/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { Component, Input, Output } from '@angular/core';
import { Subject } from 'rxjs';
import { ArlasColorService } from '../../../services/color.generator.service';
import { Item } from '../model/item';
import { ItemComponent } from '../model/itemComponent';
import { CellBackgroundStyleEnum } from '../utils/enumerations/cellBackgroundStyleEnum';
import { ResultListOptions } from '../utils/results.utils';
import { TranslateService } from '@ngx-translate/core';
import { NUMBER_FORMAT_CHAR } from '../../componentsUtils';
import { marker } from '@colsen1991/ngx-translate-extract-marker';
import * as i0 from "@angular/core";
import * as i1 from "../../../services/color.generator.service";
import * as i2 from "@ngx-translate/core";
import * as i3 from "@angular/common";
import * as i4 from "@angular/material/icon";
import * as i5 from "@angular/material/tooltip";
import * as i6 from "../result-actions/result-actions.component";
import * as i7 from "../../../pipes/format-number/format-number.pipe";
export class ResultItemComponent extends ItemComponent {
    constructor(colorService, translate) {
        super();
        this.colorService = colorService;
        this.translate = translate;
        /**
         * @constant
         */
        this.HIDE_DETAILS = marker('Hide details');
        /**
         * @constant
         */
        this.SHOW_DETAILS = marker('Show details');
        this.CellBackgroundStyleEnum = CellBackgroundStyleEnum;
        /**
         * @Input : Angular
         * @description Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a
         * factor (between 0 and 1) that tightens this scale to [(1-colorsSaturationWeight), 1].
         * Therefore saturation of generated colors will be within this tightened scale.
         */
        this.colorsSaturationWeight = 1 / 2;
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the cells of the item (the row) according to the terms displayed
         */
        this.useColorService = false;
        /**
         * @Input : Angular
         * @description The way the cell will be colorized: filled or outlined
         */
        this.cellBackgroundStyle = CellBackgroundStyleEnum.filled;
        /**
         * @Input : Angular
         * @description Map <itemId, Set<actionIds>> : for each item, gives the list of activated actions.
        */
        this.activatedActionsPerItem = new Map();
        /**
         * @Output
         * @description Emits the list of selected items in result-list.component.
         */
        this.selectedItemsEvent = new Subject();
        /**
         * @Output
         * @description Emits the event of applying the specified action on the specified item.
         */
        this.actionOnItemEvent = new Subject();
        /**
         * @Output
         * @description Emits the selected/unselected item.
         * @deprecated
         */
        this.selectedItemPositionEvent = new Subject();
        /**
         * @Output
         * @description Emits the border line style depending on the item's toggle state.
         */
        this.borderStyleEvent = new Subject();
        this.isDetailToggled = false;
        this.detailedData = '';
        this.borderStyle = 'solid';
        this.colors = {};
        this.NUMBER_FORMAT_CHAR = NUMBER_FORMAT_CHAR;
        this.colorService.changekeysToColors$.subscribe(() => this.updateColors());
    }
    ngOnInit() {
        this.identifier = this.rowItem?.identifier;
        this.updateColors();
    }
    // Detailed data is retrieved wheb the row is toggled for the first time
    toggle() {
        if (this.rowItem.isDetailToggled === false) {
            this.retrieveAdditionalInfo(this.detailedDataRetriever, this.rowItem);
            this.borderStyle = 'dashed';
        }
        else {
            this.borderStyle = 'solid';
        }
        this.borderStyleEvent.next(this.borderStyle);
        this.rowItem.isDetailToggled = !this.rowItem.isDetailToggled;
    }
    // Update the list of the selected items
    setSelectedItem() {
        super.setSelectedItem(this.rowItem.isChecked, this.identifier, this.selectedItems);
        this.rowItem.isChecked = !this.rowItem.isChecked;
        // Emit to the result list the fact that this checkbox has changed in order to notify the correspondant one in grid mode
        this.selectedItemsEvent.next(this.selectedItems);
    }
    determinateItem() {
        this.rowItem.isChecked = true;
        this.rowItem.isindeterminated = false;
        this.selectedItems.add(this.identifier);
        // Emit to the result list the fact that this checkbox has changed in order to notify the correspondant one in grid mode
        this.selectedItemsEvent.next(this.selectedItems);
    }
    getTextColor(key) {
        if (key !== undefined && key !== null) {
            return this.colorService.getTextColor(key.toString());
        }
        else {
            return '';
        }
    }
    triggerActionOnItem(action) {
        this.actionOnItemEvent.next({ action: action, elementidentifier: { idFieldName: this.idFieldName, idValue: this.rowItem.identifier } });
    }
    updateColors() {
        const newColor = {};
        this.rowItem?.columns.forEach(c => {
            if (c.useColorService) {
                const key = this.rowItem?.itemData.get(c.fieldName);
                if (key !== undefined && key !== null) {
                    newColor[key.toString()] = {};
                    newColor[key.toString()]['color'] = this.getColor(key);
                    newColor[key.toString()]['textColor'] = this.getTextColor(key);
                }
            }
        });
        this.colors = newColor;
    }
    getColor(key) {
        if (key !== undefined && key !== null) {
            return this.colorService.getColor(key.toString(), this.keysToColors, this.colorsSaturationWeight);
        }
        else {
            return '';
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultItemComponent, deps: [{ token: i1.ArlasColorService }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ResultItemComponent, selector: "[arlas-result-item]", inputs: { options: "options", rowItem: "rowItem", idFieldName: "idFieldName", detailedDataRetriever: "detailedDataRetriever", selectedItems: "selectedItems", keysToColors: "keysToColors", colorsSaturationWeight: "colorsSaturationWeight", useColorService: "useColorService", cellBackgroundStyle: "cellBackgroundStyle", activatedActionsPerItem: "activatedActionsPerItem", tableWidth: "tableWidth" }, outputs: { selectedItemsEvent: "selectedItemsEvent", actionOnItemEvent: "actionOnItemEvent", selectedItemPositionEvent: "selectedItemPositionEvent", borderStyleEvent: "borderStyleEvent" }, usesInheritance: true, ngImport: i0, template: "  <ng-container *ngFor=\"let column of rowItem?.columns;\">\n    <!-- If the column corresponds to an id field, then we put the checkbox that enables to check the item-->\n    <td *ngIf=\"column.isIdField\" class=\"resultitem__cell\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\" >\n      <div class=\"checkbox\">\n        <mat-icon *ngIf=\"rowItem?.isChecked && !rowItem?.isindeterminated\"  (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box</mat-icon>\n        <mat-icon *ngIf=\"!rowItem?.isChecked && !rowItem?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box_outline_blank</mat-icon>\n        <mat-icon *ngIf=\"rowItem?.isindeterminated\" (click)=\"determinateItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">indeterminate_check_box</mat-icon>\n      </div>\n    </td>\n\n    <!-- If the column is not an id field nor a toggle, then we put the value of the corespondant field-->\n    <td *ngIf=\"!column.isIdField && !column.isToggleField\" class=\"resultitem__cell resultitem__cell__{{column.fieldName}}\"\n          [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\">\n      <label *ngIf=\"(!useColorService || !column.useColorService || cellBackgroundStyle === undefined); else labelModeIsDefined\" class=\"resultitem__cell--label resultitem__cell--label__{{column.fieldName}}  resultitem__cell--label__{{rowItem?.itemData.get(column.fieldName)}}\">\n        {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n      </label>\n      <ng-template #labelModeIsDefined>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.filled && column.useColorService\" class=\"resultitem__cell--label resultitem__cell--label__filled\"\n          [style.background-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'transparent'\" \n          [style.color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ?  colors[rowItem?.itemData.get(column.fieldName)]['textColor'] : 'black'\">\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.outlined && column.useColorService && !!rowItem?.itemData.get(column.fieldName) && rowItem?.itemData.get(column.fieldName) !== ''\" class=\"resultitem__cell--label resultitem__cell--label__outlined\"\n          [style.border-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'black'\"  >\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n      </ng-template>\n    </td>\n\n    <!-- If the column is a toggle, then we put the + button that enables to fetch detailed data of the item-->\n    <td *ngIf=\"column.isToggleField\" class=\"resultitem__cell toggle\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\">\n      <div *ngIf=\"options.showActionsOnhover\" class=\"actions\">\n        <arlas-result-actions\n          [item]=\"rowItem\"\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [width]=\"tableWidth * 80 / 100\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\"></arlas-result-actions>\n      </div>\n      <mat-icon id= \"{{'open-detail-' + rowItem?.identifier}}\" matTooltip=\"{{SHOW_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" *ngIf=\"!rowItem?.isDetailToggled; else cancel_toggle\" (click) = \"toggle()\">{{options.showDetailIconName}}</mat-icon>\n      <ng-template #cancel_toggle>\n        <mat-icon id= \"{{'close-detail-' + rowItem?.identifier}}\"   matTooltip=\"{{HIDE_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" (click) = \"toggle()\">{{options.hideDetailIconName}}</mat-icon>\n      </ng-template>\n    </td>\n\n  </ng-container>\n\n\n\n", styles: [".resultitem__cell{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;text-align:left;vertical-align:middle;box-sizing:border-box}.resultitem__cell__toggle--icon{font-size:18px;width:18px;height:18px;display:block;cursor:pointer}.resultitem__cell--label{margin:0}.resultitem__icon_check{float:right;font-size:15px;width:15px;height:15px;cursor:pointer}.resultitem__cell--label__filled{padding:2px;border-radius:2px}.resultitem__cell--label__outlined{padding:2px;border-radius:2px;border:1.5px solid;display:inline-grid}.toggle{position:relative;cursor:pointer}.actions{position:absolute;right:35px;top:0;height:100%;width:100%}\n"], dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "component", type: i6.ResultActionsComponent, selector: "arlas-result-actions", inputs: ["item", "width", "activatedActionsPerItem", "detailedDataRetriever", "stopPropagation", "mode"], outputs: ["actionOnItemEvent"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }, { kind: "pipe", type: i7.FormatNumberPipe, name: "formatNumber" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultItemComponent, decorators: [{
            type: Component,
            args: [{ selector: '[arlas-result-item]', template: "  <ng-container *ngFor=\"let column of rowItem?.columns;\">\n    <!-- If the column corresponds to an id field, then we put the checkbox that enables to check the item-->\n    <td *ngIf=\"column.isIdField\" class=\"resultitem__cell\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\" >\n      <div class=\"checkbox\">\n        <mat-icon *ngIf=\"rowItem?.isChecked && !rowItem?.isindeterminated\"  (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box</mat-icon>\n        <mat-icon *ngIf=\"!rowItem?.isChecked && !rowItem?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box_outline_blank</mat-icon>\n        <mat-icon *ngIf=\"rowItem?.isindeterminated\" (click)=\"determinateItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">indeterminate_check_box</mat-icon>\n      </div>\n    </td>\n\n    <!-- If the column is not an id field nor a toggle, then we put the value of the corespondant field-->\n    <td *ngIf=\"!column.isIdField && !column.isToggleField\" class=\"resultitem__cell resultitem__cell__{{column.fieldName}}\"\n          [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\">\n      <label *ngIf=\"(!useColorService || !column.useColorService || cellBackgroundStyle === undefined); else labelModeIsDefined\" class=\"resultitem__cell--label resultitem__cell--label__{{column.fieldName}}  resultitem__cell--label__{{rowItem?.itemData.get(column.fieldName)}}\">\n        {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n      </label>\n      <ng-template #labelModeIsDefined>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.filled && column.useColorService\" class=\"resultitem__cell--label resultitem__cell--label__filled\"\n          [style.background-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'transparent'\" \n          [style.color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ?  colors[rowItem?.itemData.get(column.fieldName)]['textColor'] : 'black'\">\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.outlined && column.useColorService && !!rowItem?.itemData.get(column.fieldName) && rowItem?.itemData.get(column.fieldName) !== ''\" class=\"resultitem__cell--label resultitem__cell--label__outlined\"\n          [style.border-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'black'\"  >\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n      </ng-template>\n    </td>\n\n    <!-- If the column is a toggle, then we put the + button that enables to fetch detailed data of the item-->\n    <td *ngIf=\"column.isToggleField\" class=\"resultitem__cell toggle\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\">\n      <div *ngIf=\"options.showActionsOnhover\" class=\"actions\">\n        <arlas-result-actions\n          [item]=\"rowItem\"\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [width]=\"tableWidth * 80 / 100\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\"></arlas-result-actions>\n      </div>\n      <mat-icon id= \"{{'open-detail-' + rowItem?.identifier}}\" matTooltip=\"{{SHOW_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" *ngIf=\"!rowItem?.isDetailToggled; else cancel_toggle\" (click) = \"toggle()\">{{options.showDetailIconName}}</mat-icon>\n      <ng-template #cancel_toggle>\n        <mat-icon id= \"{{'close-detail-' + rowItem?.identifier}}\"   matTooltip=\"{{HIDE_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" (click) = \"toggle()\">{{options.hideDetailIconName}}</mat-icon>\n      </ng-template>\n    </td>\n\n  </ng-container>\n\n\n\n", styles: [".resultitem__cell{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;text-align:left;vertical-align:middle;box-sizing:border-box}.resultitem__cell__toggle--icon{font-size:18px;width:18px;height:18px;display:block;cursor:pointer}.resultitem__cell--label{margin:0}.resultitem__icon_check{float:right;font-size:15px;width:15px;height:15px;cursor:pointer}.resultitem__cell--label__filled{padding:2px;border-radius:2px}.resultitem__cell--label__outlined{padding:2px;border-radius:2px;border:1.5px solid;display:inline-grid}.toggle{position:relative;cursor:pointer}.actions{position:absolute;right:35px;top:0;height:100%;width:100%}\n"] }]
        }], ctorParameters: () => [{ type: i1.ArlasColorService }, { type: i2.TranslateService }], propDecorators: { options: [{
                type: Input
            }], rowItem: [{
                type: Input
            }], idFieldName: [{
                type: Input
            }], detailedDataRetriever: [{
                type: Input
            }], selectedItems: [{
                type: Input
            }], keysToColors: [{
                type: Input
            }], colorsSaturationWeight: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], cellBackgroundStyle: [{
                type: Input
            }], activatedActionsPerItem: [{
                type: Input
            }], tableWidth: [{
                type: Input
            }], selectedItemsEvent: [{
                type: Output
            }], actionOnItemEvent: [{
                type: Output
            }], selectedItemPositionEvent: [{
                type: Output
            }], borderStyleEvent: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdWx0LWl0ZW0uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYXJsYXMtY29tcG9uZW50cy9zcmMvbGliL2NvbXBvbmVudHMvcmVzdWx0cy9yZXN1bHQtaXRlbS9yZXN1bHQtaXRlbS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hcmxhcy1jb21wb25lbnRzL3NyYy9saWIvY29tcG9uZW50cy9yZXN1bHRzL3Jlc3VsdC1pdGVtL3Jlc3VsdC1pdGVtLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXZELE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLCtDQUErQyxDQUFDO0FBQ3hGLE9BQU8sRUFBNkIsaUJBQWlCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sMENBQTBDLENBQUM7Ozs7Ozs7OztBQVFsRSxNQUFNLE9BQU8sbUJBQW9CLFNBQVEsYUFBYTtJQTRHcEQsWUFBMEIsWUFBK0IsRUFBUyxTQUEyQjtRQUMzRixLQUFLLEVBQUUsQ0FBQztR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b3VyY2VzQ29udGVudCI6WyIvKlxuICogTGljZW5zZWQgdG8gR2lzYcOvYSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRS50eHQgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBHaXNhw69hIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFybGFzQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvY29sb3IuZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgSXRlbSB9IGZyb20gJy4uL21vZGVsL2l0ZW0nO1xuaW1wb3J0IHsgSXRlbUNvbXBvbmVudCB9IGZyb20gJy4uL21vZGVsL2l0ZW1Db21wb25lbnQnO1xuaW1wb3J0IHsgRGV0YWlsZWREYXRhUmV0cmlldmVyIH0gZnJvbSAnLi4vdXRpbHMvZGV0YWlsZWQtZGF0YS1yZXRyaWV2ZXInO1xuaW1wb3J0IHsgQ2VsbEJhY2tncm91bmRTdHlsZUVudW0gfSBmcm9tICcuLi91dGlscy9lbnVtZXJhdGlvbnMvY2VsbEJhY2tncm91bmRTdHlsZUVudW0nO1xuaW1wb3J0IHsgQWN0aW9uLCBFbGVtZW50SWRlbnRpZmllciwgUmVzdWx0TGlzdE9wdGlvbnMgfSBmcm9tICcuLi91dGlscy9yZXN1bHRzLnV0aWxzJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IE5VTUJFUl9GT1JNQVRfQ0hBUiB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHNVdGlscyc7XG5pbXBvcnQgeyBtYXJrZXIgfSBmcm9tICdAY29sc2VuMTk5MS9uZ3gtdHJhbnNsYXRlLWV4dHJhY3QtbWFya2VyJztcblxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdbYXJsYXMtcmVzdWx0LWl0ZW1dJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3Jlc3VsdC1pdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vcmVzdWx0LWl0ZW0uY29tcG9uZW50LmNzcyddXG59KVxuZXhwb3J0IGNsYXNzIFJlc3VsdEl0ZW1Db21wb25lbnQgZXh0ZW5kcyBJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAvKipcbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBwdWJsaWMgSElERV9ERVRBSUxTID0gbWFya2VyKCdIaWRlIGRldGFpbHMnKTtcbiAgLyoqXG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgcHVibGljIFNIT1dfREVUQUlMUyA9IG1hcmtlcignU2hvdyBkZXRhaWxzJyk7XG4gIHB1YmxpYyBDZWxsQmFja2dyb3VuZFN0eWxlRW51bSA9IENlbGxCYWNrZ3JvdW5kU3R5bGVFbnVtO1xuXG4gIC8qKlxuICAgKiBASW5wdXQgOiBBbmd1bGFyXG4gICAqIEBkZXNjcmlwdGlvbiBBbiBpbnB1dCB0byBjdXN0b21pemUgdGhlIHJlc3VsdGxpc3QgYmVoYXZpb3VyXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgb3B0aW9uczogUmVzdWx0TGlzdE9wdGlvbnM7XG4gIC8qKlxuICAgKiBASW5wdXRcbiAgICogQGRlc2NyaXB0aW9uIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYW4gSXRlbSAuXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgcm93SXRlbTogSXRlbTtcbiAgLyoqXG4gICogQElucHV0XG4gICogQGRlc2NyaXB0aW9uIE5hbWUgb2YgdGhlIGlkIGZpZWxkLlxuICAqL1xuICBASW5wdXQoKSBwdWJsaWMgaWRGaWVsZE5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIEBJbnB1dFxuICAgKiBAZGVzY3JpcHRpb24gQSBkZXRhaWxlZC1kYXRhLXJldHJpZXZlciBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG4gICAqIERldGFpbGVkRGF0YVJldHJpZXZlciBpbnRlcmZhY2UuXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgZGV0YWlsZWREYXRhUmV0cmlldmVyOiBEZXRhaWxlZERhdGFSZXRyaWV2ZXI7XG4gIC8qKlxuICAgKiBASW5wdXRcbiAgICogQGRlc2NyaXB0aW9uIExpc3Qgb2YgYWxsIHNlbGVjdGVkIGl0ZW1zIGluIHRoZSByZXN1bHQtbGlzdC5jb21wb25lbnQuXG4gICAqIFRoaXMgY29tcG9uZW50IHNldHMgZGlyZWN0bHkgdGhpcyBsaXN0LlxuICAgKi9cbiAgQElucHV0KCkgcHVibGljIHNlbGVjdGVkSXRlbXM6IFNldDxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBASW5wdXQgOiBBbmd1bGFyXG4gICAqIEBkZXNjcmlwdGlvbiBMaXN0IG9mIFtrZXksIGNvbG9yXSBjb3VwbGVzIHRoYXQgYXNzb2NpYXRlcyBhIGhleCBjb2xvciB0byBlYWNoIGtleVxuICAgKi9cbiAgQElucHV0KCkgcHVibGljIGtleXNUb0NvbG9yczogQXJyYXk8W3N0cmluZywgc3RyaW5nXT47XG5cbiAgLyoqXG4gICAqIEBJbnB1dCA6IEFuZ3VsYXJcbiAgICogQGRlc2NyaXB0aW9uIEtub3dpbmcgdGhhdCBzYXR1cmF0aW9uIHNjYWxlIGlzIFswLCAxXSwgYGNvbG9yc1NhdHVyYXRpb25XZWlnaHRgIGlzIGFcbiAgICogZmFjdG9yIChiZXR3ZWVuIDAgYW5kIDEpIHRoYXQgdGlnaHRlbnMgdGhpcyBzY2FsZSB0byBbKDEtY29sb3JzU2F0dXJhdGlvbldlaWdodCksIDFdLlxuICAgKiBUaGVyZWZvcmUgc2F0dXJhdGlvbiBvZiBnZW5lcmF0ZWQgY29sb3JzIHdpbGwgYmUgd2l0aGluIHRoaXMgdGlnaHRlbmVkIHNjYWxlLlxuICAgKi9cbiAgQElucHV0KCkgcHVibGljIGNvbG9yc1NhdHVyYXRpb25XZWlnaHQgPSAxIC8gMjtcblxuICAvKipcbiAgICogQElucHV0IDogQW5ndWxhclxuICAgKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBhbGxvdyBjb2xvcml6aW5nIHRoZSBjZWxscyBvZiB0aGUgaXRlbSAodGhlIHJvdykgYWNjb3JkaW5nIHRvIHRoZSB0ZXJtcyBkaXNwbGF5ZWRcbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyB1c2VDb2xvclNlcnZpY2UgPSBmYWxzZTtcblxuICAvKipcbiAgICogQElucHV0IDogQW5ndWxhclxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHdheSB0aGUgY2VsbCB3aWxsIGJlIGNvbG9yaXplZDogZmlsbGVkIG9yIG91dGxpbmVkXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgY2VsbEJhY2tncm91bmRTdHlsZTogQ2VsbEJhY2tncm91bmRTdHlsZUVudW0gPSBDZWxsQmFja2dyb3VuZFN0eWxlRW51bS5maWxsZWQ7XG5cblxuICAvKipcbiAgICogQElucHV0IDogQW5ndWxhclxuICAgKiBAZGVzY3JpcHRpb24gTWFwIDxpdGVtSWQsIFNldDxhY3Rpb25JZHM+PiA6IGZvciBlYWNoIGl0ZW0sIGdpdmVzIHRoZSBsaXN0IG9mIGFjdGl2YXRlZCBhY3Rpb25zLlxuICAqL1xuICBASW5wdXQoKSBwdWJsaWMgYWN0aXZhdGVkQWN0aW9uc1Blckl0ZW06IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PiA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4oKTtcbiAgQElucHV0KCkgcHVibGljIHRhYmxlV2lkdGg6IG51bWJlcjtcbiAgLyoqXG4gICAqIEBPdXRwdXRcbiAgICogQGRlc2NyaXB0aW9uIEVtaXRzIHRoZSBsaXN0IG9mIHNlbGVjdGVkIGl0ZW1zIGluIHJlc3VsdC1saXN0LmNvbXBvbmVudC5cbiAgICovXG4gIEBPdXRwdXQoKSBwdWJsaWMgc2VsZWN0ZWRJdGVtc0V2ZW50OiBTdWJqZWN0PFNldDxzdHJpbmc+PiA9IG5ldyBTdWJqZWN0PFNldDxzdHJpbmc+PigpO1xuXG4gIC8qKlxuICAgKiBAT3V0cHV0XG4gICAqIEBkZXNjcmlwdGlvbiBFbWl0cyB0aGUgZXZlbnQgb2YgYXBwbHlpbmcgdGhlIHNwZWNpZmllZCBhY3Rpb24gb24gdGhlIHNwZWNpZmllZCBpdGVtLlxuICAgKi9cbiAgQE91dHB1dCgpIHB1YmxpYyBhY3Rpb25Pbkl0ZW1FdmVudDogU3ViamVjdDx7IGFjdGlvbjogQWN0aW9uOyBlbGVtZW50aWRlbnRpZmllcjogRWxlbWVudElkZW50aWZpZXI7IH0+ID1cbiAgICBuZXcgU3ViamVjdDx7IGFjdGlvbjogQWN0aW9uOyBlbGVtZW50aWRlbnRpZmllcjogRWxlbWVudElkZW50aWZpZXI7IH0+KCk7XG5cbiAgLyoqXG4gICAqIEBPdXRwdXRcbiAgICogQGRlc2NyaXB0aW9uIEVtaXRzIHRoZSBzZWxlY3RlZC91bnNlbGVjdGVkIGl0ZW0uXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBAT3V0cHV0KCkgcHVibGljIHNlbGVjdGVkSXRlbVBvc2l0aW9uRXZlbnQ6IFN1YmplY3Q8SXRlbT4gPSBuZXcgU3ViamVjdDxJdGVtPigpO1xuXG4gIC8qKlxuICAgKiBAT3V0cHV0XG4gICAqIEBkZXNjcmlwdGlvbiBFbWl0cyB0aGUgYm9yZGVyIGxpbmUgc3R5bGUgZGVwZW5kaW5nIG9uIHRoZSBpdGVtJ3MgdG9nZ2xlIHN0YXRlLlxuICAgKi9cbiAgQE91dHB1dCgpIHB1YmxpYyBib3JkZXJTdHlsZUV2ZW50OiBTdWJqZWN0PHN0cmluZz4gPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG5cbiAgcHVibGljIGlzRGV0YWlsVG9nZ2xlZCA9IGZhbHNlO1xuICBwdWJsaWMgZGV0YWlsZWREYXRhID0gJyc7XG4gIHB1YmxpYyBhY3Rpb25zO1xuICBwdWJsaWMgYm9yZGVyU3R5bGUgPSAnc29saWQnO1xuICBwdWJsaWMgY29sb3JzID0ge307XG4gIHByb3RlY3RlZCBpZGVudGlmaWVyOiBzdHJpbmc7XG5cbiAgcHVibGljIE5VTUJFUl9GT1JNQVRfQ0hBUiA9IE5VTUJFUl9GT1JNQVRfQ0hBUjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIGNvbG9yU2VydmljZTogQXJsYXNDb2xvclNlcnZpY2UsIHB1YmxpYyB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29sb3JTZXJ2aWNlLmNoYW5nZWtleXNUb0NvbG9ycyQuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlQ29sb3JzKCkpO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIHRoaXMuaWRlbnRpZmllciA9IHRoaXMucm93SXRlbT8uaWRlbnRpZmllcjtcbiAgICB0aGlzLnVwZGF0ZUNvbG9ycygpO1xuXG4gIH1cblxuICAvLyBEZXRhaWxlZCBkYXRhIGlzIHJldHJpZXZlZCB3aGViIHRoZSByb3cgaXMgdG9nZ2xlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5yb3dJdGVtLmlzRGV0YWlsVG9nZ2xlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmV0cmlldmVBZGRpdGlvbmFsSW5mbyh0aGlzLmRldGFpbGVkRGF0YVJldHJpZXZlciwgdGhpcy5yb3dJdGVtKTtcbiAgICAgIHRoaXMuYm9yZGVyU3R5bGUgPSAnZGFzaGVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gICAgfVxuICAgIHRoaXMuYm9yZGVyU3R5bGVFdmVudC5uZXh0KHRoaXMuYm9yZGVyU3R5bGUpO1xuICAgIHRoaXMucm93SXRlbS5pc0RldGFpbFRvZ2dsZWQgPSAhdGhpcy5yb3dJdGVtLmlzRGV0YWlsVG9nZ2xlZDtcblxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBsaXN0IG9mIHRoZSBzZWxlY3RlZCBpdGVtc1xuICBwdWJsaWMgc2V0U2VsZWN0ZWRJdGVtKCkge1xuICAgIHN1cGVyLnNldFNlbGVjdGVkSXRlbSh0aGlzLnJvd0l0ZW0uaXNDaGVja2VkLCB0aGlzLmlkZW50aWZpZXIsIHRoaXMuc2VsZWN0ZWRJdGVtcyk7XG4gICAgdGhpcy5yb3dJdGVtLmlzQ2hlY2tlZCA9ICF0aGlzLnJvd0l0ZW0uaXNDaGVja2VkO1xuICAgIC8vIEVtaXQgdG8gdGhlIHJlc3VsdCBsaXN0IHRoZSBmYWN0IHRoYXQgdGhpcyBjaGVja2JveCBoYXMgY2hhbmdlZCBpbiBvcmRlciB0byBub3RpZnkgdGhlIGNvcnJlc3BvbmRhbnQgb25lIGluIGdyaWQgbW9kZVxuICAgIHRoaXMuc2VsZWN0ZWRJdGVtc0V2ZW50Lm5leHQodGhpcy5zZWxlY3RlZEl0ZW1zKTtcbiAgfVxuICBwdWJsaWMgZGV0ZXJtaW5hdGVJdGVtKCkge1xuICAgIHRoaXMucm93SXRlbS5pc0NoZWNrZWQgPSB0cnVlO1xuICAgIHRoaXMucm93SXRlbS5pc2luZGV0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zZWxlY3RlZEl0ZW1zLmFkZCh0aGlzLmlkZW50aWZpZXIpO1xuICAgIC8vIEVtaXQgdG8gdGhlIHJlc3VsdCBsaXN0IHRoZSBmYWN0IHRoYXQgdGhpcyBjaGVja2JveCBoYXMgY2hhbmdlZCBpbiBvcmRlciB0byBub3RpZnkgdGhlIGNvcnJlc3BvbmRhbnQgb25lIGluIGdyaWQgbW9kZVxuICAgIHRoaXMuc2VsZWN0ZWRJdGVtc0V2ZW50Lm5leHQodGhpcy5zZWxlY3RlZEl0ZW1zKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUZXh0Q29sb3Ioa2V5KTogc3RyaW5nIHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xvclNlcnZpY2UuZ2V0VGV4dENvbG9yKGtleS50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB0cmlnZ2VyQWN0aW9uT25JdGVtKGFjdGlvbjogQWN0aW9uKSB7XG4gICAgdGhpcy5hY3Rpb25Pbkl0ZW1FdmVudC5uZXh0KHsgYWN0aW9uOiBhY3Rpb24sIGVsZW1lbnRpZGVudGlmaWVyOiB7IGlkRmllbGROYW1lOiB0aGlzLmlkRmllbGROYW1lLCBpZFZhbHVlOiB0aGlzLnJvd0l0ZW0uaWRlbnRpZmllciB9IH0pO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDb2xvcnMoKSB7XG4gICAgY29uc3QgbmV3Q29sb3IgPSB7fTtcbiAgICB0aGlzLnJvd0l0ZW0/LmNvbHVtbnMuZm9yRWFjaChjID0+IHtcbiAgICAgIGlmIChjLnVzZUNvbG9yU2VydmljZSl7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMucm93SXRlbT8uaXRlbURhdGEuZ2V0KGMuZmllbGROYW1lKTtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5ld0NvbG9yW2tleS50b1N0cmluZygpXSA9IHt9O1xuICAgICAgICAgIG5ld0NvbG9yW2tleS50b1N0cmluZygpXVsnY29sb3InXSA9IHRoaXMuZ2V0Q29sb3Ioa2V5KTtcbiAgICAgICAgICBuZXdDb2xvcltrZXkudG9TdHJpbmcoKV1bJ3RleHRDb2xvciddID0gdGhpcy5nZXRUZXh0Q29sb3Ioa2V5KTtcblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jb2xvcnMgPSBuZXdDb2xvcjtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q29sb3Ioa2V5KTogc3RyaW5nIHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xvclNlcnZpY2UuZ2V0Q29sb3Ioa2V5LnRvU3RyaW5nKCksIHRoaXMua2V5c1RvQ29sb3JzLCB0aGlzLmNvbG9yc1NhdHVyYXRpb25XZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cblxuXG59XG4iLCIgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiByb3dJdGVtPy5jb2x1bW5zO1wiPlxuICAgIDwhLS0gSWYgdGhlIGNvbHVtbiBjb3JyZXNwb25kcyB0byBhbiBpZCBmaWVsZCwgdGhlbiB3ZSBwdXQgdGhlIGNoZWNrYm94IHRoYXQgZW5hYmxlcyB0byBjaGVjayB0aGUgaXRlbS0tPlxuICAgIDx0ZCAqbmdJZj1cImNvbHVtbi5pc0lkRmllbGRcIiBjbGFzcz1cInJlc3VsdGl0ZW1fX2NlbGxcIiBbc3R5bGUubWF4LXdpZHRoLnB4XT1cImNvbHVtbi53aWR0aFwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sdW1uLndpZHRoXCIgPlxuICAgICAgPGRpdiBjbGFzcz1cImNoZWNrYm94XCI+XG4gICAgICAgIDxtYXQtaWNvbiAqbmdJZj1cInJvd0l0ZW0/LmlzQ2hlY2tlZCAmJiAhcm93SXRlbT8uaXNpbmRldGVybWluYXRlZFwiICAoY2xpY2spPVwic2V0U2VsZWN0ZWRJdGVtKClcIiBjbGFzcz1cInByaW1hcnkgcmVzdWx0aXRlbV9faWNvbl9jaGVjayBtYXQtaWNvbiBtYXRlcmlhbC1pY29uc1wiPmNoZWNrX2JveDwvbWF0LWljb24+XG4gICAgICAgIDxtYXQtaWNvbiAqbmdJZj1cIiFyb3dJdGVtPy5pc0NoZWNrZWQgJiYgIXJvd0l0ZW0/LmlzaW5kZXRlcm1pbmF0ZWRcIiAoY2xpY2spPVwic2V0U2VsZWN0ZWRJdGVtKClcIiBjbGFzcz1cInByaW1hcnkgcmVzdWx0aXRlbV9faWNvbl9jaGVjayBtYXQtaWNvbiBtYXRlcmlhbC1pY29uc1wiPmNoZWNrX2JveF9vdXRsaW5lX2JsYW5rPC9tYXQtaWNvbj5cbiAgICAgICAgPG1hdC1pY29uICpuZ0lmPVwicm93SXRlbT8uaXNpbmRldGVybWluYXRlZFwiIChjbGljayk9XCJkZXRlcm1pbmF0ZUl0ZW0oKVwiIGNsYXNzPVwicHJpbWFyeSByZXN1bHRpdGVtX19pY29uX2NoZWNrIG1hdC1pY29uIG1hdGVyaWFsLWljb25zXCI+aW5kZXRlcm1pbmF0ZV9jaGVja19ib3g8L21hdC1pY29uPlxuICAgICAgPC9kaXY+XG4gICAgPC90ZD5cblxuICAgIDwhLS0gSWYgdGhlIGNvbHVtbiBpcyBub3QgYW4gaWQgZmllbGQgbm9yIGEgdG9nZ2xlLCB0aGVuIHdlIHB1dCB0aGUgdmFsdWUgb2YgdGhlIGNvcmVzcG9uZGFudCBmaWVsZC0tPlxuICAgIDx0ZCAqbmdJZj1cIiFjb2x1bW4uaXNJZEZpZWxkICYmICFjb2x1bW4uaXNUb2dnbGVGaWVsZFwiIGNsYXNzPVwicmVzdWx0aXRlbV9fY2VsbCByZXN1bHRpdGVtX19jZWxsX197e2NvbHVtbi5maWVsZE5hbWV9fVwiXG4gICAgICAgICAgW3N0eWxlLm1heC13aWR0aC5weF09XCJjb2x1bW4ud2lkdGhcIlxuICAgICAgICAgIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sdW1uLndpZHRoXCI+XG4gICAgICA8bGFiZWwgKm5nSWY9XCIoIXVzZUNvbG9yU2VydmljZSB8fCAhY29sdW1uLnVzZUNvbG9yU2VydmljZSB8fCBjZWxsQmFja2dyb3VuZFN0eWxlID09PSB1bmRlZmluZWQpOyBlbHNlIGxhYmVsTW9kZUlzRGVmaW5lZFwiIGNsYXNzPVwicmVzdWx0aXRlbV9fY2VsbC0tbGFiZWwgcmVzdWx0aXRlbV9fY2VsbC0tbGFiZWxfX3t7Y29sdW1uLmZpZWxkTmFtZX19ICByZXN1bHRpdGVtX19jZWxsLS1sYWJlbF9fe3tyb3dJdGVtPy5pdGVtRGF0YS5nZXQoY29sdW1uLmZpZWxkTmFtZSl9fVwiPlxuICAgICAgICB7e3Jvd0l0ZW0/Lml0ZW1EYXRhLmdldChjb2x1bW4uZmllbGROYW1lKSB8IGZvcm1hdE51bWJlcjpOVU1CRVJfRk9STUFUX0NIQVJ9fXt7Y29sdW1uLmRhdGFUeXBlfX1cbiAgICAgIDwvbGFiZWw+XG4gICAgICA8bmctdGVtcGxhdGUgI2xhYmVsTW9kZUlzRGVmaW5lZD5cbiAgICAgICAgPGxhYmVsICpuZ0lmPVwiY2VsbEJhY2tncm91bmRTdHlsZSA9PT0gQ2VsbEJhY2tncm91bmRTdHlsZUVudW0uZmlsbGVkICYmIGNvbHVtbi51c2VDb2xvclNlcnZpY2VcIiBjbGFzcz1cInJlc3VsdGl0ZW1fX2NlbGwtLWxhYmVsIHJlc3VsdGl0ZW1fX2NlbGwtLWxhYmVsX19maWxsZWRcIlxuICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cIiEhY29sb3JzW3Jvd0l0ZW0/Lml0ZW1EYXRhLmdldChjb2x1bW4uZmllbGROYW1lKV0gPyBjb2xvcnNbcm93SXRlbT8uaXRlbURhdGEuZ2V0KGNvbHVtbi5maWVsZE5hbWUpXVsnY29sb3InXSA6ICd0cmFuc3BhcmVudCdcIiBcbiAgICAgICAgICBbc3R5bGUuY29sb3JdPVwiISFjb2xvcnNbcm93SXRlbT8uaXRlbURhdGEuZ2V0KGNvbHVtbi5maWVsZE5hbWUpXSA/ICBjb2xvcnNbcm93SXRlbT8uaXRlbURhdGEuZ2V0KGNvbHVtbi5maWVsZE5hbWUpXVsndGV4dENvbG9yJ10gOiAnYmxhY2snXCI+XG4gICAgICAgICAge3tyb3dJdGVtPy5pdGVtRGF0YS5nZXQoY29sdW1uLmZpZWxkTmFtZSkgfCBmb3JtYXROdW1iZXI6TlVNQkVSX0ZPUk1BVF9DSEFSfX17e2NvbHVtbi5kYXRhVHlwZX19XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cImNlbGxCYWNrZ3JvdW5kU3R5bGUgPT09IENlbGxCYWNrZ3JvdW5kU3R5bGVFbnVtLm91dGxpbmVkICYmIGNvbHVtbi51c2VDb2xvclNlcnZpY2UgJiYgISFyb3dJdGVtPy5pdGVtRGF0YS5nZXQoY29sdW1uLmZpZWxkTmFtZSkgJiYgcm93SXRlbT8uaXRlbURhdGEuZ2V0KGNvbHVtbi5maWVsZE5hbWUpICE9PSAnJ1wiIGNsYXNzPVwicmVzdWx0aXRlbV9fY2VsbC0tbGFiZWwgcmVzdWx0aXRlbV9fY2VsbC0tbGFiZWxfX291dGxpbmVkXCJcbiAgICAgICAgICBbc3R5bGUuYm9yZGVyLWNvbG9yXT1cIiEhY29sb3JzW3Jvd0l0ZW0/Lml0ZW1EYXRhLmdldChjb2x1bW4uZmllbGROYW1lKV0gPyBjb2xvcnNbcm93SXRlbT8uaXRlbURhdGEuZ2V0KGNvbHVtbi5maWVsZE5hbWUpXVsnY29sb3InXSA6ICdibGFjaydcIiAgPlxuICAgICAgICAgIHt7cm93SXRlbT8uaXRlbURhdGEuZ2V0KGNvbHVtbi5maWVsZE5hbWUpIHwgZm9ybWF0TnVtYmVyOk5VTUJFUl9GT1JNQVRfQ0hBUn19e3tjb2x1bW4uZGF0YVR5cGV9fVxuICAgICAgICA8L2xhYmVsPlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RkPlxuXG4gICAgPCEtLSBJZiB0aGUgY29sdW1uIGlzIGEgdG9nZ2xlLCB0aGVuIHdlIHB1dCB0aGUgKyBidXR0b24gdGhhdCBlbmFibGVzIHRvIGZldGNoIGRldGFpbGVkIGRhdGEgb2YgdGhlIGl0ZW0tLT5cbiAgICA8dGQgKm5nSWY9XCJjb2x1bW4uaXNUb2dnbGVGaWVsZFwiIGNsYXNzPVwicmVzdWx0aXRlbV9fY2VsbCB0b2dnbGVcIiBbc3R5bGUubWF4LXdpZHRoLnB4XT1cImNvbHVtbi53aWR0aFwiIFtzdHlsZS5taW4td2lkdGgucHhdPVwiY29sdW1uLndpZHRoXCI+XG4gICAgICA8ZGl2ICpuZ0lmPVwib3B0aW9ucy5zaG93QWN0aW9uc09uaG92ZXJcIiBjbGFzcz1cImFjdGlvbnNcIj5cbiAgICAgICAgPGFybGFzLXJlc3VsdC1hY3Rpb25zXG4gICAgICAgICAgW2l0ZW1dPVwicm93SXRlbVwiXG4gICAgICAgICAgW2FjdGl2YXRlZEFjdGlvbnNQZXJJdGVtXT1cImFjdGl2YXRlZEFjdGlvbnNQZXJJdGVtXCJcbiAgICAgICAgICBbZGV0YWlsZWREYXRhUmV0cmlldmVyXT1cImRldGFpbGVkRGF0YVJldHJpZXZlclwiXG4gICAgICAgICAgW3dpZHRoXT1cInRhYmxlV2lkdGggKiA4MCAvIDEwMFwiXG4gICAgICAgICAgKGFjdGlvbk9uSXRlbUV2ZW50KT1cInRyaWdnZXJBY3Rpb25Pbkl0ZW0oJGV2ZW50KVwiPjwvYXJsYXMtcmVzdWx0LWFjdGlvbnM+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxtYXQtaWNvbiBpZD0gXCJ7eydvcGVuLWRldGFpbC0nICsgcm93SXRlbT8uaWRlbnRpZmllcn19XCIgbWF0VG9vbHRpcD1cInt7U0hPV19ERVRBSUxTIHwgdHJhbnNsYXRlfX1cIiBjbGFzcz1cInJlc3VsdGl0ZW1fX2NlbGxfX3RvZ2dsZS0taWNvblwiICpuZ0lmPVwiIXJvd0l0ZW0/LmlzRGV0YWlsVG9nZ2xlZDsgZWxzZSBjYW5jZWxfdG9nZ2xlXCIgKGNsaWNrKSA9IFwidG9nZ2xlKClcIj57e29wdGlvbnMuc2hvd0RldGFpbEljb25OYW1lfX08L21hdC1pY29uPlxuICAgICAgPG5nLXRlbXBsYXRlICNjYW5jZWxfdG9nZ2xlPlxuICAgICAgICA8bWF0LWljb24gaWQ9IFwie3snY2xvc2UtZGV0YWlsLScgKyByb3dJdGVtPy5pZGVudGlmaWVyfX1cIiAgIG1hdFRvb2x0aXA9XCJ7e0hJREVfREVUQUlMUyB8IHRyYW5zbGF0ZX19XCIgY2xhc3M9XCJyZXN1bHRpdGVtX19jZWxsX190b2dnbGUtLWljb25cIiAoY2xpY2spID0gXCJ0b2dnbGUoKVwiPnt7b3B0aW9ucy5oaWRlRGV0YWlsSWNvbk5hbWV9fTwvbWF0LWljb24+XG4gICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvdGQ+XG5cbiAgPC9uZy1jb250YWluZXI+XG5cblxuXG4iXX0=