/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { PowerBar } from '../powerbars/model/powerbar';
import * as tinycolor from 'tinycolor2';
import { ArlasColorService } from '../../services/color.generator.service';
import * as metricTableJsonSchema from './metrics-table.schema.json';
import * as i0 from "@angular/core";
import * as i1 from "../../services/color.generator.service";
import * as i2 from "@angular/material/tooltip";
import * as i3 from "@angular/common";
import * as i4 from "./multi-bars-row/metrics-table-row.component";
import * as i5 from "@ngx-translate/core";
import * as i6 from "../../pipes/get-collection-display-name/get-collection-display-name.pipe";
import * as i7 from "../../pipes/get-field-display-name/get-field-display-name.pipe";
export class MetricsTableComponent {
    constructor(colorService, cdr) {
        this.colorService = colorService;
        this.cdr = cdr;
        /**
           * @Input : Angular
           * @description Options about how to apply filters on metrics table
           * - value : The default value.
           *           if 'Eq', the selected line is included in the ARLAS filter.
           *           if 'Neq', the selected line is excluded in the ARLAS filter.
           * - display: Whether to display a switcher between 'Eq' and 'Neq' or keep the default operator all the time
           */
        this.filterOperator = {
            value: 'Eq',
            display: true
        };
        /**
         * @Output : Angular
         * @description Emits the filter operator
         */
        this.filterOperatorEvent = new EventEmitter();
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the bar according to its term or not using keysToColors
         */
        this.useColorService = false;
        /**
         * @Input : Angular
         * @description Choose how to apply colors to the table. By column : all the bars in same column will have the same color.
         * By row : all the bars in the same row, will have the same color.
         */
        this.applyColorTo = 'column';
        /**
         * @description Allow to select a row by a checkbox
         */
        this.selectWithCheckbox = true;
        /**
         * @description Allow to select display mode for headers.
         */
        this.headerDisplayMode = 'chip';
        /**
         * @description Normalise bars progression based on the maximum value of each column OR of the whole table
         */
        this.normaliseBy = 'table';
        this.showRowField = true;
        this.onSelect = new EventEmitter();
        // keep it time complexity o(1) with get.
        /** Map of <term-list.of.powerbars.corresponding.to.this.term.> */
        this.powerBarsMap = new Map();
        this.selectedKeys = new Set();
        this.selectedRows = new Map();
        this.pendingMode = false;
        this.titleAreDifferent = true;
        // preserve order of insertion
        this.originalOrder = (a, b) => 0;
        this.colorService.changekeysToColors$.subscribe(() => {
            this.powerBarsMap.forEach(powerbarsRow => {
                powerbarsRow.forEach(p => {
                    if (this.useColorService) {
                        this.defineColor(p.term);
                    }
                });
            });
        });
    }
    ngOnInit() {
        if (this.metricsTable) {
            this.updateSelectedTermWithDefaultValue();
            this.buildPowerBars();
            this.buildHeaders();
        }
    }
    ngOnChanges(changes) {
        if (changes.metricsTable) {
            if (this.metricsTable !== undefined && this.metricsTable !== null) {
                this.ngOnInit();
            }
        }
        if (changes.selectedTerms) {
            this.updateSelection(this.selectedTerms);
        }
    }
    buildHeaders() {
        this.uniqueTitles = [];
        let previousId = '';
        let nextIndex = 0;
        this.metricsTable.header.forEach((header, i) => {
            header.color = this.defineColor(header.title);
            const currentId = header.title + header.rowfield;
            if (currentId !== previousId) {
                header.span = 1;
                this.uniqueTitles.push(header);
                nextIndex++;
                previousId = currentId;
            }
            else {
                this.uniqueTitles[nextIndex - 1].span++;
            }
        });
        this.titleAreDifferent = this.uniqueTitles.length === this.metricsTable?.data[0]?.data.length;
    }
    updateSelectedTermWithDefaultValue() {
        if (this.selectedTerms && this.selectedTerms.length > 0) {
            this.selectedTerms.forEach(selectedTerm => {
                this.selectedKeys.add(selectedTerm);
            });
        }
        this.togglePendingMode();
    }
    buildPowerBars() {
        this.powerBarsMap.clear();
        this.clearAll();
        this.metricsTable.data?.forEach((merticsRow, rowIndex) => {
            this.powerBarsMap.set(merticsRow.term, []);
            merticsRow.data.forEach((item, i) => {
                let powerBar;
                if (this.applyColorTo === 'row') {
                    powerBar = new PowerBar(merticsRow.term, merticsRow.term, item?.value);
                }
                else {
                    const header = this.metricsTable.header[i];
                    powerBar = new PowerBar(header.title, header.title, item?.value);
                }
                if (item) {
                    let maxValue;
                    if (this.normaliseBy === 'table') {
                        maxValue = item.maxTableValue;
                    }
                    else {
                        maxValue = item.maxColumnValue;
                    }
                    powerBar.progression = (item.value / maxValue) * 100;
                }
                if (this.useColorService) {
                    powerBar.color = this.defineColor(powerBar.term);
                }
                if (this.selectedKeys.has(merticsRow.term)) {
                    merticsRow.selected = true;
                    this.selectedRows.set(merticsRow.term, merticsRow);
                }
                this.powerBarsMap.get(merticsRow.term).push(powerBar);
            });
        });
    }
    updateSelection(keys) {
        this.selectedKeys = new Set(keys);
        this.clearAll();
        keys.forEach(key => this.updateSelectedRow(key));
        this.togglePendingMode();
    }
    clearAll() {
        this.metricsTable?.data?.forEach(row => row.selected = false);
        this.selectedRows.clear();
    }
    addTermToSelectedList(key) {
        this.updateSelectedRow(key);
        this.updateSelectedTerm(key);
        this.togglePendingMode();
    }
    updateSelectedTerm(key) {
        if (this.selectedKeys.has(key)) {
            this.selectedKeys.delete(key);
        }
        else {
            this.selectedKeys.add(key);
        }
        this.onSelect.emit(this.selectedKeys);
    }
    updateSelectedRow(key) {
        const row = this.metricsTable.data.find(row => row.term === key);
        if (this.selectedRows.has(key)) {
            row.selected = false;
            this.selectedRows.delete(key);
        }
        else if (row) {
            row.selected = true;
            this.selectedRows.set(key, row);
        }
        else {
            /** If we select a row that does not exists, it means we data is not  */
        }
    }
    togglePendingMode() {
        this.pendingMode = this.selectedKeys.size !== 0;
    }
    trackByFn(index, item) {
        return item.term; // Use the 'id' property as the unique identifier
    }
    defineColor(key) {
        const rgbaColor = tinycolor.default(this.colorService.getColor(key, this.keysToColors, this.colorsSaturationWeight)).toRgb();
        return this.getPowerbarColor(rgbaColor);
    }
    getPowerbarColor(rgbaColor) {
        return 'rgba(' + [rgbaColor.r, rgbaColor.g, rgbaColor.b, 0.7].join(',') + ')';
    }
    static getJsonSchema() {
        return metricTableJsonSchema;
    }
    setOperator(op) {
        if (this.filterOperator.value !== op) {
            this.filterOperator.value = op;
            this.filterOperatorEvent.next(op);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableComponent, deps: [{ token: i1.ArlasColorService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MetricsTableComponent, selector: "arlas-metrics-table", inputs: { metricsTable: "metricsTable", filterOperator: "filterOperator", selectedTerms: "selectedTerms", keysToColors: "keysToColors", useColorService: "useColorService", applyColorTo: "applyColorTo", colorsSaturationWeight: "colorsSaturationWeight", selectWithCheckbox: "selectWithCheckbox", headerDisplayMode: "headerDisplayMode", normaliseBy: "normaliseBy", showRowField: "showRowField" }, outputs: { filterOperatorEvent: "filterOperatorEvent", onSelect: "onSelect" }, viewQueries: [{ propertyName: "header", first: true, predicate: ["tableHeader"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"tools\">\n  <div *ngIf=\"filterOperator && filterOperator?.display\" class=\"include_exclude\">\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Eq'\" (click)=\"setOperator('Eq')\">\n      {{'include' | translate}}</div>\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Neq'\" (click)=\"setOperator('Neq')\">\n      {{'exclude' | translate}}</div>\n  </div>\n  <div *ngIf=\"filterOperator && !filterOperator?.display && filterOperator?.value === 'Neq'\" class=\"include_exclude\">\n    <div class=\"operation\" [class.exclude]=\"filterOperator?.value === 'Neq'\">{{'exclude' | translate}}</div>\n  </div>\n</div>\n<div class=\"table-overflow-wrapper\">\n  <table class=\"multi-bar\">\n    <thead #tableHeader>\n      <!-- Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <ng-container *ngIf=\"titleAreDifferent; else displayOneTitle\">\n          <th class=\"multi-bar__header-indicator\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n            <div>\n              <div class=\"container\">\n                <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                  [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"></div>\n                <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n                <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"\n                  *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n                </div>\n              </div>\n              <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">{{\n                header.rowfield | getFieldDisplayName | translate }}</div>\n\n            </div>\n          </th>\n        </ng-container>\n        <ng-template #displayOneTitle>\n          <th *ngFor=\"let header of uniqueTitles\" class=\"multi-bar__header-indicator\"\n            [style.width.px]=\"header.span * 70\" [attr.colspan]=\"header.span\">\n            <div class=\"container\">\n              <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"></div>\n              <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n              <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"\n                *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n              </div>\n            </div>\n            <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">\n              {{header.rowfield | getFieldDisplayName | translate}}</div>\n          </th>\n        </ng-template>\n      </tr>\n      <!-- Sub Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <th class=\"column-head multi-bar__header\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n          <div *ngIf=\"header.metric !== 'count'\"\n            [matTooltip]=\"'METRIC_COLUMN_TITLE' | translate:  { metric: 'METRIC_COLUMN_' + header.metric | translate, field : header.subTitle | getFieldDisplayName | translate }\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'METRIC_COLUMN_TITLE' | translate: { metric: 'METRIC_COLUMN_' + header.metric | translate, field :\n            header.subTitle | getFieldDisplayName |\n            translate } }}\n          </div>\n          <div *ngIf=\"header.metric === 'count'\" [matTooltip]=\"'COUNT_COLUMN_TITLE' | translate\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'COUNT_COLUMN_TITLE' | translate }}\n          </div>\n        </th>\n      </tr>\n    </thead>\n    <ng-container *ngFor=\"let item of metricsTable?.data; let index = index;trackBy: trackByFn\">\n      <arlas-multi-bars-row *ngIf=\"item?.selected\" [metricsTableRow]=\"item\" [useColorFromData]=\"false\"\n        [hideSelection]=\"false\" [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(item.term)\"\n        [displayCheckBox]=\"selectWithCheckbox\" (rowSelected)=\"addTermToSelectedList($event)\">\n      </arlas-multi-bars-row>\n    </ng-container>\n    <arlas-multi-bars-row *ngFor=\"let row of metricsTable?.data; let index = index;trackBy: trackByFn\"\n      [metricsTableRow]=\"row\" [selected]=\"row.selected\" [hideSelection]=\"true\" [useColorFromData]=\"false\"\n      [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(row.term)\"\n      [displayCheckBox]=\"selectWithCheckbox\" [pendingMode]=\"pendingMode\" (rowSelected)=\"addTermToSelectedList($event)\">\n    </arlas-multi-bars-row>\n  </table>\n</div>", styles: ["@charset \"UTF-8\";:host{min-width:200px;display:block;height:100%}.tools .include_exclude{display:flex;align-items:baseline}.tools .include_exclude .operation{font-size:12px;color:#aaa;border-radius:3px;font-weight:700;margin-right:5px;cursor:pointer;padding-bottom:3px}.tools .include_exclude .selected_operation{color:#555;font-weight:700}.tools .include_exclude .exclude{color:#555;font-weight:700;cursor:unset}.table-overflow-wrapper{overflow-x:auto;overflow-y:auto;height:100%;max-width:100%}.container{display:flex;align-items:center}.header-indicator{height:10px;width:10px;display:inline-block;border-radius:10px;margin-left:2px}.separator{margin:0 2px;display:inline-block}.multi-bar{font-size:12px;border-spacing:0;width:100%;table-layout:fixed;max-height:100%;position:relative;border-collapse:collapse}.multi-bar thead{position:sticky;background:#fff;top:0;z-index:1}.multi-bar thead .terms-head{width:80px}.multi-bar thead .column-head{width:70px}.multi-bar td,.multi-bar th{white-space:nowrap}.multi-bar__header{font-size:12px;padding:0 6px 6px;text-align:center;vertical-align:bottom;border-bottom:1px solid #dadada;cursor:pointer}.multi-bar__header-indicator{padding:6px 0;text-align:center;line-height:12px;border-right:2px solid white;background:#e5e5e554;box-sizing:border-box}.multi-bar__header-title{font-size:12px;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-title-with-indicator{font-size:12px;overflow:hidden;text-overflow:ellipsis;width:calc(100% - 20px)}.multi-bar__header-rowfield{font-weight:200;margin:2px auto auto;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-item{font-weight:400;margin:0 auto;word-wrap:break-word;text-align:center}.multi-bar__header-item-title{max-height:50px;overflow:hidden;text-overflow:ellipsis}::-webkit-scrollbar{width:3px!important;height:4px!important;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}\n"], dependencies: [{ kind: "directive", type: i2.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4.MetricsTableRowComponent, selector: "arlas-multi-bars-row", inputs: ["displayCheckBox", "hideSelection", "metricsTableRow", "useColorService", "useColorFromData", "colors", "selected", "pendingMode", "powerBars"], outputs: ["rowSelected"] }, { kind: "pipe", type: i5.TranslatePipe, name: "translate" }, { kind: "pipe", type: i6.GetCollectionDisplayNamePipe, name: "getCollectionDisplayName" }, { kind: "pipe", type: i7.GetFieldDisplayNamePipe, name: "getFieldDisplayName" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-metrics-table', template: "<div class=\"tools\">\n  <div *ngIf=\"filterOperator && filterOperator?.display\" class=\"include_exclude\">\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Eq'\" (click)=\"setOperator('Eq')\">\n      {{'include' | translate}}</div>\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Neq'\" (click)=\"setOperator('Neq')\">\n      {{'exclude' | translate}}</div>\n  </div>\n  <div *ngIf=\"filterOperator && !filterOperator?.display && filterOperator?.value === 'Neq'\" class=\"include_exclude\">\n    <div class=\"operation\" [class.exclude]=\"filterOperator?.value === 'Neq'\">{{'exclude' | translate}}</div>\n  </div>\n</div>\n<div class=\"table-overflow-wrapper\">\n  <table class=\"multi-bar\">\n    <thead #tableHeader>\n      <!-- Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <ng-container *ngIf=\"titleAreDifferent; else displayOneTitle\">\n          <th class=\"multi-bar__header-indicator\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n            <div>\n              <div class=\"container\">\n                <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                  [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"></div>\n                <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n                <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"\n                  *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n                </div>\n              </div>\n              <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">{{\n                header.rowfield | getFieldDisplayName | translate }}</div>\n\n            </div>\n          </th>\n        </ng-container>\n        <ng-template #displayOneTitle>\n          <th *ngFor=\"let header of uniqueTitles\" class=\"multi-bar__header-indicator\"\n            [style.width.px]=\"header.span * 70\" [attr.colspan]=\"header.span\">\n            <div class=\"container\">\n              <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"></div>\n              <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n              <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"\n                *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n              </div>\n            </div>\n            <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">\n              {{header.rowfield | getFieldDisplayName | translate}}</div>\n          </th>\n        </ng-template>\n      </tr>\n      <!-- Sub Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <th class=\"column-head multi-bar__header\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n          <div *ngIf=\"header.metric !== 'count'\"\n            [matTooltip]=\"'METRIC_COLUMN_TITLE' | translate:  { metric: 'METRIC_COLUMN_' + header.metric | translate, field : header.subTitle | getFieldDisplayName | translate }\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'METRIC_COLUMN_TITLE' | translate: { metric: 'METRIC_COLUMN_' + header.metric | translate, field :\n            header.subTitle | getFieldDisplayName |\n            translate } }}\n          </div>\n          <div *ngIf=\"header.metric === 'count'\" [matTooltip]=\"'COUNT_COLUMN_TITLE' | translate\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'COUNT_COLUMN_TITLE' | translate }}\n          </div>\n        </th>\n      </tr>\n    </thead>\n    <ng-container *ngFor=\"let item of metricsTable?.data; let index = index;trackBy: trackByFn\">\n      <arlas-multi-bars-row *ngIf=\"item?.selected\" [metricsTableRow]=\"item\" [useColorFromData]=\"false\"\n        [hideSelection]=\"false\" [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(item.term)\"\n        [displayCheckBox]=\"selectWithCheckbox\" (rowSelected)=\"addTermToSelectedList($event)\">\n      </arlas-multi-bars-row>\n    </ng-container>\n    <arlas-multi-bars-row *ngFor=\"let row of metricsTable?.data; let index = index;trackBy: trackByFn\"\n      [metricsTableRow]=\"row\" [selected]=\"row.selected\" [hideSelection]=\"true\" [useColorFromData]=\"false\"\n      [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(row.term)\"\n      [displayCheckBox]=\"selectWithCheckbox\" [pendingMode]=\"pendingMode\" (rowSelected)=\"addTermToSelectedList($event)\">\n    </arlas-multi-bars-row>\n  </table>\n</div>", styles: ["@charset \"UTF-8\";:host{min-width:200px;display:block;height:100%}.tools .include_exclude{display:flex;align-items:baseline}.tools .include_exclude .operation{font-size:12px;color:#aaa;border-radius:3px;font-weight:700;margin-right:5px;cursor:pointer;padding-bottom:3px}.tools .include_exclude .selected_operation{color:#555;font-weight:700}.tools .include_exclude .exclude{color:#555;font-weight:700;cursor:unset}.table-overflow-wrapper{overflow-x:auto;overflow-y:auto;height:100%;max-width:100%}.container{display:flex;align-items:center}.header-indicator{height:10px;width:10px;display:inline-block;border-radius:10px;margin-left:2px}.separator{margin:0 2px;display:inline-block}.multi-bar{font-size:12px;border-spacing:0;width:100%;table-layout:fixed;max-height:100%;position:relative;border-collapse:collapse}.multi-bar thead{position:sticky;background:#fff;top:0;z-index:1}.multi-bar thead .terms-head{width:80px}.multi-bar thead .column-head{width:70px}.multi-bar td,.multi-bar th{white-space:nowrap}.multi-bar__header{font-size:12px;padding:0 6px 6px;text-align:center;vertical-align:bottom;border-bottom:1px solid #dadada;cursor:pointer}.multi-bar__header-indicator{padding:6px 0;text-align:center;line-height:12px;border-right:2px solid white;background:#e5e5e554;box-sizing:border-box}.multi-bar__header-title{font-size:12px;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-title-with-indicator{font-size:12px;overflow:hidden;text-overflow:ellipsis;width:calc(100% - 20px)}.multi-bar__header-rowfield{font-weight:200;margin:2px auto auto;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-item{font-weight:400;margin:0 auto;word-wrap:break-word;text-align:center}.multi-bar__header-item-title{max-height:50px;overflow:hidden;text-overflow:ellipsis}::-webkit-scrollbar{width:3px!important;height:4px!important;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}\n"] }]
        }], ctorParameters: () => [{ type: i1.ArlasColorService }, { type: i0.ChangeDetectorRef }], propDecorators: { metricsTable: [{
                type: Input
            }], filterOperator: [{
                type: Input
            }], filterOperatorEvent: [{
                type: Output
            }], selectedTerms: [{
                type: Input
            }], keysToColors: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], applyColorTo: [{
                type: Input
            }], colorsSaturationWeight: [{
                type: Input
            }], selectWithCheckbox: [{
                type: Input
            }], headerDisplayMode: [{
                type: Input
            }], normaliseBy: [{
                type: Input
            }], showRowField: [{
                type: Input
            }], onSelect: [{
                type: Output
            }], header: [{
                type: ViewChild,
                args: ['tableHeader']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0cmljcy10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hcmxhcy1jb21wb25lbnRzL3NyYy9saWIvY29tcG9uZW50cy9tZXRyaWNzLXRhYmxlL21ldHJpY3MtdGFibGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYXJsYXMtY29tcG9uZW50cy9zcmMvbGliL2NvbXBvbmVudHMvbWV0cmljcy10YWJsZS9tZXRyaWNzLXRhYmxlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUVILE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUdMLE1BQU0sRUFFTixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3ZELE9BQU8sS0FBSyxTQUFTLE1BQU0sWUFBWSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzNFLE9BQU8sS0FBSyxxQkFBcUIsTUFBTSw2QkFBNkIsQ0FBQzs7Ozs7Ozs7O0FBVXJFLE1BQU0sT0FBTyxxQkFBcUI7SUEwRmhDLFlBQW9DLFlBQStCLEVBQW1CLEdBQXNCO1FBQXhFLGlCQUFZLEdBQVosWUFBWSxDQUFtQjtRQUFtQixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQW5GNUc7Ozs7Ozs7YUFPSztRQUNXLG1CQUFjLEdBQW1CO1lBQy9DLEtBQUssRUFBRSxJQUFJO1lBQ1gsT0FBTyxFQUFFLElBQUk7U0FDZCxDQUFDO1FBQ0Y7OztXQUdHO1FBQ2Msd0JBQW1CLEdBQStCLElBQUksWUFBWSxFQUFFLENBQUM7UUFldEY7OztXQUdHO1FBQ2Esb0JBQWUsR0FBRyxLQUFLLENBQUM7UUFFeEM7Ozs7V0FJRztRQUNhLGlCQUFZLEdBQXFCLFFBQVEsQ0FBQztRQVUxRDs7V0FFRztRQUNhLHVCQUFrQixHQUFHLElBQUksQ0FBQztRQUUxQzs7V0FFRztRQUNhLHNCQUFpQixHQUE4QixNQUFNLENBQUM7UUFFdEU7O1dBRUc7UUFDYSxnQkFBVyxHQUF1QixPQUFPLENBQUM7UUFDMUMsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFFbkIsYUFBUSxHQUFHLElBQUksWUFBWSxFQUFlLENBQUM7UUFLNUQseUNBQXlDO1FBQ3pDLGtFQUFrRTtRQUN4RCxpQkFBWSxHQUE0QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2xELGlCQUFZLEdBQWdCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDdEMsaUJBQVksR0FBaUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN2RCxnQkFBVyxHQUFHLEtBQUssQ0FBQztRQUNwQixzQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFrSm5DLDhCQUE4QjtRQUN2QixrQkFBYSxHQUFHLENBQUMsQ0FBb0MsRUFBRSxDQUFvQyxFQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUE5SS9HLElBQUksQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUNuRCxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDdkMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDdkIsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7d0JBQ3pCLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUMzQixDQUFDO2dCQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTSxRQUFRO1FBQ2IsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDdEIsSUFBSSxDQUFDLGtDQUFrQyxFQUFFLENBQUM7WUFDMUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3RCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN0QixDQUFDO0lBQ0gsQ0FBQztJQUVNLFdBQVcsQ0FBQyxPQUFzQjtRQUN2QyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN6QixJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxFQUFFLENBQUM7Z0JBQ2xFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNsQixDQUFDO1FBQ0gsQ0FBQztRQUNELElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzNDLENBQUM7SUFDSCxDQUFDO0lBRU0sWUFBWTtRQUNqQixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7UUFDcEIsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM3QyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlDLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztZQUNqRCxJQUFJLFNBQVMsS0FBSyxVQUFVLEVBQUUsQ0FBQztnQkFDN0IsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Z0JBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMvQixTQUFTLEVBQUUsQ0FBQztnQkFDWixVQUFVLEdBQUcsU0FBUyxDQUFDO1lBQ3pCLENBQUM7aUJBQU0sQ0FBQztnQkFDTixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUMxQyxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUVoRyxDQUFDO0lBRU8sa0NBQWtDO1FBQ3hDLElBQUksSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN4RCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDeEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDdEMsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDO1FBQ0QsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVNLGNBQWM7UUFDbkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDaEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxFQUFFO1lBQ3ZELElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDM0MsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2xDLElBQUksUUFBa0IsQ0FBQztnQkFDdkIsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLEtBQUssRUFBRSxDQUFDO29CQUNoQyxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDekUsQ0FBQztxQkFBTSxDQUFDO29CQUNOLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMzQyxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDbkUsQ0FBQztnQkFDRCxJQUFJLElBQUksRUFBRSxDQUFDO29CQUNULElBQUksUUFBUSxDQUFDO29CQUNiLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxPQUFPLEVBQUUsQ0FBQzt3QkFDakMsUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7b0JBQ2hDLENBQUM7eUJBQU0sQ0FBQzt3QkFDTixRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztvQkFDakMsQ0FBQztvQkFDRCxRQUFRLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRyxHQUFHLENBQUM7Z0JBQ3ZELENBQUM7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7b0JBQ3pCLFFBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ25ELENBQUM7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDM0MsVUFBVSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7b0JBQzNCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7Z0JBQ3JELENBQUM7Z0JBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN4RCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLGVBQWUsQ0FBQyxJQUFjO1FBQ25DLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRU0sUUFBUTtRQUNiLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBQ00scUJBQXFCLENBQUMsR0FBVztRQUN0QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFTSxrQkFBa0IsQ0FBQyxHQUFXO1FBQ25DLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoQyxDQUFDO2FBQU0sQ0FBQztZQUNOLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLENBQUM7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUdNLGlCQUFpQixDQUFDLEdBQVc7UUFDbEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNqRSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDL0IsR0FBRyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7WUFDckIsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEMsQ0FBQzthQUFNLElBQUksR0FBRyxFQUFFLENBQUM7WUFDYixHQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztZQUNwQixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDbEMsQ0FBQzthQUFNLENBQUM7WUFDTix3RUFBd0U7UUFDMUUsQ0FBQztJQUNMLENBQUM7SUFFTSxpQkFBaUI7UUFDdEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVNLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSTtRQUMxQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxpREFBaUQ7SUFDckUsQ0FBQztJQUtPLFdBQVcsQ0FBQyxHQUFXO1FBQzdCLE1BQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQ25GLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDeEMsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVPLGdCQUFnQixDQUFDLFNBQXNDO1FBQzdELE9BQU8sT0FBTyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNoRixDQUFDO0lBRU0sTUFBTSxDQUFDLGFBQWE7UUFDekIsT0FBTyxxQkFBcUIsQ0FBQztJQUMvQixDQUFDO0lBRU0sV0FBVyxDQUFDLEVBQWdCO1FBQ2pDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEtBQUssRUFBRSxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDcEMsQ0FBQztJQUNILENBQUM7K0dBOVBVLHFCQUFxQjttR0FBckIscUJBQXFCLGdwQkM3Q2xDLG1tS0FnRk07OzRGRG5DTyxxQkFBcUI7a0JBTGpDLFNBQVM7K0JBQ0UscUJBQXFCO3NIQVNmLFlBQVk7c0JBQTNCLEtBQUs7Z0JBVVUsY0FBYztzQkFBN0IsS0FBSztnQkFRVyxtQkFBbUI7c0JBQW5DLE1BQU07Z0JBTVMsYUFBYTtzQkFBNUIsS0FBSztnQkFNVSxZQUFZO3NCQUEzQixLQUFLO2dCQU9VLGVBQWU7c0JBQTlCLEtBQUs7Z0JBT1UsWUFBWTtzQkFBM0IsS0FBSztnQkFRVSxzQkFBc0I7c0JBQXJDLEtBQUs7Z0JBS1Usa0JBQWtCO3NCQUFqQyxLQUFLO2dCQUtVLGlCQUFpQjtzQkFBaEMsS0FBSztnQkFLVSxXQUFXO3NCQUExQixLQUFLO2dCQUNVLFlBQVk7c0JBQTNCLEtBQUs7Z0JBRVcsUUFBUTtzQkFBeEIsTUFBTTtnQkFFNkIsTUFBTTtzQkFBekMsU0FBUzt1QkFBQyxhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIExpY2Vuc2VkIHRvIEdpc2HDr2EgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UudHh0IGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gR2lzYcOvYSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEtleVZhbHVlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFBvd2VyQmFyIH0gZnJvbSAnLi4vcG93ZXJiYXJzL21vZGVsL3Bvd2VyYmFyJztcbmltcG9ydCAqIGFzIHRpbnljb2xvciBmcm9tICd0aW55Y29sb3IyJztcbmltcG9ydCB7IEFybGFzQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IuZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0ICogYXMgbWV0cmljVGFibGVKc29uU2NoZW1hIGZyb20gJy4vbWV0cmljcy10YWJsZS5zY2hlbWEuanNvbic7XG5pbXBvcnQgeyBGaWx0ZXJPcGVyYXRvciB9IGZyb20gJy4uLy4uL3Rvb2xzL21vZGVscy90ZXJtLWZpbHRlcnMnO1xuaW1wb3J0IHsgTWV0cmljc1RhYmxlLCBNZXRyaWNzVGFibGVIZWFkZXIsIE1ldHJpY3NUYWJsZVJvdyB9IGZyb20gJy4vbW9kZWwvbWV0cmljcy10YWJsZSc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYXJsYXMtbWV0cmljcy10YWJsZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9tZXRyaWNzLXRhYmxlLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbWV0cmljcy10YWJsZS5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE1ldHJpY3NUYWJsZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgLyoqXG4gICAqIEBJbnB1dCA6IEFuZ3VsYXJcbiAgICogQGRlc2NyaXB0aW9uIERhdGEgdG8gYnVpbGQgdGhlIHRhYmxlLlxuICAgKi9cbiAgQElucHV0KCkgcHVibGljIG1ldHJpY3NUYWJsZTogTWV0cmljc1RhYmxlO1xuXG4gIC8qKlxuICAgICAqIEBJbnB1dCA6IEFuZ3VsYXJcbiAgICAgKiBAZGVzY3JpcHRpb24gT3B0aW9ucyBhYm91dCBob3cgdG8gYXBwbHkgZmlsdGVycyBvbiBtZXRyaWNzIHRhYmxlXG4gICAgICogLSB2YWx1ZSA6IFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqICAgICAgICAgICBpZiAnRXEnLCB0aGUgc2VsZWN0ZWQgbGluZSBpcyBpbmNsdWRlZCBpbiB0aGUgQVJMQVMgZmlsdGVyLlxuICAgICAqICAgICAgICAgICBpZiAnTmVxJywgdGhlIHNlbGVjdGVkIGxpbmUgaXMgZXhjbHVkZWQgaW4gdGhlIEFSTEFTIGZpbHRlci5cbiAgICAgKiAtIGRpc3BsYXk6IFdoZXRoZXIgdG8gZGlzcGxheSBhIHN3aXRjaGVyIGJldHdlZW4gJ0VxJyBhbmQgJ05lcScgb3Iga2VlcCB0aGUgZGVmYXVsdCBvcGVyYXRvciBhbGwgdGhlIHRpbWVcbiAgICAgKi9cbiAgQElucHV0KCkgcHVibGljIGZpbHRlck9wZXJhdG9yOiBGaWx0ZXJPcGVyYXRvciA9IHtcbiAgICB2YWx1ZTogJ0VxJyxcbiAgICBkaXNwbGF5OiB0cnVlXG4gIH07XG4gIC8qKlxuICAgKiBAT3V0cHV0IDogQW5ndWxhclxuICAgKiBAZGVzY3JpcHRpb24gRW1pdHMgdGhlIGZpbHRlciBvcGVyYXRvclxuICAgKi9cbiAgQE91dHB1dCgpIHB1YmxpYyBmaWx0ZXJPcGVyYXRvckV2ZW50OiBFdmVudEVtaXR0ZXI8J05lcScgfCAnRXEnPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogQElucHV0IDogQW5ndWxhclxuICAgKiBAZGVzY3JpcHRpb24gc2VsZWN0ZWQgdGVybXMgbGlzdC5cbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBzZWxlY3RlZFRlcm1zOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQElucHV0IDogQW5ndWxhclxuICAgKiBAZGVzY3JpcHRpb24gTGlzdCBvZiBba2V5LCBjb2xvcl0gY291cGxlcyB0aGF0IGFzc29jaWF0ZXMgYSBoZXggY29sb3IgdG8gZWFjaCBrZXlcbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBrZXlzVG9Db2xvcnM6IEFycmF5PFtzdHJpbmcsIHN0cmluZ10+O1xuXG5cbiAgLyoqXG4gICAqIEBJbnB1dCA6IEFuZ3VsYXJcbiAgICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdG8gYWxsb3cgY29sb3JpemluZyB0aGUgYmFyIGFjY29yZGluZyB0byBpdHMgdGVybSBvciBub3QgdXNpbmcga2V5c1RvQ29sb3JzXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgdXNlQ29sb3JTZXJ2aWNlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBJbnB1dCA6IEFuZ3VsYXJcbiAgICogQGRlc2NyaXB0aW9uIENob29zZSBob3cgdG8gYXBwbHkgY29sb3JzIHRvIHRoZSB0YWJsZS4gQnkgY29sdW1uIDogYWxsIHRoZSBiYXJzIGluIHNhbWUgY29sdW1uIHdpbGwgaGF2ZSB0aGUgc2FtZSBjb2xvci5cbiAgICogQnkgcm93IDogYWxsIHRoZSBiYXJzIGluIHRoZSBzYW1lIHJvdywgd2lsbCBoYXZlIHRoZSBzYW1lIGNvbG9yLlxuICAgKi9cbiAgQElucHV0KCkgcHVibGljIGFwcGx5Q29sb3JUbzogJ2NvbHVtbicgfCAncm93JyA9ICdjb2x1bW4nO1xuXG4gIC8qKlxuICAgKiBASW5wdXQgOiBBbmd1bGFyXG4gICAqIEBkZXNjcmlwdGlvbiBLbm93aW5nIHRoYXQgc2F0dXJhdGlvbiBzY2FsZSBpcyBbMCwgMV0sIGBjb2xvcnNTYXR1cmF0aW9uV2VpZ2h0YCBpcyBhXG4gICAqIGZhY3RvciAoYmV0d2VlbiAwIGFuZCAxKSB0aGF0IHRpZ2h0ZW5zIHRoaXMgc2NhbGUgdG8gWygxLWNvbG9yc1NhdHVyYXRpb25XZWlnaHQpLCAxXS5cbiAgICogVGhlcmVmb3JlIHNhdHVyYXRpb24gb2YgZ2VuZXJhdGVkIGNvbG9ycyB3aWxsIGJlIHdpdGhpbiB0aGlzIHRpZ2h0ZW5lZCBzY2FsZS5cbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBjb2xvcnNTYXR1cmF0aW9uV2VpZ2h0O1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQWxsb3cgdG8gc2VsZWN0IGEgcm93IGJ5IGEgY2hlY2tib3hcbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBzZWxlY3RXaXRoQ2hlY2tib3ggPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQWxsb3cgdG8gc2VsZWN0IGRpc3BsYXkgbW9kZSBmb3IgaGVhZGVycy5cbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXJEaXNwbGF5TW9kZTogJ2NoaXAnIHwgJ3RpdGxlJyB8ICdmdWxsJyA9ICdjaGlwJztcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIE5vcm1hbGlzZSBiYXJzIHByb2dyZXNzaW9uIGJhc2VkIG9uIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGVhY2ggY29sdW1uIE9SIG9mIHRoZSB3aG9sZSB0YWJsZVxuICAgKi9cbiAgQElucHV0KCkgcHVibGljIG5vcm1hbGlzZUJ5OiAnY29sdW1uJyB8ICd0YWJsZScgPSAndGFibGUnO1xuICBASW5wdXQoKSBwdWJsaWMgc2hvd1Jvd0ZpZWxkID0gdHJ1ZTtcblxuICBAT3V0cHV0KCkgcHVibGljIG9uU2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcjxTZXQ8c3RyaW5nPj4oKTtcblxuICBAVmlld0NoaWxkKCd0YWJsZUhlYWRlcicpIHByb3RlY3RlZCBoZWFkZXI6IEVsZW1lbnRSZWY7XG5cblxuICAvLyBrZWVwIGl0IHRpbWUgY29tcGxleGl0eSBvKDEpIHdpdGggZ2V0LlxuICAvKiogTWFwIG9mIDx0ZXJtLWxpc3Qub2YucG93ZXJiYXJzLmNvcnJlc3BvbmRpbmcudG8udGhpcy50ZXJtLj4gKi9cbiAgcHJvdGVjdGVkIHBvd2VyQmFyc01hcDogTWFwPHN0cmluZywgUG93ZXJCYXJbXT4gPSBuZXcgTWFwKCk7XG4gIHByb3RlY3RlZCBzZWxlY3RlZEtleXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBwcm90ZWN0ZWQgc2VsZWN0ZWRSb3dzOiBNYXA8c3RyaW5nLCBNZXRyaWNzVGFibGVSb3c+ID0gbmV3IE1hcCgpO1xuICBwcm90ZWN0ZWQgcGVuZGluZ01vZGUgPSBmYWxzZTtcbiAgcHJvdGVjdGVkIHRpdGxlQXJlRGlmZmVyZW50ID0gdHJ1ZTtcbiAgcHJvdGVjdGVkIHVuaXF1ZVRpdGxlczogTWV0cmljc1RhYmxlSGVhZGVyW107XG5cblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb2xvclNlcnZpY2U6IEFybGFzQ29sb3JTZXJ2aWNlLCBwcml2YXRlIHJlYWRvbmx5IGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICB0aGlzLmNvbG9yU2VydmljZS5jaGFuZ2VrZXlzVG9Db2xvcnMkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnBvd2VyQmFyc01hcC5mb3JFYWNoKHBvd2VyYmFyc1JvdyA9PiB7XG4gICAgICAgIHBvd2VyYmFyc1Jvdy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnVzZUNvbG9yU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVDb2xvcihwLnRlcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tZXRyaWNzVGFibGUpIHtcbiAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRUZXJtV2l0aERlZmF1bHRWYWx1ZSgpO1xuICAgICAgdGhpcy5idWlsZFBvd2VyQmFycygpO1xuICAgICAgdGhpcy5idWlsZEhlYWRlcnMoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLm1ldHJpY3NUYWJsZSkge1xuICAgICAgaWYgKHRoaXMubWV0cmljc1RhYmxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5tZXRyaWNzVGFibGUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5uZ09uSW5pdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hhbmdlcy5zZWxlY3RlZFRlcm1zKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih0aGlzLnNlbGVjdGVkVGVybXMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBidWlsZEhlYWRlcnMoKSB7XG4gICAgdGhpcy51bmlxdWVUaXRsZXMgPSBbXTtcbiAgICBsZXQgcHJldmlvdXNJZCA9ICcnO1xuICAgIGxldCBuZXh0SW5kZXggPSAwO1xuICAgIHRoaXMubWV0cmljc1RhYmxlLmhlYWRlci5mb3JFYWNoKChoZWFkZXIsIGkpID0+IHtcbiAgICAgIGhlYWRlci5jb2xvciA9IHRoaXMuZGVmaW5lQ29sb3IoaGVhZGVyLnRpdGxlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJZCA9IGhlYWRlci50aXRsZSArIGhlYWRlci5yb3dmaWVsZDtcbiAgICAgIGlmIChjdXJyZW50SWQgIT09IHByZXZpb3VzSWQpIHtcbiAgICAgICAgaGVhZGVyLnNwYW4gPSAxO1xuICAgICAgICB0aGlzLnVuaXF1ZVRpdGxlcy5wdXNoKGhlYWRlcik7XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICBwcmV2aW91c0lkID0gY3VycmVudElkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmlxdWVUaXRsZXNbbmV4dEluZGV4IC0gMV0uc3BhbisrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudGl0bGVBcmVEaWZmZXJlbnQgPSB0aGlzLnVuaXF1ZVRpdGxlcy5sZW5ndGggPT09IHRoaXMubWV0cmljc1RhYmxlPy5kYXRhWzBdPy5kYXRhLmxlbmd0aDtcblxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVTZWxlY3RlZFRlcm1XaXRoRGVmYXVsdFZhbHVlKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkVGVybXMgJiYgdGhpcy5zZWxlY3RlZFRlcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRUZXJtcy5mb3JFYWNoKHNlbGVjdGVkVGVybSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzLmFkZChzZWxlY3RlZFRlcm0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlUGVuZGluZ01vZGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBidWlsZFBvd2VyQmFycygpIHtcbiAgICB0aGlzLnBvd2VyQmFyc01hcC5jbGVhcigpO1xuICAgIHRoaXMuY2xlYXJBbGwoKTtcbiAgICB0aGlzLm1ldHJpY3NUYWJsZS5kYXRhPy5mb3JFYWNoKChtZXJ0aWNzUm93LCByb3dJbmRleCkgPT4ge1xuICAgICAgdGhpcy5wb3dlckJhcnNNYXAuc2V0KG1lcnRpY3NSb3cudGVybSwgW10pO1xuICAgICAgbWVydGljc1Jvdy5kYXRhLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgbGV0IHBvd2VyQmFyOiBQb3dlckJhcjtcbiAgICAgICAgaWYgKHRoaXMuYXBwbHlDb2xvclRvID09PSAncm93Jykge1xuICAgICAgICAgIHBvd2VyQmFyID0gbmV3IFBvd2VyQmFyKG1lcnRpY3NSb3cudGVybSwgbWVydGljc1Jvdy50ZXJtLCBpdGVtPy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaGVhZGVyID0gdGhpcy5tZXRyaWNzVGFibGUuaGVhZGVyW2ldO1xuICAgICAgICAgIHBvd2VyQmFyID0gbmV3IFBvd2VyQmFyKGhlYWRlci50aXRsZSwgaGVhZGVyLnRpdGxlLCBpdGVtPy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICBsZXQgbWF4VmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMubm9ybWFsaXNlQnkgPT09ICd0YWJsZScpIHtcbiAgICAgICAgICAgIG1heFZhbHVlID0gaXRlbS5tYXhUYWJsZVZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IGl0ZW0ubWF4Q29sdW1uVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvd2VyQmFyLnByb2dyZXNzaW9uID0gKGl0ZW0udmFsdWUgLyBtYXhWYWx1ZSkgKiAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlQ29sb3JTZXJ2aWNlKSB7XG4gICAgICAgICAgcG93ZXJCYXIuY29sb3IgPSB0aGlzLmRlZmluZUNvbG9yKHBvd2VyQmFyLnRlcm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkS2V5cy5oYXMobWVydGljc1Jvdy50ZXJtKSkge1xuICAgICAgICAgIG1lcnRpY3NSb3cuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dzLnNldChtZXJ0aWNzUm93LnRlcm0sIG1lcnRpY3NSb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG93ZXJCYXJzTWFwLmdldChtZXJ0aWNzUm93LnRlcm0pLnB1c2gocG93ZXJCYXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlU2VsZWN0aW9uKGtleXM6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5zZWxlY3RlZEtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIHRoaXMuY2xlYXJBbGwoKTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHRoaXMudXBkYXRlU2VsZWN0ZWRSb3coa2V5KSk7XG4gICAgdGhpcy50b2dnbGVQZW5kaW5nTW9kZSgpO1xuICB9XG5cbiAgcHVibGljIGNsZWFyQWxsKCkge1xuICAgIHRoaXMubWV0cmljc1RhYmxlPy5kYXRhPy5mb3JFYWNoKHJvdyA9PiByb3cuc2VsZWN0ZWQgPSBmYWxzZSk7XG4gICAgdGhpcy5zZWxlY3RlZFJvd3MuY2xlYXIoKTtcbiAgfVxuICBwdWJsaWMgYWRkVGVybVRvU2VsZWN0ZWRMaXN0KGtleTogc3RyaW5nKSB7XG4gICAgdGhpcy51cGRhdGVTZWxlY3RlZFJvdyhrZXkpO1xuICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRUZXJtKGtleSk7XG4gICAgdGhpcy50b2dnbGVQZW5kaW5nTW9kZSgpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVNlbGVjdGVkVGVybShrZXk6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5zZWxlY3RlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzLmFkZChrZXkpO1xuICAgIH1cbiAgICB0aGlzLm9uU2VsZWN0LmVtaXQodGhpcy5zZWxlY3RlZEtleXMpO1xuICB9XG5cblxuICBwdWJsaWMgdXBkYXRlU2VsZWN0ZWRSb3coa2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLm1ldHJpY3NUYWJsZS5kYXRhLmZpbmQocm93ID0+IHJvdy50ZXJtID09PSBrZXkpO1xuICAgIGlmICh0aGlzLnNlbGVjdGVkUm93cy5oYXMoa2V5KSkge1xuICAgICAgcm93LnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbGVjdGVkUm93cy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKHJvdykge1xuICAgICAgICByb3cuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkUm93cy5zZXQoa2V5LCByb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqIElmIHdlIHNlbGVjdCBhIHJvdyB0aGF0IGRvZXMgbm90IGV4aXN0cywgaXQgbWVhbnMgd2UgZGF0YSBpcyBub3QgICovXG4gICAgICB9XG4gIH1cblxuICBwdWJsaWMgdG9nZ2xlUGVuZGluZ01vZGUoKSB7XG4gICAgdGhpcy5wZW5kaW5nTW9kZSA9IHRoaXMuc2VsZWN0ZWRLZXlzLnNpemUgIT09IDA7XG4gIH1cblxuICBwdWJsaWMgdHJhY2tCeUZuKGluZGV4LCBpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udGVybTsgLy8gVXNlIHRoZSAnaWQnIHByb3BlcnR5IGFzIHRoZSB1bmlxdWUgaWRlbnRpZmllclxuICB9XG5cbiAgLy8gcHJlc2VydmUgb3JkZXIgb2YgaW5zZXJ0aW9uXG4gIHB1YmxpYyBvcmlnaW5hbE9yZGVyID0gKGE6IEtleVZhbHVlPHN0cmluZywgTWV0cmljc1RhYmxlUm93PiwgYjogS2V5VmFsdWU8c3RyaW5nLCBNZXRyaWNzVGFibGVSb3c+KTogbnVtYmVyID0+IDA7XG5cbiAgcHJpdmF0ZSBkZWZpbmVDb2xvcihrZXk6IHN0cmluZykge1xuICAgIGNvbnN0IHJnYmFDb2xvciA9IHRpbnljb2xvci5kZWZhdWx0KHRoaXMuY29sb3JTZXJ2aWNlLmdldENvbG9yKGtleSwgdGhpcy5rZXlzVG9Db2xvcnMsXG4gICAgICB0aGlzLmNvbG9yc1NhdHVyYXRpb25XZWlnaHQpKS50b1JnYigpO1xuICAgIHJldHVybiB0aGlzLmdldFBvd2VyYmFyQ29sb3IocmdiYUNvbG9yKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UG93ZXJiYXJDb2xvcihyZ2JhQ29sb3I6IHRpbnljb2xvci5Db2xvckZvcm1hdHMuUkdCQSk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdyZ2JhKCcgKyBbcmdiYUNvbG9yLnIsIHJnYmFDb2xvci5nLCByZ2JhQ29sb3IuYiwgMC43XS5qb2luKCcsJykgKyAnKSc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldEpzb25TY2hlbWEoKTogT2JqZWN0IHtcbiAgICByZXR1cm4gbWV0cmljVGFibGVKc29uU2NoZW1hO1xuICB9XG5cbiAgcHVibGljIHNldE9wZXJhdG9yKG9wOiAnRXEnIHwgJ05lcScpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5maWx0ZXJPcGVyYXRvci52YWx1ZSAhPT0gb3ApIHtcbiAgICAgIHRoaXMuZmlsdGVyT3BlcmF0b3IudmFsdWUgPSBvcDtcbiAgICAgIHRoaXMuZmlsdGVyT3BlcmF0b3JFdmVudC5uZXh0KG9wKTtcbiAgICB9XG4gIH1cbn1cbiIsIjxkaXYgY2xhc3M9XCJ0b29sc1wiPlxuICA8ZGl2ICpuZ0lmPVwiZmlsdGVyT3BlcmF0b3IgJiYgZmlsdGVyT3BlcmF0b3I/LmRpc3BsYXlcIiBjbGFzcz1cImluY2x1ZGVfZXhjbHVkZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJvcGVyYXRpb25cIiBbY2xhc3Muc2VsZWN0ZWRfb3BlcmF0aW9uXT1cImZpbHRlck9wZXJhdG9yPy52YWx1ZSA9PT0gJ0VxJ1wiIChjbGljayk9XCJzZXRPcGVyYXRvcignRXEnKVwiPlxuICAgICAge3snaW5jbHVkZScgfCB0cmFuc2xhdGV9fTwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJvcGVyYXRpb25cIiBbY2xhc3Muc2VsZWN0ZWRfb3BlcmF0aW9uXT1cImZpbHRlck9wZXJhdG9yPy52YWx1ZSA9PT0gJ05lcSdcIiAoY2xpY2spPVwic2V0T3BlcmF0b3IoJ05lcScpXCI+XG4gICAgICB7eydleGNsdWRlJyB8IHRyYW5zbGF0ZX19PC9kaXY+XG4gIDwvZGl2PlxuICA8ZGl2ICpuZ0lmPVwiZmlsdGVyT3BlcmF0b3IgJiYgIWZpbHRlck9wZXJhdG9yPy5kaXNwbGF5ICYmIGZpbHRlck9wZXJhdG9yPy52YWx1ZSA9PT0gJ05lcSdcIiBjbGFzcz1cImluY2x1ZGVfZXhjbHVkZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJvcGVyYXRpb25cIiBbY2xhc3MuZXhjbHVkZV09XCJmaWx0ZXJPcGVyYXRvcj8udmFsdWUgPT09ICdOZXEnXCI+e3snZXhjbHVkZScgfCB0cmFuc2xhdGV9fTwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cInRhYmxlLW92ZXJmbG93LXdyYXBwZXJcIj5cbiAgPHRhYmxlIGNsYXNzPVwibXVsdGktYmFyXCI+XG4gICAgPHRoZWFkICN0YWJsZUhlYWRlcj5cbiAgICAgIDwhLS0gVGl0bGUgYXJlYSAtLT5cbiAgICAgIDx0cj5cbiAgICAgICAgPHRoIGNsYXNzPVwidGVybXMtaGVhZFwiPjwvdGg+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJ0aXRsZUFyZURpZmZlcmVudDsgZWxzZSBkaXNwbGF5T25lVGl0bGVcIj5cbiAgICAgICAgICA8dGggY2xhc3M9XCJtdWx0aS1iYXJfX2hlYWRlci1pbmRpY2F0b3JcIiAqbmdGb3I9XCJsZXQgaGVhZGVyIG9mIG1ldHJpY3NUYWJsZT8uaGVhZGVyOyBsZXQgaSA9IGluZGV4XCI+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhlYWRlckRpc3BsYXlNb2RlID09PSAnY2hpcCcgfHwgaGVhZGVyRGlzcGxheU1vZGUgPT09ICdmdWxsJ1wiIGNsYXNzPVwiaGVhZGVyLWluZGljYXRvclwiXG4gICAgICAgICAgICAgICAgICBbc3R5bGVdPVwieydiYWNrZ3JvdW5kJzogaGVhZGVyLmNvbG9yfVwiIFttYXRUb29sdGlwXT1cImhlYWRlci50aXRsZSB8IGdldENvbGxlY3Rpb25EaXNwbGF5TmFtZSB8ICB0cmFuc2xhdGVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VwYXJhdG9yXCIgKm5nSWY9XCJoZWFkZXJEaXNwbGF5TW9kZSA9PT0gJ2Z1bGwnXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm11bHRpLWJhcl9faGVhZGVyLXRpdGxlLXdpdGgtaW5kaWNhdG9yXCIgW21hdFRvb2x0aXBdPVwiaGVhZGVyLnRpdGxlIHwgZ2V0Q29sbGVjdGlvbkRpc3BsYXlOYW1lIHwgIHRyYW5zbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAqbmdJZj1cImhlYWRlckRpc3BsYXlNb2RlID09PSAndGl0bGUnIHx8IGhlYWRlckRpc3BsYXlNb2RlID09PSAnZnVsbCdcIj57eyBoZWFkZXIudGl0bGUgfCBnZXRDb2xsZWN0aW9uRGlzcGxheU5hbWUgfCB0cmFuc2xhdGUgfX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtdWx0aS1iYXJfX2hlYWRlci1yb3dmaWVsZFwiIFttYXRUb29sdGlwXT1cImhlYWRlci5yb3dmaWVsZCB8IHRyYW5zbGF0ZVwiICpuZ0lmPVwic2hvd1Jvd0ZpZWxkXCI+e3tcbiAgICAgICAgICAgICAgICBoZWFkZXIucm93ZmllbGQgfCBnZXRGaWVsZERpc3BsYXlOYW1lIHwgdHJhbnNsYXRlIH19PC9kaXY+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvdGg+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctdGVtcGxhdGUgI2Rpc3BsYXlPbmVUaXRsZT5cbiAgICAgICAgICA8dGggKm5nRm9yPVwibGV0IGhlYWRlciBvZiB1bmlxdWVUaXRsZXNcIiBjbGFzcz1cIm11bHRpLWJhcl9faGVhZGVyLWluZGljYXRvclwiXG4gICAgICAgICAgICBbc3R5bGUud2lkdGgucHhdPVwiaGVhZGVyLnNwYW4gKiA3MFwiIFthdHRyLmNvbHNwYW5dPVwiaGVhZGVyLnNwYW5cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhlYWRlckRpc3BsYXlNb2RlID09PSAnY2hpcCcgfHwgaGVhZGVyRGlzcGxheU1vZGUgPT09ICdmdWxsJ1wiIGNsYXNzPVwiaGVhZGVyLWluZGljYXRvclwiXG4gICAgICAgICAgICAgICAgW3N0eWxlXT1cInsnYmFja2dyb3VuZCc6IGhlYWRlci5jb2xvcn1cIiBbbWF0VG9vbHRpcF09XCJoZWFkZXIudGl0bGUgfCBnZXRDb2xsZWN0aW9uRGlzcGxheU5hbWUgfCB0cmFuc2xhdGVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlcGFyYXRvclwiICpuZ0lmPVwiaGVhZGVyRGlzcGxheU1vZGUgPT09ICdmdWxsJ1wiPjwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXVsdGktYmFyX19oZWFkZXItdGl0bGUtd2l0aC1pbmRpY2F0b3JcIiBbbWF0VG9vbHRpcF09XCJoZWFkZXIudGl0bGUgfCBnZXRDb2xsZWN0aW9uRGlzcGxheU5hbWUgfCB0cmFuc2xhdGVcIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwiaGVhZGVyRGlzcGxheU1vZGUgPT09ICd0aXRsZScgfHwgaGVhZGVyRGlzcGxheU1vZGUgPT09ICdmdWxsJ1wiPnt7IGhlYWRlci50aXRsZSB8IGdldENvbGxlY3Rpb25EaXNwbGF5TmFtZSB8IHRyYW5zbGF0ZSB9fVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm11bHRpLWJhcl9faGVhZGVyLXJvd2ZpZWxkXCIgW21hdFRvb2x0aXBdPVwiaGVhZGVyLnJvd2ZpZWxkIHwgdHJhbnNsYXRlXCIgKm5nSWY9XCJzaG93Um93RmllbGRcIj5cbiAgICAgICAgICAgICAge3toZWFkZXIucm93ZmllbGQgfCBnZXRGaWVsZERpc3BsYXlOYW1lIHwgdHJhbnNsYXRlfX08L2Rpdj5cbiAgICAgICAgICA8L3RoPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgPC90cj5cbiAgICAgIDwhLS0gU3ViIFRpdGxlIGFyZWEgLS0+XG4gICAgICA8dHI+XG4gICAgICAgIDx0aCBjbGFzcz1cInRlcm1zLWhlYWRcIj48L3RoPlxuICAgICAgICA8dGggY2xhc3M9XCJjb2x1bW4taGVhZCBtdWx0aS1iYXJfX2hlYWRlclwiICpuZ0Zvcj1cImxldCBoZWFkZXIgb2YgbWV0cmljc1RhYmxlPy5oZWFkZXI7IGxldCBpID0gaW5kZXhcIj5cbiAgICAgICAgICA8ZGl2ICpuZ0lmPVwiaGVhZGVyLm1ldHJpYyAhPT0gJ2NvdW50J1wiXG4gICAgICAgICAgICBbbWF0VG9vbHRpcF09XCInTUVUUklDX0NPTFVNTl9USVRMRScgfCB0cmFuc2xhdGU6ICB7IG1ldHJpYzogJ01FVFJJQ19DT0xVTU5fJyArIGhlYWRlci5tZXRyaWMgfCB0cmFuc2xhdGUsIGZpZWxkIDogaGVhZGVyLnN1YlRpdGxlIHwgZ2V0RmllbGREaXNwbGF5TmFtZSB8IHRyYW5zbGF0ZSB9XCJcbiAgICAgICAgICAgIGNsYXNzPVwibXVsdGktYmFyX19oZWFkZXItaXRlbSBtdWx0aS1iYXJfX2hlYWRlci1pdGVtLXRpdGxlXCI+XG4gICAgICAgICAgICB7eydNRVRSSUNfQ09MVU1OX1RJVExFJyB8IHRyYW5zbGF0ZTogeyBtZXRyaWM6ICdNRVRSSUNfQ09MVU1OXycgKyBoZWFkZXIubWV0cmljIHwgdHJhbnNsYXRlLCBmaWVsZCA6XG4gICAgICAgICAgICBoZWFkZXIuc3ViVGl0bGUgfCBnZXRGaWVsZERpc3BsYXlOYW1lIHxcbiAgICAgICAgICAgIHRyYW5zbGF0ZSB9IH19XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiAqbmdJZj1cImhlYWRlci5tZXRyaWMgPT09ICdjb3VudCdcIiBbbWF0VG9vbHRpcF09XCInQ09VTlRfQ09MVU1OX1RJVExFJyB8IHRyYW5zbGF0ZVwiXG4gICAgICAgICAgICBjbGFzcz1cIm11bHRpLWJhcl9faGVhZGVyLWl0ZW0gbXVsdGktYmFyX19oZWFkZXItaXRlbS10aXRsZVwiPlxuICAgICAgICAgICAge3snQ09VTlRfQ09MVU1OX1RJVExFJyB8IHRyYW5zbGF0ZSB9fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3RoPlxuICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgbWV0cmljc1RhYmxlPy5kYXRhOyBsZXQgaW5kZXggPSBpbmRleDt0cmFja0J5OiB0cmFja0J5Rm5cIj5cbiAgICAgIDxhcmxhcy1tdWx0aS1iYXJzLXJvdyAqbmdJZj1cIml0ZW0/LnNlbGVjdGVkXCIgW21ldHJpY3NUYWJsZVJvd109XCJpdGVtXCIgW3VzZUNvbG9yRnJvbURhdGFdPVwiZmFsc2VcIlxuICAgICAgICBbaGlkZVNlbGVjdGlvbl09XCJmYWxzZVwiIFt1c2VDb2xvclNlcnZpY2VdPVwidXNlQ29sb3JTZXJ2aWNlXCIgW3Bvd2VyQmFyc109XCJwb3dlckJhcnNNYXAuZ2V0KGl0ZW0udGVybSlcIlxuICAgICAgICBbZGlzcGxheUNoZWNrQm94XT1cInNlbGVjdFdpdGhDaGVja2JveFwiIChyb3dTZWxlY3RlZCk9XCJhZGRUZXJtVG9TZWxlY3RlZExpc3QoJGV2ZW50KVwiPlxuICAgICAgPC9hcmxhcy1tdWx0aS1iYXJzLXJvdz5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8YXJsYXMtbXVsdGktYmFycy1yb3cgKm5nRm9yPVwibGV0IHJvdyBvZiBtZXRyaWNzVGFibGU/LmRhdGE7IGxldCBpbmRleCA9IGluZGV4O3RyYWNrQnk6IHRyYWNrQnlGblwiXG4gICAgICBbbWV0cmljc1RhYmxlUm93XT1cInJvd1wiIFtzZWxlY3RlZF09XCJyb3cuc2VsZWN0ZWRcIiBbaGlkZVNlbGVjdGlvbl09XCJ0cnVlXCIgW3VzZUNvbG9yRnJvbURhdGFdPVwiZmFsc2VcIlxuICAgICAgW3VzZUNvbG9yU2VydmljZV09XCJ1c2VDb2xvclNlcnZpY2VcIiBbcG93ZXJCYXJzXT1cInBvd2VyQmFyc01hcC5nZXQocm93LnRlcm0pXCJcbiAgICAgIFtkaXNwbGF5Q2hlY2tCb3hdPVwic2VsZWN0V2l0aENoZWNrYm94XCIgW3BlbmRpbmdNb2RlXT1cInBlbmRpbmdNb2RlXCIgKHJvd1NlbGVjdGVkKT1cImFkZFRlcm1Ub1NlbGVjdGVkTGlzdCgkZXZlbnQpXCI+XG4gICAgPC9hcmxhcy1tdWx0aS1iYXJzLXJvdz5cbiAgPC90YWJsZT5cbjwvZGl2PiJdfQ==