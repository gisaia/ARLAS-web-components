import { Observable, Subscription } from 'rxjs';
import { ControlPosition, ControlsOption, DrawControlsOption } from './model/controls';
import { MapExtent } from './model/extent';
import { ArlasLngLat, ArlasLngLatBounds, OnMoveResult } from './model/map';
/** Conf */
export interface MapConfig<T> {
    displayCurrentCoordinates: boolean;
    fitBoundsPadding: number;
    margePanForLoad: number;
    margePanForTest: number;
    wrapLatLng: boolean;
    offset: ArlasMapOffset;
    mapProviderOptions?: T;
    maxWidthScale?: number;
    unitScale?: string;
    controls?: ControlsOption;
}
export interface ArlasMapOffset {
    north: number;
    east: number;
    south: number;
    west: number;
}
export declare const GEOJSON_SOURCE_TYPE = "geojson";
export declare const CROSS_LAYER_PREFIX = "arlas_cross";
export declare const ZOOM_IN: "Zoom in";
export declare const ZOOM_OUT: "Zoom out";
export declare const RESET_BEARING: "Reset bearing to north";
export declare const LAYER_SWITCHER_TOOLTIP: "Manage layers";
/**
 * The aim of this class is to handle all core interaction we have
 * with a map provider.
 * The aim is also to separate the Arlas map from the Angular framework.
 * It will be instantiated in the map.component and will be responsible for initializing the map and all map behavior.
 */
export declare abstract class AbstractArlasMapGL {
    protected config: MapConfig<any>;
    /**
     *  props and methods with unknown type will be specific to the map provider
     *  we use.
     *  ex: endLngLat will have a type Maplibre.Pointlike/ Mapbox.Point
     */
    abstract startLngLat: ArlasLngLat;
    abstract endLngLat: ArlasLngLat;
    abstract moveLngLat: ArlasLngLat;
    protected _offset: ArlasMapOffset;
    protected _margePanForLoad: number;
    protected _margePanForTest: number;
    protected _fitBoundsPadding: number;
    protected _displayCurrentCoordinates: boolean;
    protected _wrapLatLng: boolean;
    protected _controls: ControlsOption;
    protected _maxWidthScale?: number;
    protected _unitScale?: string;
    currentLat: string;
    currentLng: string;
    readonly POLYGON_LABEL_SOURCE = "polygon_label";
    protected _north: number;
    protected _east: number;
    protected _west: number;
    protected _south: number;
    zoom: number;
    protected _zoomStart: number;
    protected _dragStartX: number;
    protected _dragStartY: number;
    protected _dragEndX: number;
    protected _dragEndY: number;
    protected _xMoveRatio: number;
    protected _yMoveRatio: number;
    protected _moveEnd$: Observable<any>;
    protected _zoomStart$: Observable<any>;
    protected _dragStart$: Observable<any>;
    protected _dragEnd$: Observable<any>;
    protected _eventSubscription: Subscription[];
    protected evented: EventTarget;
    protected constructor(config: MapConfig<any>);
    protected init(config: MapConfig<any>): void;
    protected _initOnLoad(): void;
    onCustomEvent(event: string, loadFn: () => void): void;
    protected _initMapMoveEvents(): void;
    protected _updateBounds(): void;
    protected _updateZoom(e?: any): void;
    protected _updateCurrentLngLat(e: any): void;
    protected _updateDragEnd(e: any): void;
    protected _updateDragStart(e: any): void;
    protected _updateEndLngLat(e: any): void;
    protected _updateMoveRatio(e: any): void;
    protected _updateStartLngLat(e: any): void;
    protected _updateZoomStart(): void;
    protected _updateOnZoomStart(): void;
    protected _updateOnDragStart(): void;
    protected _updateOnDragEnd(): void;
    protected _updateOnMoveEnd(): void;
    onMoveEnd(visualisationsSets: {
        visualisations: Map<string, Set<string>>;
        status: Map<string, boolean>;
    }, cb?: () => void): Observable<OnMoveResult>;
    setLayoutProperty(layer: string, name: string, value: any, options?: any): this;
    unsubscribeEvents(): void;
    getMaxZoom(): number;
    getMinZoom(): number;
    getPitch(): number;
    protected abstract _initMapProvider(BaseMapGlConfig: any): void;
    protected abstract _initControls(): void;
    protected abstract _getMoveEnd(visualisationsSets: {
        visualisations: Map<string, Set<string>>;
        status: Map<string, boolean>;
    }): OnMoveResult;
    abstract addControl(control: any, position?: ControlPosition, eventOverride?: {
        event: string;
        fn: (e?: any) => void;
    }): any;
    abstract calcOffsetPoint(): any;
    abstract disableDragPan(): void;
    abstract enableDragPan(): void;
    abstract fitBounds(bounds: ArlasLngLatBounds | number[], options?: unknown, unknown?: unknown): this;
    abstract fitToPaddedBounds(bounds: ArlasLngLatBounds | number[]): any;
    abstract getBounds(): unknown;
    abstract getCanvasContainer(): HTMLElement;
    abstract getEastBounds(): number;
    abstract getMapExtend(): MapExtent;
    abstract getMapProvider(): any;
    abstract getMaxBounds(): unknown;
    abstract getNorthBounds(): number;
    abstract getNorthEastBounds(): ArlasLngLat;
    abstract getSouthBounds(): number;
    abstract getSouthWestBounds(): ArlasLngLat;
    abstract getWestBounds(): number;
    abstract getZoom(): number;
    abstract initDrawControls(config: DrawControlsOption): void;
    abstract on(type: string, listener: (ev: any) => void): this;
    abstract onLoad(fn: () => void): void;
    abstract queryRenderedFeatures(pointOrBox?: unknown, options?: {
        layers?: string[];
        filter?: any[];
    }): any[];
    abstract resize(eventData?: unknown): this;
    abstract setCenter(center: unknown, unknown?: unknown): this;
    abstract setMaxBounds(unknown?: unknown): this;
    abstract setFilter(layer: string, filter?: boolean | any[], options?: unknown): this;
    abstract paddedBounds(npad: number, spad: number, epad: number, wpad: number, map: any, SW: ArlasLngLat, NE: ArlasLngLat): ArlasLngLat[];
    /** Gets bounds of the given geometry */
    geometryToBounds(geometry: any, paddingPercentage?: number): ArlasLngLatBounds;
}
