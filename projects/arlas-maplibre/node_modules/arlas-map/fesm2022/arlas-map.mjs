import * as i0 from '@angular/core';
import { Component, Output, Injectable, EventEmitter, signal, ViewEncapsulation, Input, HostListener, Pipe, ElementRef, ViewChild, computed, Inject, NgModule } from '@angular/core';
import * as i4 from '@angular/forms';
import { UntypedFormControl, Validators, UntypedFormGroup, FormGroup, FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import * as i1 from '@angular/material/dialog';
import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { marker } from '@colsen1991/ngx-translate-extract-marker';
import { Subject, takeUntil, fromEvent, map, finalize } from 'rxjs';
import * as i2 from 'arlas-web-components';
import { GetCollectionDisplayModule, GetColorModule, GetValueModule, FormatNumberModule, ArlasColorService } from 'arlas-web-components';
import * as i2$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i5 from '@angular/material/form-field';
import { MatFormFieldModule } from '@angular/material/form-field';
import * as i6 from '@angular/material/select';
import { MatSelectModule } from '@angular/material/select';
import * as i7 from '@angular/material/core';
import * as i8 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i3 from '@ngx-translate/core';
import { TranslateModule } from '@ngx-translate/core';
import * as toGeoJSON from '@tmcw/togeojson';
import centroid from '@turf/centroid';
import JSZip from 'jszip';
import { lineString, point, polygon, bearingToAzimuth } from '@turf/helpers';
import * as shp_ from 'shpjs/dist/shp';
import * as extent_ from 'turf-extent';
import { parse } from 'wellknown';
import { valid } from 'geojson-validation';
import * as gpsi_ from 'geojson-polygon-self-intersections';
import * as i9$1 from '@angular/cdk/drag-drop';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import * as i1$1 from '@angular/common/http';
import * as i2$2 from '@angular/material/snack-bar';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import StaticMode from '@mapbox/mapbox-gl-draw-static-mode';
import cleanCoords from '@turf/clean-coords';
import { debounceTime } from 'rxjs/operators';
import bbox from '@turf/bbox';
import area from '@turf/area';
import length from '@turf/length';
import MapboxDraw from '@mapbox/mapbox-gl-draw';
import * as jsts from 'jsts/dist/jsts.min';
import circle from '@turf/circle';
import numeral from 'numeral';
import distance from '@turf/distance';
import center from '@turf/center';
import midpoint from '@turf/midpoint';
import rhumbDestination from '@turf/rhumb-destination';
import rhumbBearing from '@turf/rhumb-bearing';
import transformRotate from '@turf/transform-rotate';
import transformTranslate from '@turf/transform-translate';
import * as i6$1 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i7$1 from '@angular/material/slide-toggle';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import * as i5$1 from '@angular/material/tooltip';
import { MatTooltipModule } from '@angular/material/tooltip';
import * as i6$2 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import { Subject as Subject$1 } from 'rxjs/internal/Subject';
import { scaleLinear } from 'd3-scale';
import { select } from 'd3-selection';
import { area as area$1, curveLinear, line } from 'd3-shape';
import tinycolor from 'tinycolor2';
import * as i5$2 from '@angular/material/menu';
import { MatMenuModule } from '@angular/material/menu';
import * as i9 from '@colsen1991/ngx-translate-extract-marker/extras';
import { MarkerModule } from '@colsen1991/ngx-translate-extract-marker/extras';
import * as i5$3 from '@angular/material/checkbox';
import { MatCheckboxModule } from '@angular/material/checkbox';
import * as i6$3 from '@angular/material/progress-spinner';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import * as i7$2 from '@angular/material/radio';
import { MatRadioModule } from '@angular/material/radio';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { MatTabsModule } from '@angular/material/tabs';

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var GeoQueryOperator;
(function (GeoQueryOperator) {
    GeoQueryOperator["WITHIN"] = "within";
    GeoQueryOperator["NOT_WITHIN"] = "notwithin";
    GeoQueryOperator["INTERSECTS"] = "intersects";
    GeoQueryOperator["NOT_INTERSECTS"] = "notintersects";
})(GeoQueryOperator || (GeoQueryOperator = {}));
class SelectFormControl extends UntypedFormControl {
    constructor(formState, label, options) {
        super(formState, Validators.required);
        this.syncOptions = [];
        this.setValue(formState);
        this.setSyncOptions(options);
    }
    setSyncOptions(newOptions) {
        this.syncOptions = newOptions;
        this.filteredOptions = newOptions;
    }
}
class MapSettingsDialogComponent {
    constructor(dialogRef, colorGeneratorLoader) {
        this.dialogRef = dialogRef;
        this.colorGeneratorLoader = colorGeneratorLoader;
        /**
         * @Output : Angular
         * Emits the geo-query to apply. A geo-query is defined by
         * - the operation ("within", "intersects", "notwithin", "notintersects")
         * - the geometry field to query
         */
        this.geoQueryEmitter = new Subject();
        this.emittedGeoQueries = new Map();
        /** Constants */
        this.GEO_QUERIES_DESCRIPTION = marker('Draw a bbox or a polygon that');
        this.geoQueriesFormGroups = new Array();
        this.collectionsColors = new Array();
        this.selectionsSnapshot = new Map();
        this._onDestroy$ = new Subject();
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    /** Emits the geo-query to apply */
    emitGeoFilter() {
        this.geoQueryEmitter.next(this.emittedGeoQueries);
    }
    /** Closes the dialog */
    onClose() {
        this.dialogRef.close();
    }
    createGeoQueryForm(collectionName, displayCollectionName, filterGeometries, operationsSelectModel) {
        /** geometry */
        const geometryPaths = filterGeometries.map(fg => fg.path);
        const selectedGeometry = filterGeometries.find(fg => fg.selected);
        const selectedGeometryPath = !!selectedGeometry ? selectedGeometry.path : '';
        /** operation */
        const operations = operationsSelectModel.map(osm => osm.operation);
        const selectedOperationSelectModel = operationsSelectModel.find(osm => osm.selected);
        const selectedOperation = !!selectedOperationSelectModel ? selectedOperationSelectModel.operation : GeoQueryOperator.INTERSECTS;
        const geoQueryControls = {
            a_operation: new SelectFormControl(selectedOperation, '', operations),
            b_geometryPath: new SelectFormControl(selectedGeometryPath, '', geometryPaths),
            c_collection: new UntypedFormControl(collectionName),
            d_displayCollectionName: new UntypedFormControl(displayCollectionName),
        };
        const geoQueryForm = new UntypedFormGroup(geoQueryControls);
        /** snapshot defaultselections */
        this.emittedGeoQueries.clear();
        this.selectionsSnapshot.clear();
        this.selectionsSnapshot.set(collectionName, selectedGeometry + selectedOperation);
        geoQueryForm.valueChanges
            .pipe(takeUntil(this._onDestroy$))
            .subscribe(vc => {
            const selectionSnapShot = vc.b_geometryPath + vc.a_operation;
            /** ignore selection changes if the user go back to initial state of a control */
            const ignoreChange = selectionSnapShot === this.selectionsSnapshot.get(vc.c_collection);
            if (ignoreChange) {
                this.emittedGeoQueries.delete(vc.c_collection);
            }
            else {
                this.emittedGeoQueries.set(vc.c_collection, {
                    geometry_path: vc.b_geometryPath,
                    operation: vc.a_operation
                });
            }
        });
        this.collectionsColors.push((this.colorGeneratorLoader.getColor(collectionName)));
        this.geoQueriesFormGroups.push(geoQueryForm);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsDialogComponent, deps: [{ token: i1.MatDialogRef }, { token: i2.ArlasColorService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapSettingsDialogComponent, selector: "arlas-map-settings-dialog", outputs: { geoQueryEmitter: "geoQueryEmitter" }, ngImport: i0, template: "<h1 mat-dialog-title class=\"mapgl-settings__title\">\n  {{ 'Geo-queries' | translate }}\n</h1>\n\n<div mat-dialog-content class=\"mapgl-settings\">\n  <div class=\"mapgl-settings__description\">\n    {{ GEO_QUERIES_DESCRIPTION | translate }}\n  </div>\n  <div class=\"mapgl-settings__form\" *ngFor=\"let formGroup of geoQueriesFormGroups; let i = index\"\n      [formGroup]=\"formGroup\" [style.borderLeftColor]=\"collectionsColors[i]\">\n    <div class=\"mapgl-settings__form__steps\">\n      <div *ngFor=\"let control of formGroup.controls | keyvalue\" class=\"mapgl-settings__form__steps__item\">\n        <div *ngIf=\"control.key === 'd_displayCollectionName'\">\n          {{ 'of_collection' | translate: { collection: (control.value.value | getCollectionDisplayName | translate) } }}\n        </div>\n        <mat-form-field *ngIf=\"control.key !== 'c_collection' && control.key !== 'color' && control.key !== 'd_displayCollectionName'\">\n          <mat-label>{{ control.key | translate }}</mat-label>\n          <mat-select [formControl]=\"control.value\">\n            <mat-option *ngFor=\"let option of control.value.syncOptions\" [value]=\"option\">\n              {{option | translate}}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-settings__actions\">\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter()\">{{ 'Apply geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter();onClose()\">{{ 'Set geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--cancel\"\n    (click)=\"onClose()\">{{ 'Cancel' | translate}}</button>\n</div>\n\n\n", styles: ["@charset \"UTF-8\";::ng-deep .map-settings-dialog .mdc-dialog__surface{padding:0 15px}.mapgl-settings__title{margin:0 0 20px!important}.mapgl-settings{position:relative;overflow:hidden}.mapgl-settings__description{padding-right:20px;padding-bottom:.65em}.mapgl-settings__form{display:flex;margin-bottom:15px;flex-direction:column;padding:5px 15px 0;justify-content:flex-start;box-shadow:0 2px 1px -1px #0003,0 1px 1px #00000024,0 1px 3px #0000001f;border-left:3px solid}.mapgl-settings__form__steps{display:flex;justify-content:left;align-items:center}.mapgl-settings__form__steps__item{padding-right:20px;display:flex;justify-content:left;align-items:center;--mdc-filled-text-field-container-color: transparent;--mat-form-field-focus-state-layer-opacity: 0}.mapgl-settings__actions{--mat-dialog-actions-alignment: end}.mapgl-settings__actions--apply{--mdc-text-button-label-text-color: #ff4081;font-weight:bolder;outline:none}.mapgl-settings__actions--cancel{color:#000;margin:2px;outline:none}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i1.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i1.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "component", type: i5.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i5.MatLabel, selector: "mat-label" }, { kind: "component", type: i6.MatSelect, selector: "mat-select", inputs: ["aria-describedby", "panelClass", "disabled", "disableRipple", "tabIndex", "hideSingleSelectionIndicator", "placeholder", "required", "multiple", "disableOptionCentering", "compareWith", "value", "aria-label", "aria-labelledby", "errorStateMatcher", "typeaheadDebounceInterval", "sortComparator", "id", "panelWidth"], outputs: ["openedChange", "opened", "closed", "selectionChange", "valueChange"], exportAs: ["matSelect"] }, { kind: "component", type: i7.MatOption, selector: "mat-option", inputs: ["value", "id", "disabled"], outputs: ["onSelectionChange"], exportAs: ["matOption"] }, { kind: "component", type: i8.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "pipe", type: i2$1.KeyValuePipe, name: "keyvalue" }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }, { kind: "pipe", type: i2.GetCollectionDisplayNamePipe, name: "getCollectionDisplayName" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-settings-dialog', template: "<h1 mat-dialog-title class=\"mapgl-settings__title\">\n  {{ 'Geo-queries' | translate }}\n</h1>\n\n<div mat-dialog-content class=\"mapgl-settings\">\n  <div class=\"mapgl-settings__description\">\n    {{ GEO_QUERIES_DESCRIPTION | translate }}\n  </div>\n  <div class=\"mapgl-settings__form\" *ngFor=\"let formGroup of geoQueriesFormGroups; let i = index\"\n      [formGroup]=\"formGroup\" [style.borderLeftColor]=\"collectionsColors[i]\">\n    <div class=\"mapgl-settings__form__steps\">\n      <div *ngFor=\"let control of formGroup.controls | keyvalue\" class=\"mapgl-settings__form__steps__item\">\n        <div *ngIf=\"control.key === 'd_displayCollectionName'\">\n          {{ 'of_collection' | translate: { collection: (control.value.value | getCollectionDisplayName | translate) } }}\n        </div>\n        <mat-form-field *ngIf=\"control.key !== 'c_collection' && control.key !== 'color' && control.key !== 'd_displayCollectionName'\">\n          <mat-label>{{ control.key | translate }}</mat-label>\n          <mat-select [formControl]=\"control.value\">\n            <mat-option *ngFor=\"let option of control.value.syncOptions\" [value]=\"option\">\n              {{option | translate}}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-settings__actions\">\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter()\">{{ 'Apply geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter();onClose()\">{{ 'Set geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--cancel\"\n    (click)=\"onClose()\">{{ 'Cancel' | translate}}</button>\n</div>\n\n\n", styles: ["@charset \"UTF-8\";::ng-deep .map-settings-dialog .mdc-dialog__surface{padding:0 15px}.mapgl-settings__title{margin:0 0 20px!important}.mapgl-settings{position:relative;overflow:hidden}.mapgl-settings__description{padding-right:20px;padding-bottom:.65em}.mapgl-settings__form{display:flex;margin-bottom:15px;flex-direction:column;padding:5px 15px 0;justify-content:flex-start;box-shadow:0 2px 1px -1px #0003,0 1px 1px #00000024,0 1px 3px #0000001f;border-left:3px solid}.mapgl-settings__form__steps{display:flex;justify-content:left;align-items:center}.mapgl-settings__form__steps__item{padding-right:20px;display:flex;justify-content:left;align-items:center;--mdc-filled-text-field-container-color: transparent;--mat-form-field-focus-state-layer-opacity: 0}.mapgl-settings__actions{--mat-dialog-actions-alignment: end}.mapgl-settings__actions--apply{--mdc-text-button-label-text-color: #ff4081;font-weight:bolder;outline:none}.mapgl-settings__actions--cancel{color:#000;margin:2px;outline:none}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialogRef }, { type: i2.ArlasColorService }], propDecorators: { geoQueryEmitter: [{
                type: Output
            }] } });
class MapSettingsComponent {
    constructor(dialog) {
        this.dialog = dialog;
        /**
         * @Output : Angular
         * Emits the geo-query to apply. A geo-query is defined by
         * - the operation ("within", "intersects", "notwithin", "notintersects")
         * - the geometry field to query
         */
        this.geoQueryEmitter = new Subject();
    }
    openDialog(mapSettingsService) {
        this.dialogRef = this.dialog.open(MapSettingsDialogComponent, { data: null, panelClass: 'map-settings-dialog' });
        const mapGeoQueries = mapSettingsService.getGeoQueries();
        if (!!mapGeoQueries) {
            mapGeoQueries.forEach((geoQueries, collection) => {
                this.dialogRef.componentInstance.createGeoQueryForm(collection, geoQueries[2], geoQueries[0], geoQueries[1]);
            });
        }
        this.dialogRef.componentInstance.geoQueryEmitter = this.geoQueryEmitter;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsComponent, deps: [{ token: i1.MatDialog }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapSettingsComponent, selector: "arlas-map-settings", outputs: { geoQueryEmitter: "geoQueryEmitter" }, ngImport: i0, template: "\n", styles: ["@charset \"UTF-8\";\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-settings', template: "\n", styles: ["@charset \"UTF-8\";\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }], propDecorators: { geoQueryEmitter: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ArlasLngLat {
    constructor(lng, lat) {
        this.lng = lng;
        this.lat = lat;
    }
    toArray() {
        return [this.lng, this.lat];
    }
}
class ArlasLngLatBounds {
    constructor(sw, ne) {
        this.sw = sw;
        this.ne = ne;
    }
    getEast() {
        return this.ne.lng;
    }
    getNorth() {
        return this.ne.lat;
    }
    getWest() {
        return this.sw.lng;
    }
    getSouth() {
        return this.sw.lat;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * This service exposes a list of map interaction methods that are abstract.
 * Theses methods will be implemented by the chosen cartographical framework to use.
 */
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
class ArlasMapFrameworkService {
    constructor() { }
    /**
     * @description Gets the bounds from the two given coordinates.
     * @param c1 Coordinates of the first corner.
     * @param c2 Coordinates of the second corner.
     * @returns Bounds formed from the two given coordinates.
     */
    getLngLatBound(c1, c2) {
        return new ArlasLngLatBounds(c1, c2);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapFrameworkService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapFrameworkService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapFrameworkService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

var $schema = "http://json-schema.org/draft-06/schema#";
var title = "Map's inputs configuration";
var description = "The Configuration of the map's inputs";
var type = "object";
var $id = "arlas-map.schema.json";
var properties = {
	displayScale: {
		description: "Whether the scale is displayed",
		type: "boolean"
	},
	displayLayerSwitcher: {
		description: "Whether the layer switcher controll is displayed. If not, the map component uses the default style group and with its default style.",
		type: "boolean"
	},
	maxWidthScale: {
		description: "Max width of the scale in px. Default value is 100px.",
		type: "number"
	},
	unitScale: {
		description: "Unit of the scale. Default value is 'metric'.",
		type: "string"
	},
	mapLayers: {
		$id: "/properties/mapLayers",
		type: "object",
		properties: {
			layers: {
				description: "List of layers",
				type: "array"
			},
			events: {
				type: "object",
				properties: {
					onHover: {
						description: "List of layers ids to listen to on hover",
						type: "array"
					},
					emitOnClick: {
						description: "List of layers ids to listen to on click event in order to emit features",
						type: "array"
					},
					zoomOnClick: {
						description: "List of layers ids to listen to on click event in order to trigger zoom action",
						type: "array"
					}
				},
				required: [
					"onHover",
					"emitOnClick",
					"zoomOnClick"
				]
			}
		},
		required: [
			"layers",
			"events"
		]
	},
	mapSources: {
		description: "List of sources to add to the map as basemaps",
		type: "array",
		items: {
			type: "object",
			properties: {
				id: {
					description: "Id of the source.",
					type: "string"
				},
				source: {
					description: "source.",
					type: "object",
					properties: {
						type: {
							description: "Type of the source. Possible values : 'vector' | 'raster' | 'geojson' | 'image' | 'video' | 'canvas'",
							type: "string"
						},
						minzoom: {
							description: "Minimum zoom to display the source layers",
							type: "integer"
						},
						maxzoom: {
							description: "Maximum zoom to display the source layers",
							type: "integer"
						},
						url: {
							description: "Url to the source (for `vector`, `raster`, `image`, `video` types).",
							type: "string"
						},
						tiles: {
							description: "List of tiles (for `vector` and `raster` types).",
							type: "array"
						},
						coordinates: {
							description: "The 4 corners coordinates of the canvas/image/video, given as [longitude, latitude].",
							type: "array"
						},
						data: {
							description: "A geojson object or a url to a geojson file (for `geosjson` type).",
							type: "array"
						},
						canvas: {
							description: "Id of the canvas element (for `canvas` type)",
							type: "string"
						},
						animate: {
							description: "Whether the canvas source is animated (for `canvas` type)",
							type: "boolean"
						}
					},
					required: [
						"type"
					]
				}
			},
			required: [
				"id",
				"source"
			]
		}
	},
	defaultBasemapStyle: {
		description: "Defines the name and default basemap style.",
		type: "object",
		properties: {
			name: {
				description: "name of the style",
				type: "string"
			},
			styleFile: {
				description: "url to basemap style or a `maplibre.Style`",
				type: [
					"string",
					"object"
				]
			}
		},
		required: [
			"name",
			"styleFile"
		]
	},
	basemapStyles: {
		description: "List of basemaps styles",
		type: "array",
		items: {
			description: "Defines the name and the basemap style.",
			type: "object",
			properties: {
				name: {
					description: "name of the style",
					type: "string"
				},
				styleFile: {
					description: "url to basemap style or a `maplibre.Style`",
					type: [
						"string",
						"object"
					]
				}
			},
			required: [
				"name",
				"styleFile"
			]
		}
	},
	initCenter: {
		description: "Coordinates of the map's center when it's initialized.",
		type: "array",
		minItems: 2,
		maxItems: 2,
		items: [
			{
				description: "Longitude",
				type: "number"
			},
			{
				description: "Latitude",
				type: "number"
			}
		]
	},
	initZoom: {
		description: "Zoom of the map when it's initialized",
		type: "number"
	},
	minZoom: {
		description: "Min zoom of the map",
		type: "number"
	},
	maxZoom: {
		description: "Max zoom of the map",
		type: "number"
	},
	margePanForLoad: {
		description: "Margin applied to the map extent. Data is loaded in all this extent",
		type: "number"
	},
	margePanForTest: {
		description: "Margin applied to the map extent. Before loading data, the components checks first if there are features already loaded in this extent.",
		type: "number"
	},
	drawButtonEnabled: {
		description: "Whether the draw tools are activated.",
		type: "boolean"
	},
	drawPolygonVerticesLimit: {
		description: "Maximum number of vertices allowed when drawing a polygon."
	},
	visualisationSetsConfig: {
		description: "List of visualisation sets",
		type: "array",
		items: {
			description: "A Visualisation set is an entity where layers are grouped together.",
			type: "object",
			properties: {
				name: {
					description: "Name of the visualisation set.",
					type: "string"
				},
				layers: {
					description: "List of layers ids grouped in this visualisation set.",
					type: "array",
					items: {
						description: "layer id",
						type: "string"
					}
				},
				enabled: {
					description: "If enabled, all the layers can be displayed on the map, otherwise the layers are removed from the map.",
					type: "boolean"
				}
			}
		}
	},
	icons: {
		description: "List of icons to add to the map and to use in layers styling.",
		type: "array",
		items: {
			description: "Icon to add",
			type: "object",
			properties: {
				path: {
					description: "path to the icon. The icon should be placed at `assest/icons` folder and should be `png` or `jpeg`. Example : 'path': 'name_of_icon.png'",
					type: "string"
				},
				recolorable: {
					description: "Whether to allow recolorising the icon or not.",
					type: "boolean"
				}
			}
		}
	}
};
var required = [
	"mapLayers",
	"margePanForLoad",
	"margePanForTest"
];
var arlasMap_schema = {
	$schema: $schema,
	title: title,
	description: description,
	type: type,
	$id: $id,
	properties: properties,
	required: required
};

var mapJsonSchema = /*#__PURE__*/Object.freeze({
    __proto__: null,
    $id: $id,
    $schema: $schema,
    default: arlasMap_schema,
    description: description,
    properties: properties,
    required: required,
    title: title,
    type: type
});

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var ExternalEvent;
(function (ExternalEvent) {
    ExternalEvent["select"] = "select";
    ExternalEvent["hover"] = "hover";
})(ExternalEvent || (ExternalEvent = {}));
const HOVER_LAYER_PREFIX = 'arlas-hover-';
const SELECT_LAYER_PREFIX = 'arlas-select-';
const FILLSTROKE_LAYER_PREFIX = 'arlas-fill_stroke-';
const SCROLLABLE_ARLAS_ID = 'scrollable_arlas_id:';
const ARLAS_ID = 'arlas_id:';
const ARLAS_VSET = ':arlas_vset:';
/** FROM V15.0.0 layer ids look like 'arlas_id:NAME:timestamp
   * This pipe extracts the 'NAME' in that id
   */
function getLayerName(id) {
    if (!!id && id.startsWith(ARLAS_ID)) {
        const datedName = id.split(ARLAS_ID)[1];
        const undatedName = datedName.split(':')[0];
        return undatedName;
    }
    return id;
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * This service propose a set of method to execute the ArlasMapComponent logic.
 * Do not confuse with ArlasMapFrameworkService that is more dedicated to a framework logic.
 */
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
class AbstractArlasMapService {
    constructor(mapFrameworkService) {
        this.mapFrameworkService = mapFrameworkService;
        /** @description List of arlas data sources declared in configuration */
        this.dataSources = [];
        /**
         * @description Object to describe visualisation sets
         * - visulisations: a map of <visualisation name, set of layers identifiers>;
         * - status: a map of <visualisation name, visibility status>
         */
        this.visualisationsSets = {
            visualisations: new Map(),
            status: new Map()
        };
    }
    updateLabelSources(labelSourceId, data, map) {
        if (labelSourceId) {
            const source = this.mapFrameworkService.getSource(labelSourceId, map);
            this.mapFrameworkService.setDataToGeojsonSource(source, data);
        }
    }
    /**
     * @description Inits a map of visulisation sets from the configuration.
     * @param visualisationSetsConfig Visualisation set configuration.
     */
    initVisualisationSet(visualisationSetsConfig) {
        if (visualisationSetsConfig) {
            visualisationSetsConfig.forEach(visu => {
                this.visualisationsSets.visualisations.set(visu.name, new Set(visu.layers));
                this.visualisationsSets.status.set(visu.name, visu.enabled);
            });
        }
    }
    initMapLayers(mapLayers, map) {
        if (mapLayers) {
            this.setLayersMap(mapLayers);
        }
    }
    addArlasDataLayers(visualisationSetsConfig, mapLayers, map) {
        this.initMapLayers(mapLayers, map);
        this.initVisualisationSet(visualisationSetsConfig);
        for (let i = visualisationSetsConfig.length - 1; i >= 0; i--) {
            const visualisation = visualisationSetsConfig[i];
            if (visualisation.layers) {
                for (let j = visualisation.layers.length - 1; j >= 0; j--) {
                    const l = visualisation.layers[j];
                    const layer = this.layersMap.get(l);
                    this.addArlasDataLayer(map, layer, this.layersMap);
                }
            }
        }
        this._addExternalEventLayers(mapLayers, map);
        this.visualisationsSets.status.forEach((visible, vs) => {
            this.visualisationsSets.visualisations.get(vs).forEach(l => {
                this.mapFrameworkService.setLayerVisibility(l, visible, map);
            });
        });
        this.reorderLayers(visualisationSetsConfig, map);
    }
    _addExternalEventLayers(mapLayers, map) {
        if (mapLayers.externalEventLayers) {
            mapLayers.layers
                .filter(layer => mapLayers.externalEventLayers.map(e => e.id).indexOf(layer.id) >= 0)
                .forEach(l => {
                this.mapFrameworkService.addLayer(map, l);
            });
        }
    }
    reorderLayers(visualisationSetsConfig, map) {
        // parses the visulisation list from bottom in order to put the fist ones first
        for (let i = visualisationSetsConfig.length - 1; i >= 0; i--) {
            const visualisation = visualisationSetsConfig[i];
            if (!!visualisation.layers && visualisation.enabled) {
                for (let j = visualisation.layers.length - 1; j >= 0; j--) {
                    const l = visualisation.layers[j];
                    this.moveArlasDataLayer(map, l, this.layersMap);
                }
            }
        }
        this.reorderDrawLayers(map);
    }
    selectFeatures(mapLayers, map, elementToSelect) {
        if (elementToSelect) {
            const ids = elementToSelect.length > 0 ?
                elementToSelect.reduce((memo, element) => {
                    memo.push(element.idValue);
                    return memo;
                }, []) : [];
            const numericalIds = ids.filter(id => !isNaN(+id)).map(id => +id);
            const visibilityFilter = ids.length > 0 ? ['in', ['get', elementToSelect[0].idFieldName], ['literal', ids.concat(numericalIds)]] : [];
            this.filterLayers(mapLayers, map, (elementToSelect.length > 0), visibilityFilter, ExternalEvent.select);
        }
    }
    highlightFeature(mapLayers, map, featureToHightLight) {
        if (featureToHightLight?.elementidentifier) {
            const ids = [featureToHightLight.elementidentifier.idValue];
            if (!isNaN(+featureToHightLight.elementidentifier.idValue)) {
                ids.push(+featureToHightLight.elementidentifier.idValue);
            }
            const visibilityFilter = ['in', ['get', featureToHightLight.elementidentifier.idFieldName],
                ['literal', ids]];
            this.filterLayers(mapLayers, map, !featureToHightLight.isleaving, visibilityFilter, ExternalEvent.hover);
        }
    }
    selectFeaturesByCollection(mapLayers, map, features, collection) {
        const ids = features.map(f => f.idValue);
        const numericalIds = ids.filter(id => !isNaN(+id)).map(id => +id);
        const visibilityFilter = ids.length > 0 ? ['in', ['get', features[0].idFieldName], ['literal', ids.concat(numericalIds)]] : [];
        this.filterLayers(mapLayers, map, (features.length > 0), visibilityFilter, ExternalEvent.select, collection);
    }
    updateLayoutVisibility(visualisationName, visualisationSetsConfig, map) {
        const visuStatus = !this.visualisationsSets.status.get(visualisationName);
        visualisationSetsConfig.find(v => v.name === visualisationName).enabled = visuStatus;
        if (!visuStatus) {
            const layersSet = new Set(this.visualisationsSets.visualisations.get(visualisationName));
            this.visualisationsSets.visualisations.forEach((ls, v) => {
                if (v !== visualisationName) {
                    ls.forEach(ll => {
                        if (layersSet?.has(ll)) {
                            layersSet.delete(ll);
                        }
                    });
                }
            });
            layersSet.forEach(ll => {
                this.mapFrameworkService.setLayerVisibility(ll, false, map);
            });
        }
        this.visualisationsSets.status.set(visualisationName, visuStatus);
        const layers = new Set();
        this.visualisationsSets.visualisations.forEach((ls, v) => {
            if (this.visualisationsSets.status.get(v)) {
                ls.forEach(l => {
                    layers.add(l);
                    this.mapFrameworkService.setLayerVisibility(l, true, map);
                });
            }
        });
        return layers;
    }
    updateVisibility(visibilityStatus, visualisationSetsConfig, map) {
        visibilityStatus.forEach((visibilityStatus, l) => {
            let layerInVisualisations = false;
            if (!visibilityStatus) {
                visualisationSetsConfig.forEach(v => {
                    const ls = new Set(v.layers);
                    if (!layerInVisualisations) {
                        layerInVisualisations = ls.has(l);
                    }
                });
                if (layerInVisualisations) {
                    this.mapFrameworkService.setLayerVisibility(l, false, map);
                }
            }
            else {
                let oneVisualisationEnabled = false;
                visualisationSetsConfig.forEach(v => {
                    const ls = new Set(v.layers);
                    if (!layerInVisualisations) {
                        layerInVisualisations = ls.has(l);
                    }
                    if (ls.has(l) && v.enabled) {
                        oneVisualisationEnabled = true;
                        this.mapFrameworkService.setLayerVisibility(l, true, map);
                    }
                });
                if (!oneVisualisationEnabled && layerInVisualisations) {
                    this.mapFrameworkService.setLayerVisibility(l, false, map);
                }
            }
        });
    }
    findVisualisationSetLayer(visuName, visualisationSetsConfig) {
        return visualisationSetsConfig.find(v => v.name === visuName).layers;
    }
    setVisualisationSetLayers(visuName, layers, visualisationSetsConfig) {
        const f = visualisationSetsConfig.find(v => v.name === visuName);
        if (f) {
            f.layers = layers;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AbstractArlasMapService, deps: [{ token: ArlasMapFrameworkService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AbstractArlasMapService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AbstractArlasMapService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: ArlasMapFrameworkService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
class BasemapService {
    constructor(http, mapFrameworkService) {
        this.http = http;
        this.mapFrameworkService = mapFrameworkService;
        this.POWERED_BY_ARLAS = ' Powered by ARLAS.';
        this.LOCAL_STORAGE_BASEMAPS = 'arlas_last_base_map';
        this.basemapChangedSource = new Subject();
        this.basemapChanged$ = this.basemapChangedSource.asObservable();
        this.protomapBasemapAddedSource = new Subject();
        this.protomapBasemapAdded$ = this.protomapBasemapAddedSource.asObservable();
    }
    setBasemaps(basemaps) {
        this.basemaps = basemaps;
    }
    addPMtilesToSource(map, pmtilesSource) {
        /* eslint-disable max-len */
        pmtilesSource['attribution'] = '<a href="https://protomaps.com/" target="_blank">Protomaps</a> <a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap</a>';
        pmtilesSource['attribution'] = pmtilesSource['attribution'] + this.POWERED_BY_ARLAS;
        this.mapFrameworkService.setSource('arlas_protomaps_source', pmtilesSource, map);
    }
    addProtomapLayerToMap(map, styleFile) {
        styleFile.layers.forEach(l => {
            this.mapFrameworkService.removeLayer(map, l.id);
            this.mapFrameworkService.addLayer(map, l);
        });
    }
    notifyProtomapAddition() {
        this.protomapBasemapAddedSource.next(true);
    }
    cloneStyleFile(selected) {
        return { ...selected.styleFile };
    }
    buildInitStyle(clonedStyleFile) {
        clonedStyleFile.sources = {
            protomaps_attribution: {
                'type': 'vector',
                // eslint-disable-next-line max-len
                'attribution': '<a href="https://protomaps.com/" target="_blank">Protomaps</a> <a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap</a>' + this.POWERED_BY_ARLAS
            }
        };
        clonedStyleFile.layers = [{
                id: 'backgrounds',
                type: 'background',
                source: 'protomaps_attribution',
                paint: {
                    'background-color': 'rgba(0,0,0,0)'
                }
            }];
        return clonedStyleFile;
    }
    ;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapService, deps: [{ token: i1$1.HttpClient }, { token: ArlasMapFrameworkService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: i1$1.HttpClient }, { type: ArlasMapFrameworkService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ArlasBasemaps {
    constructor(defaultBasemapStyle, basemapStyles) {
        this.LOCAL_STORAGE_BASEMAPS = 'arlas_last_base_map';
        if (defaultBasemapStyle && basemapStyles) {
            this.defaultBasemapStyle = defaultBasemapStyle;
            this.basemapStyles = basemapStyles;
        }
        else {
            // todo throw error ?
        }
    }
    styles() {
        if (!this._styles) {
            this._styles = this.getAllBasemapStyles(this.defaultBasemapStyle, this.basemapStyles);
        }
        return this._styles.filter(b => !b.errored);
    }
    setSelected(style) {
        this._selectedStyle = style;
        return this;
    }
    getStyle(b) {
        return this.styles().find(s => s.name === b?.name);
    }
    getSelected() {
        if (!this._selectedStyle) {
            const styles = this.styles();
            const localStorageBasemapStyle = JSON.parse(localStorage.getItem(this.LOCAL_STORAGE_BASEMAPS));
            const sameNameBasemaps = localStorageBasemapStyle ? styles.filter(b => b.name === localStorageBasemapStyle.name) : [];
            if (sameNameBasemaps.length > 0) {
                this._selectedStyle = sameNameBasemaps[0];
            }
            else if (!!this.getStyle(this.defaultBasemapStyle)) {
                this._selectedStyle = this.getStyle(this.defaultBasemapStyle);
            }
            else if (styles && styles.length > 0) {
                this._selectedStyle = styles[0];
            }
            else {
                this._selectedStyle = {
                    name: 'Background',
                    styleFile: {
                        version: 8,
                        sources: {},
                        layers: [
                            {
                                id: 'backgrounds',
                                type: 'background',
                                paint: {
                                    'background-color': 'rgba(0,0,0,0)'
                                }
                            }
                        ]
                    }
                };
            }
        }
        return this._selectedStyle;
    }
    getAllBasemapStyles(defaultBasemapTheme, basemapStyles) {
        const allBasemapStyles = new Array();
        if (basemapStyles) {
            basemapStyles.forEach(b => allBasemapStyles.push(b));
            if (defaultBasemapTheme) {
                if (basemapStyles.map(b => b.name).filter(n => n === defaultBasemapTheme.name).length === 0) {
                    allBasemapStyles.push(defaultBasemapTheme);
                }
            }
        }
        else if (defaultBasemapTheme) {
            allBasemapStyles.push(defaultBasemapTheme);
        }
        return allBasemapStyles;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const GEOJSON_SOURCE_TYPE = 'geojson';
const CROSS_LAYER_PREFIX = 'arlas_cross';
const ZOOM_IN = marker('Zoom in');
const ZOOM_OUT = marker('Zoom out');
const RESET_BEARING = marker('Reset bearing to north');
const LAYER_SWITCHER_TOOLTIP = marker('Manage layers');
/**
 * The aim of this class is to handle all core interaction we have
 * with a map provider.
 * The aim is also to separate the Arlas map from the Angular framework.
 * It will be instantiated in the map.component and will be responsible for initializing the map and all map behavior.
 */
class AbstractArlasMapGL {
    constructor(config) {
        this.config = config;
        this.POLYGON_LABEL_SOURCE = 'polygon_label';
        this._eventSubscription = [];
        this.evented = new EventTarget();
        this.config = config;
        this._offset = config.offset;
        this._margePanForLoad = config.margePanForLoad;
        this._margePanForTest = config.margePanForTest;
        this._displayCurrentCoordinates = config.displayCurrentCoordinates ?? false;
        this._wrapLatLng = config.wrapLatLng ?? true;
        this._controls = config.controls;
        this._fitBoundsPadding = config.fitBoundsPadding ?? 10;
        this._maxWidthScale = config.maxWidthScale;
        this._unitScale = config.unitScale;
        this.init(config);
    }
    init(config) {
        try {
            this._initMapProvider(config);
            this._initControls();
            this._initOnLoad();
            this._initMapMoveEvents();
        }
        catch (e) {
            console.log(e);
        }
    }
    _initOnLoad() {
        this.onLoad(() => {
            this.evented.dispatchEvent(new Event('beforeOnLoadInit'));
            this._updateBounds();
            this._updateZoom();
            this.getMapProvider().fitBounds(this.getBounds());
        });
    }
    onCustomEvent(event, loadFn) {
        this.evented.addEventListener(event, loadFn);
    }
    _initMapMoveEvents() {
        this._zoomStart$ = fromEvent(this.getMapProvider(), 'zoomstart')
            .pipe(debounceTime(750));
        this._dragStart$ = fromEvent(this.getMapProvider(), 'dragstart')
            .pipe(debounceTime(750));
        this._dragEnd$ = fromEvent(this.getMapProvider(), 'dragend')
            .pipe(debounceTime(750));
        this._moveEnd$ = fromEvent(this.getMapProvider(), 'moveend')
            .pipe(debounceTime(750));
        this._updateOnZoomStart();
        this._updateOnDragStart();
        this._updateOnDragEnd();
        this._updateOnMoveEnd();
    }
    _updateBounds() {
        this._west = this.getWestBounds();
        this._south = this.getSouthBounds();
        this._east = this.getEastBounds();
        this._north = this.getNorthBounds();
    }
    _updateZoom(e) {
        this.zoom = this.getZoom();
    }
    _updateCurrentLngLat(e) {
        const lngLat = e.lngLat;
        if (this._displayCurrentCoordinates) {
            const displayedLngLat = this._wrapLatLng ? lngLat.wrap() : lngLat;
            this.currentLng = String(Math.round(displayedLngLat.lng * 100000) / 100000);
            this.currentLat = String(Math.round(displayedLngLat.lat * 100000) / 100000);
        }
    }
    _updateDragEnd(e) {
        if (e.originalEvent) {
            this._dragEndX = e.originalEvent.clientX;
            this._dragEndY = e.originalEvent.clientY;
        }
    }
    _updateDragStart(e) {
        this._dragStartX = e.originalEvent.clientX;
        this._dragStartY = e.originalEvent.clientY;
    }
    _updateEndLngLat(e) {
        this.endLngLat = e.lngLat;
    }
    _updateMoveRatio(e) {
        this._xMoveRatio = Math.abs(this._dragEndX - this._dragStartX) / e.target._canvas.clientWidth;
        this._yMoveRatio = Math.abs(this._dragEndY - this._dragStartY) / e.target._canvas.clientHeight;
    }
    _updateStartLngLat(e) {
        this.startLngLat = e.lngLat;
    }
    _updateZoomStart() {
        this._zoomStart = this.getZoom();
    }
    _updateOnZoomStart() {
        const sub = this._zoomStart$.subscribe(_ => this._updateZoomStart());
        this._eventSubscription.push(sub);
    }
    _updateOnDragStart() {
        const sub = this._dragStart$.subscribe(e => this._updateDragStart(e));
        this._eventSubscription.push(sub);
    }
    _updateOnDragEnd() {
        const sub = this._dragEnd$
            .subscribe(e => {
            this._updateDragEnd(e);
            this._updateMoveRatio(e);
        });
        this._eventSubscription.push(sub);
    }
    _updateOnMoveEnd() {
        const sub = this._moveEnd$
            .subscribe(_ => {
            this._updateBounds();
            this._updateZoom();
        });
        this._eventSubscription.push(sub);
    }
    onMoveEnd(visualisationsSets, cb) {
        return this._moveEnd$
            .pipe(map(_ => {
            this._updateBounds();
            this._updateZoom();
            if (cb) {
                cb();
            }
            return this._getMoveEnd(visualisationsSets);
        }));
    }
    setLayoutProperty(layer, name, value, options) {
        this.getMapProvider().setLayoutProperty(layer, name, value, options);
        return this;
    }
    unsubscribeEvents() {
        this._eventSubscription.forEach(s => s.unsubscribe());
    }
    getMaxZoom() {
        return this.getMapProvider().getMaxZoom();
    }
    getMinZoom() {
        return this.getMapProvider().getMinZoom();
    }
    getPitch() {
        return this.getMapProvider().getPitch();
    }
    /** Gets bounds of the given geometry */
    geometryToBounds(geometry, paddingPercentage) {
        const boundingBox = bbox(geometry);
        let west = boundingBox[0];
        let south = boundingBox[1];
        let east = boundingBox[2];
        let north = boundingBox[3];
        if (paddingPercentage !== undefined) {
            let width = east - west;
            let height = north - south;
            /** if there is one hit, then west=east ===> we consider a width of 0.05°*/
            if (width === 0) {
                width = 0.05;
            }
            /** if there is one hit, then north=south ===> we consider a height of 0.05°*/
            if (height === 0) {
                height = 0.05;
            }
            west = west - paddingPercentage * width;
            south = Math.max(-90, south - paddingPercentage * height);
            east = east + paddingPercentage * width;
            north = Math.min(90, north + paddingPercentage * height);
        }
        const bounds = new ArlasLngLatBounds(new ArlasLngLat(west, south), new ArlasLngLat(east, north));
        return bounds;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function latLngToWKT(features) {
    let wktType = 'POLYGON[###]';
    if (features.length > 1) {
        wktType = 'MULTIPOLYGON([###])';
    }
    let polygons = '';
    features.forEach((feat, indexFeature) => {
        if (feat) {
            const currentFeat = feat.geometry.coordinates;
            polygons += (indexFeature === 0 ? '' : ',') + '((';
            currentFeat[0].forEach((coord, index) => {
                polygons += (index === 0 ? '' : ',') + coord[0] + ' ' + coord[1];
            });
            polygons += '))';
        }
    });
    let wkt = '';
    if (polygons !== '') {
        wkt = wktType.replace('[###]', polygons);
    }
    return wkt;
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MapboxAoiDrawService {
    constructor() {
        this.ids = new Set();
        this.editAoiSource = new Subject();
        this.editAoi$ = this.editAoiSource.asObservable();
        this.drawBboxSource = new Subject();
        this.drawBbox$ = this.drawBboxSource.asObservable();
        /** Set to true when the user is drawing a bbox. */
        this.isDrawingBbox = false;
        /** Set to true when the user is drawing a circle. */
        this.isDrawingCircle = false;
        /** Set to true when the user is drawing a strip. */
        this.isDrawingStrip = false;
        /** Set to true when the user is drawing a polygon. */
        this.isDrawingPolygon = false;
        /** Set to true when the user is in simple draw mode. */
        this.isInSimpleDrawMode = false;
        /** Set to true when the drawn geometry is selected. */
        this.isDrawSelected = false;
        this.isReady = false;
    }
    isDrawing() {
        return this.isDrawingBbox || this.isDrawingCircle || this.isDrawingPolygon || this.isDrawingStrip;
    }
    drawBbox(fCorner, sCorner) {
        const west = Math.min(fCorner.lng, sCorner.lng);
        const east = Math.max(fCorner.lng, sCorner.lng);
        const south = Math.min(fCorner.lat, sCorner.lat);
        const north = Math.max(fCorner.lat, sCorner.lat);
        this.drawBboxSource.next({
            west,
            east,
            south,
            north
        });
    }
    setDraw(mapboxDraw) {
        this.mapDraw = mapboxDraw;
        this.isReady = true;
        this.onSelectionChange();
        this.onRender();
        this.onDelete();
        this.onStop();
    }
    /**
     * Add new features to the mapboxdraw object.
     * @param fc Featurecollection to be added to mapboxdraw object.
     * @param deleteOld if true, the mapboxdraw object is purged first, before adding the new given feature collection.
     */
    addFeatures(fc, deleteOld = false) {
        if (deleteOld) {
            this.mapDraw.deleteAll();
        }
        this.registeringMode = true;
        this.mapDraw.add(fc);
    }
    /** Deletes all the features from Mapboxdraw object */
    deleteAll() {
        this.registeringMode = true;
        this.mapDraw.deleteAll();
    }
    /** Deletes all the features from Mapboxdraw object that have not been saved */
    deleteUnregisteredFeatures() {
        this.mapDraw.delete(this.getUnregistredFeatures().map(f => f.id.toString()));
    }
    /** Returns the area of the given feature */
    calculateArea(feature) {
        if (this.isArea(feature)) {
            return area(feature);
        }
        return 0;
    }
    /** Returns the width x height of the given feature's envelope */
    calculateEnvelopeDimension(feature) {
        if (this.isLine(feature)) {
            const [minX, minY, maxX, maxY] = bbox(feature);
            const verticalLine = lineString([[minX, minY], [minX, maxY]]);
            const horizontalLine = lineString([[minX, minY], [maxX, minY]]);
            return [length(horizontalLine), length(verticalLine)];
        }
        return [0, 0];
    }
    /** on selection of a drawn polygon, we get its corresponding id. */
    onSelectionChange() {
        this.mapDraw.on('draw.selectionchange', (e) => {
            const features = e.features;
            if (this.hasFeatures(features)) {
                this.editionId = features[0].id;
            }
            else {
                this.endDimensionsEmission();
            }
        });
    }
    hasFeatures(features) {
        return !!features && features.length > 0;
    }
    /** Triggered on deletion of feature(s).
     * - Removes the deleted feature(s) from this service's register.
     * - Stops emitting Aoi dimension info.
     * */
    onDelete() {
        this.mapDraw.on('draw.delete', (e) => {
            e.features.forEach(f => this.unregister(f.id));
            this.endDimensionsEmission();
        });
    }
    onStop() {
        this.mapDraw.on('draw.onStop', (e) => {
            this.register(this.editionId);
            this.endDimensionsEmission();
        });
    }
    /**
     * This event is triggered :
     * - after draw.update
     * - after draw.delete
     * - on adding/deleting features from mapboxdraw object.
     */
    onRender() {
        this.mapDraw.on('draw.render', (e) => {
            if (this.mapDraw) {
                this.registerAll();
                const unregisteredFeatures = this.getUnregistredFeatures();
                if (unregisteredFeatures && (unregisteredFeatures.length === 1 || unregisteredFeatures.length === 2)) {
                    const index = unregisteredFeatures.length - 1;
                    this.editionId = unregisteredFeatures[index].id + '';
                }
                if (this.editionId) {
                    const feature = this.getFeature(this.editionId, this.mapDraw);
                    this.emitDimensions(feature);
                }
            }
        });
    }
    emitStartBBox() {
        this.editAoiSource.next({
            area: 0,
            areaMessage: marker('Start draging to draw a bbox.'),
            envelope: {
                width: 0,
                height: 0
            },
            show: true
        });
    }
    /** Emits dimension info of the given feature.*/
    emitDimensions(feature) {
        const a = this.calculateArea(feature);
        const wh = this.calculateEnvelopeDimension(feature);
        this.editAoiSource.next({
            area: a,
            areaMessage: a > 0 ? '' : marker('Draw at least 2 points.'),
            envelope: {
                width: wh[0],
                height: wh[1]
            },
            show: true
        });
    }
    /** Stops emitting Aoi dimension info */
    endDimensionsEmission() {
        this.editionId = undefined;
        this.editAoiSource.next({
            area: 0,
            envelope: {
                width: 0,
                height: 0
            },
            show: false
        });
    }
    /** Mapbox lacks a method to get the identifier of a new feature that is being drawn and not yet created
     * this method detects this feature on 'draw.render' event.
    */
    getUnregistredFeatures() {
        return this.mapDraw.getAllFeatures().filter(f => !this.ids.has(f.id.toString()));
    }
    /** registers the identifiers of each drawn polygon in this service. */
    registerAll() {
        if (this.registeringMode) {
            this.ids.clear();
            const fc = this.mapDraw.getAll();
            if (!!fc && !!fc.features) {
                this.ids = new Set(fc.features.map(f => f.id.toString()));
            }
            this.registeringMode = false;
        }
    }
    /** Unregisters the given feature id in this service. */
    unregister(id) {
        this.ids.delete(id);
    }
    /** Registers the given feature id in this service. */
    register(id) {
        this.ids.add(id);
    }
    /** Gets the given feature from MapboxDraw object. */
    getFeature(featureId, mapDraw) {
        return mapDraw.get(featureId);
    }
    /** Checks if the given feature has enough coordinates to represent an area (polygon) */
    isArea(feature) {
        const isGeometryDefined = !!feature && !!feature.geometry;
        const areCoordinatesDefined = isGeometryDefined && !!feature.geometry.coordinates;
        if (areCoordinatesDefined) {
            const coordinates = feature.geometry.coordinates;
            const isArea = coordinates.length === 1 && coordinates[0].length > 3;
            return isArea;
        }
        return false;
    }
    /** Checks if the given feature has enough coordinates to represent a line */
    isLine(feature) {
        const isGeometryDefined = !!feature && !!feature.geometry;
        const areCoordinatesDefined = isGeometryDefined && !!feature.geometry.coordinates;
        if (areCoordinatesDefined) {
            const coordinates = feature.geometry.coordinates;
            const isLine = coordinates.length === 1 && coordinates[0].length > 1;
            return isLine;
        }
        return false;
    }
    /**
     * Chck if its a valid circle
     * @param feature
     */
    isValidCircle(feature) {
        const coordinates = feature.geometry.coordinates;
        return this.isCircle(feature) && coordinates && coordinates[0] !== null && coordinates[0][0] !== null && feature.properties.center;
    }
    isValidPolygon(feature) {
        const coordinates = feature.geometry.coordinates;
        return this.isPolygon(feature) && coordinates && coordinates[0] !== null && coordinates[0][0] !== null;
    }
    isPolygon(feature) {
        return feature.geometry.type === 'Polygon' && !this.isCircle(feature);
    }
    isCircle(feature) {
        return feature.properties?.isCircle;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapboxAoiDrawService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapboxAoiDrawService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapboxAoiDrawService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const limitVertexDirectSelectMode = MapboxDraw.modes.direct_select;
const reader$1 = new jsts.io.GeoJSONReader();
limitVertexDirectSelectMode.fireInvalidGeom = function (feature) {
    this.map.fire('draw.invalidGeometry', {
        action: 'error',
        features: [feature]
    });
};
limitVertexDirectSelectMode.fireInitialFeature = function (feature) {
    this.map.fire('draw.edit.saveInitialFeature', {
        feature: feature
    });
};
limitVertexDirectSelectMode.toDisplayFeatures = function (state, geojson, push) {
    if (state.featureId === geojson.properties.id) {
        geojson.properties.active = MapboxDraw.constants.activeStates.ACTIVE;
        push(geojson);
        MapboxDraw.lib.createSupplementaryPoints(geojson, {
            map: this.map,
            midpoints: geojson.geometry.coordinates[0].length >= state.maxVertexByPolygon + 1 ? false : true,
            selectedPaths: state.selectedCoordPaths
        }).forEach(push);
    }
    else {
        geojson.properties.active = MapboxDraw.constants.activeStates.INACTIVE;
        push(geojson);
    }
    this.fireActionable(state);
};
limitVertexDirectSelectMode.onTouchEnd = limitVertexDirectSelectMode.onMouseUp = function (state) {
    if (state.dragMoving) {
        const featureCoords = [...state.feature.coordinates[0]];
        if (featureCoords[0][0] !== featureCoords[featureCoords.length - 1][0] ||
            featureCoords[0][1] !== featureCoords[featureCoords.length - 1][1]) {
            featureCoords.push(featureCoords[0]);
        }
        const currentFeature = {
            'type': 'Feature',
            'geometry': {
                'type': 'Polygon',
                'coordinates': [featureCoords]
            }
        };
        const g = reader$1.read(currentFeature);
        if (!g.geometry.isValid()) {
            this.fireInvalidGeom(currentFeature);
        }
        else {
            this.fireUpdate();
        }
    }
    this.stopDragging(state);
};
limitVertexDirectSelectMode.onSetup = function (opts) {
    const featureId = opts.featureId;
    let maxVertexByPolygon = opts.maxVertexByPolygon;
    const feature = this.getFeature(featureId);
    this.fireInitialFeature(feature);
    if (!feature) {
        throw new Error('You must provide a featureId to enter direct_select mode');
    }
    if (!maxVertexByPolygon) {
        maxVertexByPolygon = 100;
    }
    if (feature.type === MapboxDraw.constants.geojsonTypes.POINT) {
        throw new TypeError('direct_select mode doesn\'t handle point features');
    }
    const state = {
        featureId,
        feature,
        dragMoveLocation: opts.startPos || null,
        dragMoving: false,
        canDragMove: false,
        selectedCoordPaths: opts.coordPath ? [opts.coordPath] : [],
        maxVertexByPolygon
    };
    this.setSelectedCoordinates(this.pathsToCoordinates(featureId, state.selectedCoordPaths));
    this.setSelected(featureId);
    MapboxDraw.lib.doubleClickZoom.disable(this);
    this.setActionableState({
        trash: true
    });
    return state;
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const validGeomDrawPolygonMode = MapboxDraw.modes.draw_polygon;
const reader = new jsts.io.GeoJSONReader();
validGeomDrawPolygonMode.fireInvalidGeom = function (feature) {
    this.map.fire('draw.invalidGeometry', {
        action: 'error',
        features: [feature]
    });
};
validGeomDrawPolygonMode.fireOnClick = function () {
    this.map.fire('draw.onClick', 'point drawn');
};
validGeomDrawPolygonMode.fireOnStop = function () {
    this.map.fire('draw.onStop', 'draw end');
};
validGeomDrawPolygonMode.clickOnVertex = function (state) {
    return this.changeMode(MapboxDraw.constants.modes.STATIC, {});
};
validGeomDrawPolygonMode.onTap = validGeomDrawPolygonMode.onClick = function (state, e) {
    if (MapboxDraw.lib.CommonSelectors.isVertex(e)) {
        return this.clickOnVertex(state, e);
    }
    else {
        this.fireOnClick();
        return this.clickAnywhere(state, e);
    }
};
validGeomDrawPolygonMode.onStop = function (state) {
    this.fireOnStop();
    this.updateUIClasses({ mouse: MapboxDraw.constants.cursors.NONE });
    MapboxDraw.lib.doubleClickZoom.enable(this);
    this.activateUIButton();
    // check to see if we've deleted this feature
    if (this.getFeature(state.polygon.id) === undefined) {
        return;
    }
    // remove last added coordinate
    state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);
    if (state.polygon.isValid()) {
        const featureCoords = [...state.polygon.coordinates[0]];
        if (featureCoords[0][0] !== featureCoords[featureCoords.length - 1][0] ||
            featureCoords[0][1] !== featureCoords[featureCoords.length - 1][1]) {
            featureCoords.push(featureCoords[0]);
        }
        const currentFeature = {
            'type': 'Feature',
            'geometry': {
                'type': 'Polygon',
                'coordinates': [featureCoords]
            }
        };
        const g = reader.read(currentFeature);
        if (!g.geometry.isValid()) {
            this.fireInvalidGeom(state.polygon);
            this.deleteFeature([state.polygon.id], { silent: true });
        }
        else {
            this.map.fire(MapboxDraw.constants.events.CREATE, {
                features: [state.polygon.toGeoJSON()]
            });
        }
    }
    else {
        this.deleteFeature([state.polygon.id], { silent: true });
        this.changeMode(MapboxDraw.constants.modes.STATIC, {}, { silent: true });
    }
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const circleMode = { ...MapboxDraw.modes.draw_polygon };
const DEFAULT_RADIUS_IN_KM = 2;
circleMode.onSetup = function (opts) {
    const polygon = this.newFeature({
        type: MapboxDraw.constants.geojsonTypes.FEATURE,
        properties: {
            isFixedRadius: opts.isFixedRadius !== undefined ? opts.isFixedRadius : false,
            isCircle: true,
            center: opts.center !== undefined ? opts.center : []
        },
        geometry: {
            type: MapboxDraw.constants.geojsonTypes.POLYGON,
            coordinates: [[]]
        }
    });
    this.addFeature(polygon);
    this.clearSelectedFeatures();
    MapboxDraw.lib.doubleClickZoom.disable(this);
    this.updateUIClasses({ mouse: MapboxDraw.constants.cursors.ADD });
    this.activateUIButton(MapboxDraw.constants.types.POLYGON);
    this.setActionableState({
        trash: true
    });
    return {
        initialRadiusInKm: opts.initialRadiusInKm || DEFAULT_RADIUS_IN_KM,
        steps: opts.steps || 64,
        units: opts.units || 'kilometers',
        polygon,
        currentVertexPosition: 0
    };
};
circleMode.clickAnywhere = function (state, e) {
    if (state.currentVertexPosition === 0) {
        state.currentVertexPosition++;
        const center = [e.lngLat.lng, e.lngLat.lat];
        const options = { steps: state.steps, units: state.units };
        const circleFeature = circle(center, state.initialRadiusInKm, options);
        state.polygon.incomingCoords(circleFeature.geometry.coordinates);
        state.polygon.properties.center = center;
        state.polygon.properties.radiusInKm = state.initialRadiusInKm;
    }
    return this.changeMode(MapboxDraw.constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function createDrawVertex(parentId, coordinates, path, selected) {
    return {
        type: 'Feature',
        properties: {
            meta: 'vertex',
            parent: parentId,
            coord_path: path,
            active: selected ? 'true' : 'false',
        },
        geometry: {
            type: 'Point',
            coordinates,
        },
    };
}
function displayFeatures(state, geojson, display) {
    const isActiveLine = geojson.properties.id === state.line.id;
    geojson.properties.active = isActiveLine ? 'true' : 'false';
    if (!isActiveLine) {
        if (!geojson.geometry.coordinates[0][0]) {
            return null;
        }
        return display(geojson);
    }
    // Only render the line if it has at least one real coordinate
    if (geojson.geometry.coordinates.length < 2) {
        return null;
    }
    geojson.properties.meta = 'feature';
    // displays center vertex as a point feature
    display(createDrawVertex(state.line.id, geojson.geometry.coordinates[state.direction === 'forward'
        ? geojson.geometry.coordinates.length - 2
        : 1], `${state.direction === 'forward'
        ? geojson.geometry.coordinates.length - 2
        : 1}`, false));
    // displays the line as it is drawn
    display(geojson);
}
function updateCoordinates(state, e) {
    if (state.direction === 'forward') {
        state.currentVertexPosition += 1; // eslint-disable-line
        state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
    }
    else {
        state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const radiusCircleMode = { ...MapboxDraw.modes.draw_line_string };
radiusCircleMode.fireOnStop = function () {
    this.map.fire('draw.onStop', 'draw end');
};
function getDisplayMeasurements(feature) {
    // should log both metric and standard display strings for the current drawn feature
    // metric calculation
    const drawnLength = length(feature) * 1000; // meters
    let metricUnits = 'm';
    let metricFormat = '0,0';
    let metricMeasurement;
    let standardUnits = 'feet';
    let standardFormat = '0,0';
    let standardMeasurement;
    metricMeasurement = drawnLength;
    if (drawnLength >= 1000) {
        // if over 1000 meters, upgrade metric
        metricMeasurement = drawnLength / 1000;
        metricUnits = 'km';
        metricFormat = '0.00';
    }
    standardMeasurement = drawnLength * 3.28084;
    if (standardMeasurement >= 5280) {
        // if over 5280 feet, upgrade standard
        standardMeasurement /= 5280;
        standardUnits = 'mi';
        standardFormat = '0.00';
    }
    const displayMeasurements = {
        metric: `${numeral(metricMeasurement).format(metricFormat)} ${metricUnits}`,
        standard: `${numeral(standardMeasurement).format(standardFormat)} ${standardUnits}`,
    };
    return displayMeasurements;
}
const doubleClickZoom$1 = {
    enable: (ctx) => {
        setTimeout(() => {
            // First check we've got a map and some context.
            if (!ctx.map?.doubleClickZoom ||
                !ctx._ctx?.store?.getInitialConfigValue) {
                return;
            }
            // Now check initial state wasn't false (we leave it disabled if so)
            if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) {
                return;
            }
            ctx.map.doubleClickZoom.enable();
        }, 0);
    },
};
radiusCircleMode.onSetup = function (opts) {
    const props = MapboxDraw.modes.draw_line_string.onSetup.call(this, opts);
    const polygon = this.newFeature({
        type: MapboxDraw.constants.geojsonTypes.FEATURE,
        properties: {
            meta: 'radius',
            isFixedRadius: opts.isFixedRadius !== undefined ? opts.isFixedRadius : false,
            isCircle: true,
            center: opts.center !== undefined ? opts.center : []
        },
        geometry: {
            type: MapboxDraw.constants.geojsonTypes.POLYGON,
            coordinates: [[]],
        },
    });
    this.addFeature(polygon);
    return {
        ...props,
        circle: polygon,
        steps: opts.steps || 64,
        units: opts.units || 'kilometers'
    };
};
radiusCircleMode.clickAnywhere = function (state, e) {
    // this ends the drawing after the user creates a second point, triggering this.onStop
    if (state.currentVertexPosition === 1) {
        state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);
        return this.changeMode('simple_select', { featureIds: [state.line.id] });
    }
    this.updateUIClasses({ mouse: MapboxDraw.constants.cursors.ADD });
    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
    updateCoordinates(state, e);
    return null;
};
radiusCircleMode.onMouseMove = function (state, e) {
    MapboxDraw.modes.draw_line_string.onMouseMove.call(this, state, e);
    const geojson = state.line.toGeoJSON();
    const center = geojson.geometry.coordinates[0];
    const radiusInKm = length(geojson, { units: 'kilometers' });
    const options = { steps: state.steps, units: state.units };
    const circleFeature = circle(center, radiusInKm, options);
    circleFeature.properties.parent = state.line.id;
    circleFeature.properties.meta = 'radius';
    state.circle.setCoordinates(circleFeature.geometry.coordinates);
};
// creates the final geojson point feature with a radius property
// triggers draw.create
radiusCircleMode.onStop = function (state) {
    doubleClickZoom$1.enable(this);
    this.activateUIButton();
    // check to see if we've deleted this feature
    if (this.getFeature(state.line.id) === undefined) {
        return;
    }
    // remove last added coordinate
    state.line.removeCoordinate('0');
    if (state.line.isValid()) {
        this.deleteFeature([state.line.id], { silent: true });
        this.map.fire('draw.create', {
            features: [state.circle.toGeoJSON()],
        });
    }
    else {
        this.deleteFeature([state.line.id], { silent: true });
        this.changeMode('simple_select', {}, { silent: true });
    }
    this.fireOnStop();
};
radiusCircleMode.toDisplayFeatures = function (state, geojson, display) {
    displayFeatures(state, geojson, display);
    if (geojson.geometry.coordinates.length >= 2 && geojson.geometry.coordinates[1]) {
        const displayMeasurements = getDisplayMeasurements(geojson);
        // create custom feature for the current pointer position
        const currentVertex = {
            type: 'Feature',
            properties: {
                meta: 'currentPosition',
                radiusMetric: displayMeasurements.metric,
                radiusStandard: displayMeasurements.standard,
                parent: state.line.id,
            },
            geometry: {
                type: 'Point',
                coordinates: geojson.geometry.coordinates[1],
            },
        };
        display(currentVertex);
    }
    return null;
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function createSupplementaryPointsForCircle(geojson) {
    const { properties, geometry } = geojson;
    if (!properties.user_isCircle) {
        return null;
    }
    const supplementaryPoints = [];
    const vertices = geometry.coordinates[0].slice(0, -1);
    for (let index = 0; index < vertices.length; index += Math.round((vertices.length / 4))) {
        supplementaryPoints.push(MapboxDraw.lib.createVertex(properties.id, vertices[index], `0.${index}`, false));
    }
    return supplementaryPoints;
}
const dragPan = {
    enable(ctx) {
        setTimeout(() => {
            // First check we've got a map and some context.
            if (!ctx.map || !ctx.map.dragPan || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) {
                return;
            }
            // Now check initial state wasn't false (we leave it disabled if so)
            if (!ctx._ctx.store.getInitialConfigValue('dragPan')) {
                return;
            }
            ctx.map.dragPan.enable();
        }, 0);
    },
    disable(ctx) {
        setTimeout(() => {
            if (!ctx.map || !ctx.map.doubleClickZoom) {
                return;
            }
            // Always disable here, as it's necessary in some cases.
            ctx.map.dragPan.disable();
        }, 0);
    }
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const directModeOverride = MapboxDraw.modes.direct_select;
directModeOverride.dragFeature = function (state, e, delta) {
    MapboxDraw.lib.moveFeatures(this.getSelected(), delta);
    this.getSelected()
        .filter(feature => feature.properties.isCircle)
        .map(circle => circle.properties.center)
        .forEach(center => {
        center[0] += delta.lng;
        center[1] += delta.lat;
    });
    state.dragMoveLocation = e.lngLat;
};
directModeOverride.dragVertex = function (state, e, delta) {
    if (state.feature.properties.isCircle && state.feature.properties.isFixedRadius) {
        MapboxDraw.lib.moveFeatures(this.getSelected(), delta);
        this.getSelected()
            .filter(feature => feature.properties.isCircle)
            .map(circle => circle.properties.center)
            .forEach(center => {
            center[0] += delta.lng;
            center[1] += delta.lat;
        });
        state.dragMoveLocation = e.lngLat;
    }
    else {
        if (state.feature.properties.isCircle) {
            const center = state.feature.properties.center;
            const movedVertex = [e.lngLat.lng, e.lngLat.lat];
            const radius = distance(point(center), point(movedVertex), { units: 'kilometers' });
            const circleFeature = circle(center, radius);
            state.feature.incomingCoords(circleFeature.geometry.coordinates);
            state.feature.properties.radiusInKm = radius;
        }
        else {
            const selectedCoords = state.selectedCoordPaths.map(coord_path => state.feature.getCoordinate(coord_path));
            const selectedCoordPoints = selectedCoords.map(coords => ({
                type: MapboxDraw.constants.geojsonTypes.FEATURE,
                properties: {},
                geometry: {
                    type: MapboxDraw.constants.geojsonTypes.POINT,
                    coordinates: coords
                }
            }));
            const constrainedDelta = MapboxDraw.lib.constrainFeatureMovement(selectedCoordPoints, delta);
            for (let i = 0; i < selectedCoords.length; i++) {
                const coord = selectedCoords[i];
                state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);
            }
        }
    }
};
directModeOverride.toDisplayFeatures = function (state, geojson, push) {
    if (state.featureId === geojson.properties.id) {
        geojson.properties.active = MapboxDraw.constants.activeStates.ACTIVE;
        push(geojson);
        const supplementaryPoints = geojson.properties.user_isCircle ? createSupplementaryPointsForCircle(geojson)
            : MapboxDraw.lib.createSupplementaryPoints(geojson, {
                map: this.map,
                midpoints: true,
                selectedPaths: state.selectedCoordPaths
            });
        supplementaryPoints.forEach(push);
    }
    else {
        geojson.properties.active = MapboxDraw.constants.activeStates.INACTIVE;
        push(geojson);
    }
    this.fireActionable(state);
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
// Inspired by https://github.com/thegisdev/mapbox-gl-draw-rectangle-mode/tree/master
const rectangleMode = {};
rectangleMode.onSetup = function () {
    const rectangle = this.newFeature({
        type: MapboxDraw.constants.geojsonTypes.FEATURE,
        properties: {
            source: 'bbox'
        },
        geometry: {
            type: MapboxDraw.constants.geojsonTypes.POLYGON,
            coordinates: [[]]
        }
    });
    this.addFeature(rectangle);
    this.clearSelectedFeatures();
    MapboxDraw.lib.doubleClickZoom.disable(this);
    this.updateUIClasses({ mouse: MapboxDraw.constants.cursors.ADD });
    this.activateUIButton(MapboxDraw.constants.types.POLYGON);
    this.setActionableState({
        trash: true
    });
    return {
        rectangle,
        currentVertexPosition: 0,
        start: []
    };
};
rectangleMode.onClick = function (state, e) {
    if (state.currentVertexPosition === 1
        && state.start[0] !== e.lngLat.lng
        && state.start[1] !== e.lngLat.lat) {
        this.updateUIClasses({ mouse: MapboxDraw.constants.cursors.NONE });
        return this.changeMode('simple_select', { featuresId: state.rectangle.id });
    }
    state.start = [e.lngLat.lng, e.lngLat.lat];
    state.currentVertexPosition++;
};
rectangleMode.onMouseMove = function (state, e) {
    if (state.start?.length > 0) {
        const start = state.start;
        // The bbox needs to be oriented in a certain way to match the parsing in the contributors
        const west = Math.min(start[0], e.lngLat.lng);
        const north = Math.max(start[1], e.lngLat.lat);
        const east = Math.max(start[0], e.lngLat.lng);
        const south = Math.min(start[1], e.lngLat.lat);
        state.rectangle.updateCoordinate('0.0', east, south);
        state.rectangle.updateCoordinate('0.1', east, north);
        state.rectangle.updateCoordinate('0.2', west, north);
        state.rectangle.updateCoordinate('0.3', west, south);
    }
};
rectangleMode.toDisplayFeatures = function (state, geojson, display) {
    const isActivePolygon = geojson.properties.id === state.rectangle.id;
    geojson.properties.active = isActivePolygon ? 'true' : 'false';
    if (!isActivePolygon) {
        return display(geojson);
    }
    // Only render the rectangular polygon if it has the starting point
    if (state.start.length === 0) {
        return;
    }
    return display(geojson);
};
rectangleMode.fireOnStop = function () {
    this.map.fire('draw.onStop', 'draw end');
};
rectangleMode.onStop = function (state) {
    MapboxDraw.lib.doubleClickZoom.enable(this);
    this.activateUIButton();
    // check to see if we've deleted this feature
    if (this.getFeature(state.rectangle.id) === undefined) {
        return;
    }
    // remove last added coordinate
    state.rectangle.removeCoordinate('0.4');
    if (state.rectangle.isValid()) {
        this.map.fire('draw.create', {
            features: [state.rectangle.toGeoJSON()],
        });
    }
    else {
        this.deleteFeature([state.rectangle.id], { silent: true });
        this.changeMode('simple_select', { featureIds: [state.rectangle.id] }, { silent: true });
    }
    this.fireOnStop();
};
rectangleMode.onTrash = function (state) {
    this.deleteFeature([state.rectangle.id], { silent: true });
    this.changeMode('simple_select');
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const simpleSelectModeOverride = MapboxDraw.modes.simple_select;
simpleSelectModeOverride.dragMove = function (state, e) {
    // Dragging when drag move is enabled
    state.dragMoving = true;
    e.originalEvent.stopPropagation();
    const delta = {
        lng: e.lngLat.lng - state.dragMoveLocation.lng,
        lat: e.lngLat.lat - state.dragMoveLocation.lat
    };
    MapboxDraw.lib.moveFeatures(this.getSelected(), delta);
    this.getSelected()
        .filter(feature => feature.properties.isCircle)
        .map(circle => circle.properties.center)
        .forEach(center => {
        center[0] += delta.lng;
        center[1] += delta.lat;
    });
    state.dragMoveLocation = e.lngLat;
};
simpleSelectModeOverride.toDisplayFeatures = function (state, geojson, display) {
    geojson.properties.active = (this.isSelected(geojson.properties.id)) ?
        MapboxDraw.constants.activeStates.ACTIVE : MapboxDraw.constants.activeStates.INACTIVE;
    display(geojson);
    this.fireActionable();
    if (geojson.properties.active !== MapboxDraw.constants.activeStates.ACTIVE ||
        geojson.geometry.type === MapboxDraw.constants.geojsonTypes.POINT) {
        return;
    }
    const supplementaryPoints = geojson.properties.user_isCircle ?
        createSupplementaryPointsForCircle(geojson) : MapboxDraw.lib.createSupplementaryPoints(geojson);
    supplementaryPoints.forEach(display);
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const stripMode = { ...MapboxDraw.modes.draw_line_string };
function rotateStrip(start, end, state, currentMaxBearing = 0, options = {}) {
    const properties = options.properties ? options.properties : {};
    const startPoint = point(start);
    const endPoint = point(end);
    const bearing = rhumbBearing(startPoint, endPoint);
    const rotatedPoly = transformRotate(state.strip, bearing - currentMaxBearing, { pivot: start });
    state.currentMaxBearing = bearing;
    return polygon(rotatedPoly.coordinates, properties);
}
function buildStrip(start, end, halfSwath, options = {}) {
    const properties = options.properties ? options.properties : {};
    // main
    const coordinates = [];
    const startPoint = point(start);
    const endPoint = point(end);
    // build polygone
    const bearing = rhumbBearing(startPoint, endPoint);
    const corner1 = rhumbDestination(startPoint, halfSwath, bearing - 90);
    const corner2 = rhumbDestination(startPoint, halfSwath, bearing + 90);
    const corner3 = rhumbDestination(endPoint, halfSwath, bearing + 90);
    const corner4 = rhumbDestination(endPoint, halfSwath, bearing - 90);
    coordinates.push(corner1.geometry.coordinates);
    coordinates.push(corner2.geometry.coordinates);
    coordinates.push(corner3.geometry.coordinates);
    coordinates.push(corner4.geometry.coordinates);
    coordinates.push(coordinates[0]);
    properties.start = start;
    properties.end = end;
    return polygon([coordinates], properties);
}
function computeStripProperties(coordinates) {
    const properties = new Map();
    // Compute bearing
    const bearingAngle = rhumbBearing(point(coordinates[0]), point(coordinates[3]));
    properties['bearingAngle'] = bearingToAzimuth(bearingAngle);
    // Compute origin
    properties['origin'] = midpoint(point(coordinates[0]), point(coordinates[1])).geometry.coordinates;
    // Compute length
    properties['length'] = distance(point(coordinates[1]), point(coordinates[2]), { units: 'kilometers' });
    return properties;
}
const doubleClickZoom = {
    enable: (ctx) => {
        setTimeout(() => {
            // First check we've got a map and some context.
            if (!ctx.map?.doubleClickZoom ||
                !ctx._ctx?.store?.getInitialConfigValue) {
                return;
            }
            // Now check initial state wasn't false (we leave it disabled if so)
            if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) {
                return;
            }
            ctx.map.doubleClickZoom.enable();
        }, 0);
    },
};
stripMode.onSetup = function (opts) {
    const halfSwath = opts.halfSwath;
    const maxLength = opts.maxLength;
    if (!halfSwath) {
        throw new Error('You must provide a valid halfSwath to enter strip_direct mode');
    }
    if (!maxLength) {
        throw new Error('You must provide a valid maxLength to enter strip_direct mode');
    }
    const props = MapboxDraw.modes.draw_line_string.onSetup.call(this, opts);
    const polygon = this.newFeature({
        type: MapboxDraw.constants.geojsonTypes.FEATURE,
        properties: {
            meta: 'strip',
            isCircle: false,
            isStrip: true,
            halfSwath: opts.halfSwath,
            maxLength: opts.maxLength,
            bearingAngle: 0
        },
        geometry: {
            type: MapboxDraw.constants.geojsonTypes.POLYGON,
            coordinates: [[]],
        },
    });
    this.addFeature(polygon);
    return {
        ...props,
        strip: polygon,
        halfSwath,
        maxLength,
        meta: 'strip'
    };
};
stripMode.fireOnStop = function () {
    this.map.fire('draw.onStop', 'draw end');
};
stripMode.clickAnywhere = function (state, e) {
    // this ends the drawing after the user creates a second point, triggering this.onStop
    if (state.currentVertexPosition === 1) {
        state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);
        return this.changeMode('simple_select', {
            featureIds: [state.line.id]
        });
    }
    this.updateUIClasses({ mouse: MapboxDraw.constants.cursors.ADD });
    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
    updateCoordinates(state, e);
    return null;
};
stripMode.onMouseMove = function (state, e) {
    if (state.currentVertexPosition === 1) {
        MapboxDraw.modes.draw_line_string.onMouseMove.call(this, state, e);
        const geojson = state.line.toGeoJSON();
        const stripLength = length(geojson, { units: 'kilometers' });
        const start = geojson.geometry.coordinates[0];
        const end = [e.lngLat.lng, e.lngLat.lat];
        const startPoint = point(start);
        const endPoint = point(end);
        const bearing = rhumbBearing(startPoint, endPoint);
        if (stripLength > state.maxLength && state.isStripDrew === undefined) {
            const translateDistance = -(stripLength - state.maxLength);
            const translatedPoint = transformTranslate(endPoint, translateDistance, bearing);
            const stripFeature = buildStrip(start, translatedPoint.geometry.coordinates, state.halfSwath);
            stripFeature.properties.parent = state.line.id;
            stripFeature.properties.meta = 'strip';
            state.strip.setCoordinates(stripFeature.geometry.coordinates);
            state.currentMaxBearing = bearing;
            state.isStripDrew = true;
            Object.assign(state.strip.properties, computeStripProperties(stripFeature.geometry.coordinates[0]));
        }
        else if (stripLength <= state.maxLength || state.isStripDrew === undefined) {
            const stripFeature = buildStrip(start, end, state.halfSwath);
            stripFeature.properties.parent = state.line.id;
            stripFeature.properties.meta = 'strip';
            state.strip.setCoordinates(stripFeature.geometry.coordinates);
            state.currentMaxBearing = bearing;
            state.isStripDrew = true;
            Object.assign(state.strip.properties, computeStripProperties(stripFeature.geometry.coordinates[0]));
        }
        else if (state.isStripDrew && stripLength > state.maxLength) {
            const stripFeature = rotateStrip(start, end, state, state.currentMaxBearing);
            stripFeature.properties.parent = state.line.id;
            stripFeature.properties.meta = 'strip';
            state.strip.setCoordinates(stripFeature.geometry.coordinates);
            Object.assign(state.strip.properties, computeStripProperties(stripFeature.geometry.coordinates[0]));
        }
    }
};
// creates the final geojson point feature with a radius property
// triggers draw.create
stripMode.onStop = function (state) {
    doubleClickZoom.enable(this);
    this.activateUIButton();
    // check to see if we've deleted this feature
    if (this.getFeature(state.line.id) === undefined) {
        return;
    }
    // remove last added coordinate
    state.line.removeCoordinate('0');
    if (state.line.isValid()) {
        this.deleteFeature([state.line.id], { silent: true });
        this.map.fire('draw.create', {
            features: [state.strip.toGeoJSON()],
        });
    }
    else {
        this.deleteFeature([state.line.id], { silent: true });
        this.changeMode('simple_select', {}, { silent: true });
    }
    this.fireOnStop();
};
stripMode.toDisplayFeatures = function (state, geojson, display) {
    displayFeatures(state, geojson, display);
    if (geojson.geometry.coordinates.length >= 2 && geojson.geometry.coordinates[1]) {
        // create custom feature for the current pointer position
        const currentVertex = {
            type: 'Feature',
            properties: {
                meta: 'currentPosition',
                parent: state.line.id,
            },
            geometry: {
                type: 'Point',
                coordinates: geojson.geometry.coordinates[1],
            },
        };
        display(currentVertex);
    }
    return null;
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const stripDirectSelectMode = {};
stripDirectSelectMode.onSetup = function (opts) {
    const featureId = opts.featureId;
    const halfSwath = opts.halfSwath;
    const maxLength = opts.maxLength;
    const feature = this.getFeature(featureId);
    if (!featureId) {
        throw new Error('You must provide a valid featureId to enter strip_direct mode');
    }
    if (!halfSwath) {
        throw new Error('You must provide a valid halfSwath to enter strip_direct mode');
    }
    if (!maxLength) {
        throw new Error('You must provide a valid maxLength to enter strip_direct mode');
    }
    if (feature.type !== MapboxDraw.constants.geojsonTypes.POLYGON) {
        throw new TypeError('strip_direct mode can only handle polygons');
    }
    if (feature.coordinates === undefined
        || feature.coordinates.length !== 1
        || feature.coordinates[0].length <= 2) {
        throw new TypeError('strip_direct mode can only handle polygons');
    }
    const state = {
        featureId,
        feature,
        halfSwath,
        maxLength,
        resizePointRadius: opts.resizePointRadius !== undefined ? opts.resizePointRadius : 1,
        rotationPointRadius: opts.rotationPointRadius !== undefined ? opts.rotationPointRadius : 1.0,
        canSelectFeatures: opts.canSelectFeatures !== undefined ? opts.canSelectFeatures : true,
        dragMoveLocation: opts.startPos || null,
        dragMoving: false,
        canDragMove: false,
        selectedCoordPaths: opts.coordPath ? [opts.coordPath] : []
    };
    this.setSelectedCoordinates(this.pathsToCoordinates(featureId, state.selectedCoordPaths));
    this.setSelected(featureId);
    MapboxDraw.lib.doubleClickZoom.disable(this);
    this.setActionableState({
        combineFeatures: false,
        uncombineFeatures: false,
        trash: true
    });
    this.addFeature(feature);
    return state;
};
stripDirectSelectMode.fireOnStop = function () {
    this.map.fire('draw.onStop', 'draw end');
};
stripDirectSelectMode.toDisplayFeatures = function (state, geojson, push) {
    if (state.featureId === geojson.properties.id) {
        geojson.properties.active = MapboxDraw.constants.activeStates.ACTIVE;
        push(geojson);
        const suppPoints = MapboxDraw.lib.createSupplementaryPoints(geojson, {
            map: this.map,
            midpoints: false,
            selectedPaths: state.selectedCoordPaths
        });
        const actionsPoints = this.createActionPoints(state, geojson, suppPoints);
        actionsPoints.forEach(push);
    }
    else {
        geojson.properties.active = MapboxDraw.constants.activeStates.INACTIVE;
        push(geojson);
    }
    this.setActionableState({
        combineFeatures: false,
        uncombineFeatures: false,
        trash: true
    });
};
stripDirectSelectMode.onStop = function () {
    MapboxDraw.lib.doubleClickZoom.enable(this);
    this.clearSelectedCoordinates();
    this.fireOnStop();
};
stripDirectSelectMode.pathsToCoordinates = function (featureId, paths) {
    return paths.map(coord_path => ({ feature_id: featureId, coord_path }));
};
stripDirectSelectMode._createActionPoint = function (actionWidgets, featureId, v1, v2, rotCenter, radiusScale, type) {
    const cR0 = midpoint(v1, v2).geometry.coordinates;
    const heading = rhumbBearing(rotCenter, cR0);
    const distance0 = distance(rotCenter, cR0);
    const distance1 = radiusScale * distance0;
    const cR1 = rhumbDestination(rotCenter, distance1, heading, {}).geometry.coordinates;
    actionWidgets.push({
        type: MapboxDraw.constants.geojsonTypes.FEATURE,
        properties: {
            meta: MapboxDraw.constants.meta.MIDPOINT,
            actionType: type,
            parent: featureId,
            lng: cR1[0],
            lat: cR1[1],
            coord_path: v1.properties.coord_path,
            coord_path_coords: cR0,
            heading: heading,
        },
        geometry: {
            type: MapboxDraw.constants.geojsonTypes.POINT,
            coordinates: cR1
        }
    });
};
stripDirectSelectMode.createActionPoints = function (state, geojson, suppPoints) {
    const { type, coordinates } = geojson.geometry;
    const featureId = geojson.properties && geojson.properties.id;
    const actionWidgets = [];
    if (type !== MapboxDraw.constants.geojsonTypes.POLYGON) {
        return;
    }
    const corners = suppPoints.slice(0);
    corners[corners.length] = corners[0];
    let v1 = null;
    const rotCenter = this.computeCenter(state, geojson);
    corners.forEach((v2) => {
        if (v1 != null && (v1.properties.coord_path === '0.2')) {
            this._createActionPoint(actionWidgets, featureId, v1, v2, rotCenter, state.rotationPointRadius, 'resize');
        }
        if (v1 != null && (v1.properties.coord_path === '0.0')) {
            this._createActionPoint(actionWidgets, featureId, v1, v2, rotCenter, state.rotationPointRadius, 'origin');
        }
        if (v1 != null && (v1.properties.coord_path === '0.3')) {
            this._createActionPoint(actionWidgets, featureId, v1, v2, rotCenter, state.rotationPointRadius, 'rotation');
        }
        v1 = v2;
    });
    state.actionWidgets = actionWidgets;
    return actionWidgets;
};
stripDirectSelectMode.startDragging = function (state, e) {
    this.map.dragPan.disable();
    state.canDragMove = true;
    state.dragMoveLocation = e.lngLat;
};
stripDirectSelectMode.stopDragging = function (state) {
    this.map.dragPan.enable();
    state.dragMoving = false;
    state.canDragMove = false;
    state.dragMoveLocation = null;
};
const isMidPoint = MapboxDraw.lib.CommonSelectors.isOfMetaType(MapboxDraw.constants.meta.MIDPOINT);
stripDirectSelectMode.onTouchStart = stripDirectSelectMode.onMouseDown = function (state, e) {
    if (isMidPoint(e)) {
        return this.onActivatePoint(state, e);
    }
    if (MapboxDraw.lib.CommonSelectors.isActiveFeature(e)) {
        return this.onFeature(state, e);
    }
};
const stripDirectMode = {
    Resize: 1,
    Rotate: 2
};
stripDirectSelectMode.onActivatePoint = function (state, e) {
    this.computeAxes(state, state.feature.toGeoJSON());
    this.startDragging(state, e);
    const about = e.featureTarget.properties;
    state.selectedCoordPaths = [about.coord_path];
    if (e.featureTarget.properties.actionType === 'rotation') {
        state.stripDirectMode = stripDirectMode.Rotate;
    }
    else if (e.featureTarget.properties.actionType === 'resize') {
        state.stripDirectMode = stripDirectMode.Resize;
    }
};
stripDirectSelectMode.onFeature = function (state, e) {
    state.selectedCoordPaths = [];
    this.startDragging(state, e);
};
stripDirectSelectMode.coordinateIndex = function (coordPaths) {
    if (coordPaths.length >= 1) {
        const parts = coordPaths[0].split('.');
        return parseInt(parts[parts.length - 1], 10);
    }
    else {
        return 0;
    }
};
stripDirectSelectMode.computeCenter = function (state, polygon) {
    const center0 = center(polygon);
    return center0;
};
stripDirectSelectMode.computeAxes = function (state, polygon) {
    const center = this.computeCenter(state, polygon);
    const corners = polygon.geometry.coordinates[0].slice(0);
    const n = corners.length - 1;
    const iHalf = Math.floor(n / 2);
    const rotateCenters = [];
    const headings = [];
    for (let i1 = 0; i1 < n; i1++) {
        let i0 = i1 - 1;
        if (i0 < 0) {
            i0 += n;
        }
        const c0 = corners[i0];
        const c1 = corners[i1];
        const rotPoint = midpoint(point(c0), point(c1));
        rotateCenters[i1] = center.geometry.coordinates;
        headings[i1] = rhumbBearing(center, rotPoint);
    }
    state.rotation = {
        feature0: polygon, // initial feature state
        centers: rotateCenters,
        headings: headings, // rotation start heading for each point
    };
};
stripDirectSelectMode.onDrag = function (state, e) {
    if (state.canDragMove !== true) {
        return;
    }
    state.dragMoving = true;
    e.originalEvent.stopPropagation();
    const delta = {
        lng: e.lngLat.lng - state.dragMoveLocation.lng,
        lat: e.lngLat.lat - state.dragMoveLocation.lat
    };
    if (state.selectedCoordPaths.length > 0 && state.stripDirectMode) {
        switch (state.stripDirectMode) {
            case stripDirectMode.Rotate:
                this.dragRotatePoint(state, e, delta);
                break;
            case stripDirectMode.Resize:
                this.dragResizePoint(state, e, delta);
                break;
        }
    }
    else {
        this.dragFeature(state, e, delta);
    }
    state.dragMoveLocation = e.lngLat;
};
stripDirectSelectMode.dragRotatePoint = function (state, e, delta) {
    if (state.rotation === undefined || state.rotation == null) {
        console.error('state.rotation required');
        return;
    }
    const m1 = point([e.lngLat.lng, e.lngLat.lat]);
    const n = state.rotation.centers.length;
    const cIdx = (this.coordinateIndex(state.selectedCoordPaths) + 1) % n;
    const cCenter = state.rotation.centers[cIdx];
    const cp = point(cCenter);
    const heading1 = rhumbBearing(cp, m1);
    const heading0 = state.rotation.headings[cIdx];
    const rotateAngle = heading1 - heading0; // in degrees
    const rotatedFeature = transformRotate(state.rotation.feature0, rotateAngle, {
        pivot: cp,
        mutate: false,
    });
    state.start = undefined;
    state.feature.incomingCoords(rotatedFeature.geometry.coordinates);
    Object.assign(state.feature.properties, computeStripProperties(state.feature.coordinates[0]));
    this.fireUpdate();
};
stripDirectSelectMode.dragResizePoint = function (state, e, delta) {
    const end = [e.lngLat.lng, e.lngLat.lat];
    let start;
    if (!state.selectedResizePaths) {
        state.selectedResizePaths = state.selectedCoordPaths[0];
    }
    if (!state.start || state.selectedResizePaths !== state.selectedCoordPaths[0]) {
        if (state.selectedCoordPaths[0] === '0.0') {
            start = state.actionWidgets.find(a => a.properties.coord_path === '0.2').properties.coord_path_coords;
        }
        else {
            start = state.actionWidgets.find(a => a.properties.coord_path === '0.0').properties.coord_path_coords;
        }
        state.start = start;
    }
    const dist = distance(point(state.start), point(end), { units: 'kilometers' });
    const newPolygon = buildStrip(state.start, end, state.halfSwath);
    if (dist <= state.maxLength) {
        state.feature.setCoordinates(newPolygon.geometry.coordinates);
        Object.assign(state.feature.properties, computeStripProperties(state.feature.coordinates[0]));
        this.fireUpdate();
    }
};
stripDirectSelectMode.dragFeature = function (state, e, delta) {
    MapboxDraw.lib.moveFeatures(this.getSelected(), delta);
    state.dragMoveLocation = e.lngLat;
    state.start = undefined;
    Object.assign(state.feature.properties, computeStripProperties(state.feature.coordinates[0]));
    this.fireUpdate();
};
stripDirectSelectMode.fireUpdate = function () {
    this.map.fire(MapboxDraw.constants.events.UPDATE, {
        action: MapboxDraw.constants.updateActions.CHANGE_COORDINATES,
        features: this.getSelected().map(f => f.toGeoJSON())
    });
};
stripDirectSelectMode.onMouseOut = function (state) {
    // As soon as you mouse leaves the canvas, update the feature
    if (state.dragMoving) {
        this.fireUpdate();
    }
};
stripDirectSelectMode.onTouchEnd = stripDirectSelectMode.onMouseUp = function (state) {
    if (state.dragMoving) {
        this.fireUpdate();
    }
    this.stopDragging(state);
};
stripDirectSelectMode.clickActiveFeature = function (state) {
    state.selectedCoordPaths = [];
    this.clearSelectedCoordinates();
    state.feature.changed();
};
stripDirectSelectMode.onClick = function (state, e) {
    if (MapboxDraw.lib.CommonSelectors.noTarget(e)) {
        return this.clickNoTarget(state, e);
    }
    if (MapboxDraw.lib.CommonSelectors.isActiveFeature(e)) {
        return this.clickActiveFeature(state, e);
    }
    if (MapboxDraw.lib.CommonSelectors.isInactiveFeature(e)) {
        return this.clickInactive(state, e);
    }
    this.stopDragging(state);
};
stripDirectSelectMode.clickNoTarget = function (state, e) {
    if (state.canSelectFeatures) {
        this.changeMode(MapboxDraw.constants.modes.SIMPLE_SELECT);
    }
};
stripDirectSelectMode.clickInactive = function (state, e) {
    if (state.canSelectFeatures) {
        this.changeMode(MapboxDraw.constants.modes.SIMPLE_SELECT, {
            featureIds: [e.featureTarget.properties.id]
        });
    }
};
stripDirectSelectMode.onTrash = function () {
    this.deleteFeature(this.getSelectedIds());
};

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const roundLineLayout = {
    'line-cap': 'round',
    'line-join': 'round'
};
const staticModeVertex = ['all',
    ['==', 'meta', 'vertex'],
    ['==', '$type', 'Point'],
    ['!=', 'mode', 'static']
];
const deactivatedStaticModeFeature = ['all',
    ['==', 'active', 'false'],
    ['==', '$type', 'Point'],
    ['==', 'meta', 'feature'],
    ['!=', 'mode', 'static']
];
const deactivatedStaticPolygon = ['all',
    ['==', 'active', 'false'],
    ['==', '$type', 'Polygon'],
    ['!=', 'mode', 'static']
];
const activatedMidPoint = ['all',
    ['==', '$type', 'Point'],
    ['==', 'active', 'true'],
    ['!=', 'meta', 'midpoint']
];
const staticLineMidPoint = ['all', ['==', 'meta', 'midpoint'],
    ['==', 'actionType', 'rotation'],
    ['==', '$type', 'LineString'],
    ['!=', 'mode', 'static']
];
const staticPolygon = ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']];
const activePolygon = ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']];
const staticMidpoint = ['all',
    ['==', 'meta', 'midpoint'],
    ['==', 'actionType', 'resize'],
    ['==', '$type', 'Point'],
    ['!=', 'mode', 'static']
];
const dashedLinePaint = {
    'line-color': '#fbb03b',
    'line-dasharray': [0.2, 2],
    'line-width': 2
};
const linePaint = {
    'line-color': '#3bb2d0',
    'line-width': 2
};
const rotatePointFilter = ['all',
    ['==', 'meta', 'midpoint'],
    ['==', 'actionType', 'rotation'],
    ['==', '$type', 'Point'],
    ['!=', 'mode', 'static']
];
var defaultTheme = [
    {
        'id': 'gl-draw-polygon-fill-inactive',
        'type': 'fill',
        'filter': deactivatedStaticPolygon,
        'paint': {
            'fill-color': '#3bb2d0',
            'fill-outline-color': '#3bb2d0',
            'fill-opacity': 0.1
        }
    },
    {
        'id': 'gl-draw-polygon-fill-active',
        'type': 'fill',
        'filter': activePolygon,
        'paint': {
            'fill-color': '#fbb03b',
            'fill-outline-color': '#fbb03b',
            'fill-opacity': 0.1
        }
    },
    {
        'id': 'gl-draw-polygon-midpoint',
        'type': 'circle',
        'filter': ['all',
            ['==', '$type', 'Point'],
            ['==', 'meta', 'midpoint']],
        'paint': {
            'circle-radius': 3,
            'circle-color': '#fbb03b'
        }
    },
    {
        'id': 'gl-draw-polygon-stroke-inactive',
        'type': 'line',
        'filter': deactivatedStaticPolygon,
        'layout': roundLineLayout,
        'paint': linePaint
    },
    {
        'id': 'gl-draw-polygon-stroke-active',
        'type': 'line',
        'filter': activePolygon,
        'layout': roundLineLayout,
        'paint': dashedLinePaint
    },
    {
        'id': 'gl-draw-line-inactive',
        'type': 'line',
        'filter': ['all',
            ['==', 'active', 'false'],
            ['==', '$type', 'LineString'],
            ['!=', 'mode', 'static']
        ],
        'layout': roundLineLayout,
        'paint': linePaint
    },
    {
        'id': 'gl-draw-line-active',
        'type': 'line',
        'filter': ['all',
            ['==', '$type', 'LineString'],
            ['==', 'active', 'true']
        ],
        'layout': roundLineLayout,
        'paint': dashedLinePaint
    },
    {
        'id': 'gl-draw-polygon-and-line-vertex-stroke-inactive',
        'type': 'circle',
        'filter': staticModeVertex,
        'paint': {
            'circle-radius': 5,
            'circle-color': '#fff'
        }
    },
    {
        'id': 'gl-draw-polygon-and-line-vertex-inactive',
        'type': 'circle',
        'filter': staticModeVertex,
        'paint': {
            'circle-radius': 3,
            'circle-color': '#fbb03b'
        }
    },
    {
        'id': 'gl-draw-point-point-stroke-inactive',
        'type': 'circle',
        'filter': deactivatedStaticModeFeature,
        'paint': {
            'circle-radius': 5,
            'circle-opacity': 1,
            'circle-color': '#fff'
        }
    },
    {
        'id': 'gl-draw-point-inactive',
        'type': 'circle',
        'filter': deactivatedStaticModeFeature,
        'paint': {
            'circle-radius': 3,
            'circle-color': '#3bb2d0'
        }
    },
    {
        'id': 'gl-draw-point-stroke-active',
        'type': 'circle',
        'filter': activatedMidPoint,
        'paint': {
            'circle-radius': 7,
            'circle-color': '#fff'
        }
    },
    {
        'id': 'gl-draw-point-active',
        'type': 'circle',
        'filter': activatedMidPoint,
        'paint': {
            'circle-radius': 5,
            'circle-color': '#fbb03b'
        }
    },
    {
        'id': 'gl-draw-polygon-fill-static',
        'type': 'fill',
        'filter': staticPolygon,
        'paint': {
            'fill-color': '#3bb2d0',
            'fill-outline-color': '#3bb2d0',
            'fill-opacity': 0.1
        }
    },
    {
        'id': 'gl-draw-polygon-stroke-static',
        'type': 'line',
        'filter': staticPolygon,
        'layout': roundLineLayout,
        'paint': linePaint
    },
    {
        'id': 'gl-draw-line-static',
        'type': 'line',
        'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'LineString']],
        'layout': roundLineLayout,
        'paint': {
            'line-color': '#404040',
            'line-width': 2
        }
    },
    {
        'id': 'gl-draw-point-static',
        'type': 'circle',
        'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Point']],
        'paint': {
            'circle-radius': 5,
            'circle-color': '#404040'
        }
    },
    {
        'id': 'gl-draw-line-rotate-point',
        'type': 'line',
        'filter': staticLineMidPoint,
        'layout': roundLineLayout,
        'paint': dashedLinePaint
    },
    {
        'id': 'gl-draw-polygon-rotate-point-stroke',
        'type': 'circle',
        'filter': rotatePointFilter,
        'paint': {
            'circle-radius': 4,
            'circle-color': '#fff'
        }
    },
    {
        'id': 'gl-draw-polygon-rotate-point',
        'type': 'circle',
        'filter': rotatePointFilter,
        'paint': {
            'circle-radius': 2,
            'circle-color': '#fbb03b'
        }
    },
    {
        'id': 'gl-draw-polygon-rotate-point-icon',
        'type': 'symbol',
        'filter': rotatePointFilter,
        'layout': {
            'icon-image': 'rotate',
            'icon-allow-overlap': true,
            'icon-ignore-placement': true,
            'icon-rotation-alignment': 'map',
            'icon-rotate': ['get', 'heading']
        },
        'paint': {
            'icon-opacity': 1.0,
            'icon-opacity-transition': {
                'delay': 0,
                'duration': 0
            }
        }
    },
    {
        'id': 'gl-draw-line-resize-point',
        'type': 'line',
        'filter': staticLineMidPoint,
        'layout': roundLineLayout,
        'paint': dashedLinePaint
    },
    {
        'id': 'gl-draw-polygon-resize-point-stroke',
        'type': 'circle',
        'filter': staticMidpoint,
        'paint': {
            'circle-radius': 5,
            'circle-color': '#fff'
        }
    },
    {
        'id': 'gl-draw-polygon-resize-point',
        'type': 'circle',
        'filter': staticMidpoint,
        'paint': {
            'circle-radius': 6,
            'circle-color': '#fbb03b'
        }
    },
    {
        'id': 'gl-draw-polygon-resize-point-icon',
        'type': 'symbol',
        'filter': staticMidpoint,
        'layout': {
            'icon-image': 'resize',
            'icon-allow-overlap': true,
            'icon-ignore-placement': true,
            'icon-rotation-alignment': 'map',
            'icon-rotate': ['get', 'heading']
        },
        'paint': {
            'icon-opacity': 1.0,
            'icon-opacity-transition': {
                'delay': 0,
                'duration': 0
            }
        }
    }
];

var defaultTheme$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: defaultTheme
});

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
class ArlasDrawComponent {
    constructor(drawService, _snackBar, translate, mapFrameworkService, mapService) {
        this.drawService = drawService;
        this._snackBar = _snackBar;
        this.translate = translate;
        this.mapFrameworkService = mapFrameworkService;
        this.mapService = mapService;
        this.emptyData = {
            'type': 'FeatureCollection',
            'features': []
        };
        /**  @description Options object for draw tools : https://github.com/mapbox/mapbox-gl-draw/blob/master/docs/API.md#options */
        this.drawOption = {};
        /** @description Features drawn at component start */
        this.drawData = ({ ...this.emptyData });
        /** @description Whether the draw tools are activated. */
        this.drawButtonEnabled = false;
        /** @description Whether the drawing buffer is activated */
        /** If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL(). Default: false */
        this.preserveDrawingBuffer = false;
        /** @description Emits the geojson of an aoi added to the map. */
        this.onAoiChanged = new EventEmitter();
        /** @description Emits the the dimensions of the polygon/bbox that is being drawn. */
        this.onAoiEdit = new EventEmitter();
        /** Number of drawn vertices (incremented in draw mode). Reset to 0 when the drawing is finished. */
        this.nbPolygonVertices = 0;
        /** Number of clicks while drawing a geometry. */
        this.drawClickCounter = 0;
        /** List of drawn polygons centroid */
        this.polygonlabeldata = ({ ...this.emptyData });
        /** Drawn geometry's state when editing/updating. */
        this.savedEditFeature = null;
        /** Message shown to explain how to draw. */
        this.drawTooltipMessage = signal('');
        this.mouseMoveForDraw = (e) => {
            const x = e.clientX;
            const y = e.clientY;
            this.drawTooltipElement.style.top = (y + 20) + 'px';
            this.drawTooltipElement.style.left = (x + 20) + 'px';
        };
        this.drawService.editAoi$.pipe(takeUntilDestroyed()).subscribe(ae => this.onAoiEdit.emit(ae));
        this.drawService.drawBbox$.pipe(takeUntilDestroyed()).subscribe({
            next: (bboxDC) => {
                this.drawBbox(bboxDC.east, bboxDC.south, bboxDC.west, bboxDC.north);
            }
        });
    }
    /**
     * @description Stops the drawing mode by changing to static mode.
     */
    stopDrawingAtVerticeLimit() {
        if (this.nbPolygonVertices === this.drawPolygonVerticesLimit) {
            this.draw.changeMode('static');
            this.drawService.isDrawingPolygon = false;
            this.nbPolygonVertices = 0;
            this.drawClickCounter = 0;
        }
    }
    listenToDrawOnCreate() {
        this.draw.on('draw.create', (e) => {
            this.onAoiChanged.next({
                'type': 'FeatureCollection',
                'features': this.draw.getAllFeatures().filter(fc => this.drawService.isValidPolygon(fc) ||
                    this.drawService.isValidCircle(fc)).map(f => cleanCoords(f))
            });
        });
    }
    listenToDrawUpdate() {
        this.draw.on('draw.update', (e) => {
            if (e) {
                const features = e.features;
                if (features && features.length > 0) {
                    this.savedEditFeature = { ...features[0] };
                    this.savedEditFeature.coordinates = [[]];
                    features[0].geometry.coordinates[0].forEach(f => this.savedEditFeature.coordinates[0].push(f));
                }
            }
        });
    }
    listenToDrawDelete() {
        this.draw.on('draw.delete', (e) => {
            this.onAoiChanged.next({
                'type': 'FeatureCollection',
                'features': this.draw.getAllFeatures().filter(fc => this.drawService.isPolygon(fc) ||
                    this.drawService.isCircle(fc)).map(f => cleanCoords(f))
            });
        });
    }
    listenToDrawInvalidGeometry() {
        this.draw.onDrawInvalidGeometry((e) => {
            if (this.savedEditFeature) {
                const featureCoords = this.savedEditFeature.coordinates[0].slice();
                if (featureCoords[0][0] !== featureCoords[featureCoords.length - 1][0] ||
                    featureCoords[0][1] !== featureCoords[featureCoords.length - 1][1]) {
                    featureCoords.push(featureCoords[0]);
                }
                const currentFeature = {
                    id: '',
                    type: 'Feature',
                    geometry: {
                        'type': 'Polygon',
                        'coordinates': [featureCoords]
                    },
                    properties: {}
                };
                currentFeature.id = this.savedEditFeature.id;
                currentFeature.properties = this.savedEditFeature.properties;
                this.draw.add(currentFeature);
            }
            this.openInvalidGeometrySnackBar();
            this.mapFrameworkService.setMapCursor(this.map, '');
        });
    }
    listenToDrawSelectionChange() {
        this.draw.onDrawSelectionchange((e) => {
            if (e.features.length > 0) {
                this.drawService.isDrawSelected = true;
            }
            else {
                this.savedEditFeature = null;
                this.drawService.isDrawSelected = false;
                this.onAoiChanged.next({
                    'type': 'FeatureCollection',
                    'features': this.draw.getAllFeatures().filter(fc => this.drawService.isValidPolygon(fc) ||
                        this.drawService.isValidCircle(fc)).map(f => cleanCoords(f))
                });
                this.switchToStaticMode();
                this.mapFrameworkService.setMapCursor(this.map, '');
            }
        });
    }
    listenToDrawModeChange() {
        this.draw.onDrawModeChange((e) => {
            this.updateTooltipMessage();
            this.drawService.isDrawingPolygon = e.mode === this.draw.getMode('DRAW_POLYGON');
            this.drawService.isDrawingStrip = e.mode === this.draw.getMode('DRAW_STRIP') || e.mode === this.draw.getMode('DIRECT_STRIP');
            this.drawService.isDrawingCircle = e.mode === this.draw.getMode('DRAW_CIRCLE') || e.mode === this.draw.getMode('DRAW_RADIUS_CIRCLE');
            this.drawService.isDrawingBbox = e.mode === this.draw.getMode('DRAW_RECTANGLE');
            if (this.drawService.isDrawingPolygon || this.drawService.isDrawingCircle || this.drawService.isDrawingStrip || e.mode === 'static') {
                this.drawService.isInSimpleDrawMode = false;
            }
            if (e.mode === 'simple_select') {
                this.drawService.isInSimpleDrawMode = true;
            }
            else if (e.mode === 'static') {
                this.mapFrameworkService.setMapCursor(this.map, '');
            }
            else if (e.mode === 'direct_select') {
                const selectedFeatures = this.draw.getSelectedFeatures();
                const selectedIds = this.draw.getSelectedIds();
                if (selectedFeatures && selectedIds && selectedIds.length > 0) {
                    if (selectedFeatures[0].properties.source === 'bbox') {
                        this.draw.changeMode('simple_select', {
                            featureIds: [selectedIds[0]]
                        });
                        this.drawService.isInSimpleDrawMode = true;
                    }
                    else if (this.drawPolygonVerticesLimit && selectedFeatures[0].properties.meta !== 'strip') {
                        this.draw.changeMode('limit_vertex', {
                            featureId: selectedIds[0],
                            maxVertexByPolygon: this.drawPolygonVerticesLimit,
                            selectedCoordPaths: selectedFeatures[0].geometry.coordinates
                        });
                        this.drawService.isInSimpleDrawMode = false;
                    }
                    else if (this.drawPolygonVerticesLimit && selectedFeatures[0].properties.meta === 'strip') {
                        this.draw.changeMode('direct_strip', {
                            featureId: selectedIds[0],
                            maxLength: selectedFeatures[0].properties.maxLength,
                            halfSwath: selectedFeatures[0].properties.halfSwath,
                        });
                        this.drawService.isInSimpleDrawMode = false;
                    }
                }
                else {
                    this.drawService.isInSimpleDrawMode = false;
                    this.mapFrameworkService.setMapCursor(this.map, '');
                }
            }
        });
    }
    ngOnInit() {
        this.drawTooltipElement = document.getElementById('arlas-draw-tooltip');
        const drawStyles = defaultTheme;
        const drawOptions = {
            ...this.drawOption,
            ...{
                styles: drawStyles,
                modes: {
                    static: StaticMode,
                    limit_vertex: limitVertexDirectSelectMode,
                    draw_polygon: validGeomDrawPolygonMode,
                    draw_circle: circleMode,
                    draw_radius_circle: radiusCircleMode,
                    draw_strip: stripMode,
                    direct_strip: stripDirectSelectMode,
                    draw_rectangle: rectangleMode,
                    direct_select: directModeOverride,
                    simple_select: simpleSelectModeOverride
                },
                suppressAPIEvents: true
            }
        };
        this.draw = this.mapFrameworkService.createDraw(drawOptions, this.drawButtonEnabled, this.map);
        this.draw.setMode('DRAW_CIRCLE', 'draw_circle');
        this.draw.setMode('DRAW_RADIUS_CIRCLE', 'draw_radius_circle');
        this.draw.setMode('DRAW_STRIP', 'draw_strip');
        this.draw.setMode('STATIC', 'static');
        this.draw.setMode('DIRECT_STRIP', 'direct_strip');
        this.draw.setMode('DRAW_RECTANGLE', 'draw_rectangle');
        const drawControlConfig = {
            draw: { control: this.draw },
            addGeoBox: {
                enable: true,
                overrideEvent: {
                    event: 'click',
                    fn: this.addGeoBox
                }
            },
            removeAois: {
                enable: true,
                overrideEvent: { event: 'click', fn: this.removeAois }
            }
        };
        this.map.initDrawControls(drawControlConfig);
        this.drawService.setDraw(this.draw);
        this.mapFrameworkService.onMapEvent('load', this.map, () => {
            this.mapService.declareLabelSources('', this.polygonlabeldata, this.map);
            this.switchToStaticMode();
            this.canvas = this.map.getCanvasContainer();
            this.listenToDrawOnCreate();
            this.listenToDrawUpdate();
            this.listenToDrawDelete();
            this.canvas.addEventListener('mousemove', this.mouseMoveForDraw, true);
            this.draw.onDrawOnStart((e) => {
                this.drawClickCounter = 0;
                this.mapFrameworkService.setMapCursor(this.map, '');
            });
            this.draw.onDrawOnStop((e) => {
                this.drawClickCounter = 0;
                this.mapFrameworkService.setMapCursor(this.map, '');
            });
            this.listenToDrawInvalidGeometry();
            this.draw.onDrawEditSaveInitialFeature((edition) => {
                this.savedEditFeature = { ...edition.feature };
                this.savedEditFeature.coordinates = [[]];
                edition.feature.coordinates[0].forEach(c => this.savedEditFeature.coordinates[0].push(c));
            });
            this.listenToDrawSelectionChange();
            this.listenToDrawModeChange();
            this.mapFrameworkService.onMapEvent('click', this.map, (e) => {
                if (this.drawService.isDrawing()) {
                    this.drawClickCounter++;
                    this.updateTooltipMessage();
                }
                if (this.drawService.isDrawingCircle) {
                    return;
                }
                if (this.drawService.isDrawingPolygon) {
                    this.nbPolygonVertices++;
                    this.stopDrawingAtVerticeLimit();
                }
                else {
                    this.nbPolygonVertices = 0;
                    const features = this.map.queryRenderedFeatures(e.point);
                    // edit polygon condition : no arlas feature && mapbox-gl-draw source present
                    const editCondition = features.filter(f => f.layer.id?.indexOf('arlas') >= 0).length === 0 &&
                        features.filter(f => f.source.startsWith('mapbox-gl-draw')).length > 0;
                    if (editCondition) {
                        const candidates = features.filter(f => f.source.startsWith('mapbox-gl-draw'));
                        // edit only on click on the border of the polygon
                        const candidatesProperties = candidates.filter(f => f.layer.id?.indexOf('stroke') >= 0)[0]?.properties;
                        if (candidatesProperties?.id) {
                            if (candidatesProperties.user_meta === 'strip') {
                                this.draw.changeMode('direct_strip', {
                                    featureId: candidatesProperties.id,
                                    maxLength: candidatesProperties.user_maxLength,
                                    halfSwath: candidatesProperties.user_halfSwath
                                });
                                this.drawService.isInSimpleDrawMode = false;
                            }
                            else {
                                this.draw.changeMode('simple_select', {
                                    featureIds: [candidatesProperties.id]
                                });
                                this.drawService.isInSimpleDrawMode = true;
                            }
                        }
                    }
                }
            });
        });
        this.mapFrameworkService.onMapEvent('mousemove', this.map, (e) => {
            if (this.drawService.isDrawingBbox || this.drawService.isDrawingPolygon) {
                this.mapFrameworkService.setMapCursor(this.map, 'crosshair');
                this.map.moveLngLat = e.lngLat;
            }
        });
    }
    ngOnChanges(changes) {
        if (this.map && this.map.getMapProvider() !== undefined) {
            if (changes['drawData'] !== undefined && this.drawService.isReady) {
                const centroides = new Array();
                this.drawData.features.forEach(feature => {
                    const poly = polygon(feature.geometry.coordinates);
                    const cent = centroid(poly);
                    cent.properties.arlas_id = feature.properties.arlas_id;
                    centroides.push(cent);
                });
                this.polygonlabeldata = {
                    type: 'FeatureCollection',
                    features: centroides
                };
                this.drawService.addFeatures(this.drawData, /** deleteOld */ true);
                this.mapService.updateLabelSources(this.map.POLYGON_LABEL_SOURCE, this.polygonlabeldata, this.map);
            }
        }
    }
    /**
     * Update the tooltip message when drawing to reflect drawing mode and state
     */
    updateTooltipMessage() {
        let tooltipMessage;
        switch (this.draw.getCurrentMode().toLocaleUpperCase()) {
            case 'DRAW_RADIUS_CIRCLE':
                if (this.drawClickCounter === 0) {
                    tooltipMessage = marker('Click to set the center of the circle');
                }
                else {
                    tooltipMessage = marker('Click again to set the radius of the circle');
                }
                break;
            case 'DRAW_POLYGON':
                if (this.drawClickCounter < 2) {
                    tooltipMessage = marker('Click to set a corner of the polygon');
                }
                else {
                    tooltipMessage = marker('Double click to finish drawing');
                }
                break;
            case 'DRAW_CIRCLE':
                tooltipMessage = marker('Click to create a circle centered on this point');
                break;
            case 'DRAW_STRIP':
                if (this.drawClickCounter === 0) {
                    tooltipMessage = marker('Click to set the origin of the strip');
                }
                else {
                    tooltipMessage = marker('Click again to set the length and bearing of the strip');
                }
                break;
            case 'DRAW_RECTANGLE':
                if (this.drawClickCounter === 0) {
                    tooltipMessage = marker('Click to set the first corner of the rectangle');
                }
                else {
                    tooltipMessage = marker('Click again to complete the rectangle');
                }
                break;
            case 'STATIC':
            case 'SIMPLE_SELECT':
                this.drawClickCounter = 0;
                break;
            default:
                break;
        }
        this.drawTooltipMessage.set(tooltipMessage);
    }
    /**
     * @description Emits the bbox drawn by the BboxGenerator component
     * @param east
     * @param south
     * @param west
     * @param north
     */
    drawBbox(east, south, west, north) {
        const coordinates = [[
                [east, south],
                [east, north],
                [west, north],
                [west, south],
                [east, south],
            ]];
        const polygonGeojson = {
            type: 'Feature',
            properties: {
                source: 'bbox'
            },
            geometry: {
                type: 'Polygon',
                coordinates: coordinates
            }
        };
        const geoboxdata = { ...this.emptyData };
        geoboxdata.features = [];
        if (this.drawData?.features && this.drawData.features.length > 0) {
            this.drawData.features.forEach(df => geoboxdata.features.push(df));
        }
        geoboxdata.features.push(polygonGeojson);
        /** This allows to keep the drawn box on the map. It will be overriden in ngOnChanges `changes['drawData']` */
        this.drawService.addFeatures(geoboxdata, /** deleteOld */ true);
        this.onAoiChanged.next(geoboxdata);
        this.drawService.isDrawingBbox = false;
        this.drawService.endDimensionsEmission();
    }
    /** @description Enables bbox drawing mode.*/
    addGeoBox() {
        this.mapFrameworkService.setMapCursor(this.map, 'crosshair');
        this.switchToDrawMode('draw_rectangle');
    }
    /**
     * @description Removes all the aois if none of them is selected. Otherwise it removes the selected one only
     */
    removeAois() {
        this.mapFrameworkService.setMapCursor(this.map, '');
        this.drawService.isDrawingBbox = false;
        this.deleteSelectedItem();
    }
    /** @description Deletes the selected drawn geometry. If no drawn geometry is selected, all geometries are deteleted */
    deleteSelectedItem() {
        if (this.drawService.isDrawSelected) {
            this.draw.trash();
        }
        else {
            this.drawService.deleteAll();
        }
        this.drawService.isDrawSelected = false;
        this.onAoiChanged.next(this.draw.getAll());
    }
    /**
     * @description Shows an invalid-geometry error on a snack bar.
     */
    openInvalidGeometrySnackBar() {
        this._snackBar.open(this.translate.instant('Invalid geometry'), this.translate.instant('Ok'), {
            duration: 3 * 1000,
            verticalPosition: 'top',
            panelClass: 'invalid-geo-toast'
        });
    }
    /**
     * @description Switches to a drawing mode of a polygon, circle, radius circle or strip.
     * @param mode Draw mode (DRAW_POLYGON, DRAW_CIRCLE, DRAW_RADIUS_CIRCLE or DRAW_STRIP). Default to DRAW_POLYGON
     * @param option Mapboxdraw option.
     */
    switchToDrawMode(mode, option) {
        const selectedMode = mode ?? this.draw.getMode('DRAW_POLYGON');
        this.drawService.isDrawingCircle = selectedMode === this.draw.getMode('DRAW_CIRCLE')
            || selectedMode === this.draw.getMode('DRAW_RADIUS_CIRCLE');
        this.drawService.isDrawingPolygon = selectedMode === this.draw.getMode('DRAW_POLYGON');
        this.drawService.isDrawingStrip = selectedMode === this.draw.getMode('DRAW_STRIP');
        this.drawService.isDrawingBbox = selectedMode === this.draw.getMode('DRAW_RECTANGLE');
        this.drawService.isInSimpleDrawMode = false;
        this.mapFrameworkService.setMapCursor(this.map, 'crosshair');
        this.draw.changeMode(selectedMode, option ?? {});
        this.updateTooltipMessage();
    }
    /**
     * @description Switches to direct_select mode.
     * @param option Mapboxdraw option.
     */
    switchToDirectSelectMode(option) {
        this.draw.changeMode('direct_select', option);
        this.drawService.isInSimpleDrawMode = false;
        this.drawService.isDrawingCircle = false;
        this.drawService.isDrawingStrip = false;
        this.drawService.isDrawingPolygon = false;
        this.drawService.isDrawingBbox = false;
    }
    /**
     * @description Switches to simple_select mode.
     */
    switchToEditMode() {
        this.draw.changeMode('simple_select', {
            featureIds: this.draw.getAll().features.map(f => f.id)
        });
        this.drawService.isInSimpleDrawMode = true;
        this.drawService.isDrawingCircle = false;
        this.drawService.isDrawingStrip = false;
        this.drawService.isDrawingPolygon = false;
        this.drawService.isDrawingBbox = false;
    }
    /**
     * @description Switches to static mode.
     */
    switchToStaticMode() {
        this.draw.changeMode('static');
        this.drawService.isInSimpleDrawMode = false;
        this.drawService.isDrawingBbox = false;
        this.drawService.isDrawingCircle = false;
        this.drawService.isDrawingStrip = false;
        this.drawService.isDrawingPolygon = false;
        this.updateTooltipMessage();
    }
    /**
     * @description Returns all the drawn polygons as wkt or geojson.
     * @param mode 'wkt' | 'geojson'
     * @returns
     */
    getAllPolygon(mode) {
        let polygon;
        if (mode === 'wkt') {
            polygon = latLngToWKT(this.draw.getAll().features.filter(f => this.drawService.isPolygon(f) ||
                this.drawService.isCircle(f)).map(f => cleanCoords(f)));
        }
        else {
            polygon = {
                'type': 'FeatureCollection',
                'features': this.draw.getAll().features.filter(f => this.drawService.isPolygon(f) ||
                    this.drawService.isCircle(f)).map(f => cleanCoords(f))
            };
        }
        return polygon;
    }
    /**
     * @returns the selected polygon geometry in WKT or GeoJson given the mode
     * @param mode : 'wkt' | 'geojson'
     * @returns Wkt string or Geojson object.
     */
    getSelectedPolygon(mode) {
        let polygon;
        if (mode === 'wkt') {
            polygon = latLngToWKT(this.draw.getSelected().features.filter(f => this.drawService.isPolygon(f) ||
                this.drawService.isCircle(f)));
        }
        else {
            polygon = {
                'type': 'FeatureCollection',
                'features': this.draw.getSelected().features.filter(f => this.drawService.isPolygon(f) ||
                    this.drawService.isCircle(f))
            };
        }
        return polygon;
    }
    handleKeyboardEvent(event) {
        if (event.key === 'Escape') {
            if (this.drawService.isDrawing()) {
                this.drawService.deleteUnregisteredFeatures();
                this.mapFrameworkService.setMapCursor(this.map, '');
                this.switchToStaticMode();
                this.drawService.endDimensionsEmission();
            }
            else if (this.drawService.isInSimpleDrawMode) {
                this.drawService.isInSimpleDrawMode = false;
                this.draw.changeMode('simple_select', { featureIds: [] });
                this.updateTooltipMessage();
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasDrawComponent, deps: [{ token: MapboxAoiDrawService }, { token: i2$2.MatSnackBar }, { token: i3.TranslateService }, { token: ArlasMapFrameworkService }, { token: AbstractArlasMapService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ArlasDrawComponent, selector: "arlas-draw", inputs: { map: "map", emptyData: "emptyData", drawOption: "drawOption", drawData: "drawData", drawButtonEnabled: "drawButtonEnabled", drawPolygonVerticesLimit: "drawPolygonVerticesLimit", preserveDrawingBuffer: "preserveDrawingBuffer" }, outputs: { onAoiChanged: "onAoiChanged", onAoiEdit: "onAoiEdit" }, host: { listeners: { "document:keydown": "handleKeyboardEvent($event)" } }, usesOnChanges: true, ngImport: i0, template: "<div id=\"arlas-draw-tooltip\" class=\"draw-tooltip--hide\" [class.draw-tooltip--show]=\"drawTooltipMessage()\">\n    {{drawTooltipMessage() | translate}}</div>", styles: ["@charset \"UTF-8\";\n"], dependencies: [{ kind: "pipe", type: i3.TranslatePipe, name: "translate" }], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasDrawComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-draw', encapsulation: ViewEncapsulation.None, template: "<div id=\"arlas-draw-tooltip\" class=\"draw-tooltip--hide\" [class.draw-tooltip--show]=\"drawTooltipMessage()\">\n    {{drawTooltipMessage() | translate}}</div>", styles: ["@charset \"UTF-8\";\n"] }]
        }], ctorParameters: () => [{ type: MapboxAoiDrawService }, { type: i2$2.MatSnackBar }, { type: i3.TranslateService }, { type: ArlasMapFrameworkService }, { type: AbstractArlasMapService }], propDecorators: { map: [{
                type: Input
            }], emptyData: [{
                type: Input
            }], drawOption: [{
                type: Input
            }], drawData: [{
                type: Input
            }], drawButtonEnabled: [{
                type: Input
            }], drawPolygonVerticesLimit: [{
                type: Input
            }], preserveDrawingBuffer: [{
                type: Input
            }], onAoiChanged: [{
                type: Output
            }], onAoiEdit: [{
                type: Output
            }], handleKeyboardEvent: [{
                type: HostListener,
                args: ['document:keydown', ['$event']]
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
// eslint-disable-next-line max-len
const DECIMAL_SEXAGESIMAL_REGEX = '^(?<decimal>[+-]?([0-9]*[.])?[0-9]+)$|^(?<degrees>(-?)[0-9]+)°[ ]*((?<minutes>[0-9]+)\'[ ]*((?<seconds>[0-9]+)\")?)?$';
class PointFormGroup extends FormGroup {
    constructor(initLat, initLng) {
        const coordinatesRegex = DECIMAL_SEXAGESIMAL_REGEX;
        const latitude = new FormControl(String(initLat), [
            Validators.required,
            Validators.pattern(coordinatesRegex)
        ]);
        const longitude = new FormControl(String(initLng), [
            Validators.required,
            Validators.pattern(coordinatesRegex),
        ]);
        super({
            latitude,
            longitude
        });
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
class Coordinate {
    /** Parses a coordinate in decimal or sexagesimal degrees and returns the decimal degrees */
    static parse(value) {
        const coordinatesRegex = DECIMAL_SEXAGESIMAL_REGEX;
        const parsedCoordinates = (String(value)).match(coordinatesRegex);
        if (parsedCoordinates && parsedCoordinates.groups) {
            const groups = parsedCoordinates.groups;
            if (groups.decimal) {
                return +groups.decimal;
            }
            else {
                const degrees = +groups.degrees;
                const minutes = +groups.minutes;
                const seconds = +groups.seconds;
                return this.dmsToDd(degrees, minutes, seconds);
            }
        }
    }
    /** DegreeMinutesSeconds to Decimal degree */
    static dmsToDd(degrees, minutes, seconds) {
        const isNegative = (degrees < 0);
        if (!minutes) {
            minutes = 0;
        }
        if (!seconds) {
            seconds = 0;
        }
        const dd = Math.abs(degrees) + minutes / 60 + seconds / 3600;
        return isNegative ? -dd : dd;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class CoordinatesErrorPipe {
    transform(formControl) {
        if (formControl.hasError('required')) {
            return marker('You must enter a coordinate');
        }
        return formControl.hasError('pattern') ? marker('1.1 or 1°6\'3"') : '';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesErrorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesErrorPipe, name: "coordinatesFormError" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesErrorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'coordinatesFormError'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class CoordinatesComponent {
    constructor() {
        /**
         * @constant
         */
        this.placeHolder = marker('1.1 or 1°6\'3"');
        this.moveToCoordinates$ = new EventEmitter();
        this.editionMode = false;
    }
    ngOnInit() {
        this.coordinatesForm = new PointFormGroup(this.currentLat, this.currentLng);
    }
    switchToEditionMode() {
        this.editionMode = true;
        this.coordinatesForm.latitude.setValue(this.currentLat);
        this.coordinatesForm.longitude.setValue(this.currentLng);
    }
    moveToCoordinates() {
        const lat = Coordinate.parse(this.coordinatesForm.latitude.value);
        const lng = Coordinate.parse(this.coordinatesForm.longitude.value);
        this.moveToCoordinates$.emit([lng, lat]);
        this.editionMode = false;
        this.currentLat = String(lat);
        this.currentLng = String(lng);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: CoordinatesComponent, selector: "arlas-coordinates", inputs: { currentLat: "currentLat", currentLng: "currentLng" }, outputs: { moveToCoordinates$: "moveToCoordinates$" }, ngImport: i0, template: "<div class=\"current-coordinate\" (click)=\"switchToEditionMode()\" (keyDown)=\"switchToEditionMode()\" [matTooltip]=\"'Enter coordinates and centre the map' | translate\"\n  matTooltipPosition=\"above\" *ngIf=\"!editionMode; else editing\">\n  <span class=\"lat\"> {{ 'Lat:' | translate }} {{ currentLat | number:'1.5-5' }} </span>\n  <span class=\"lng\"> {{ 'Lng:' | translate }} {{ currentLng | number:'1.5-5' }} </span>\n</div>\n<ng-template #editing>\n  <div class=\"current-coordinate-edition\">\n    <div class=\"section\" [formGroup]=\"coordinatesForm\">\n      <mat-form-field appearance=\"outline\">\n        <mat-label>{{'Latitude' | translate}}</mat-label>\n        <input class=\"input\" matInput [formControl]=\"coordinatesForm.latitude\"\n          [placeholder]=\"placeHolder | translate\">\n        <mat-error *ngIf=\"coordinatesForm.latitude.invalid\">{{coordinatesForm.latitude | coordinatesFormError | translate}}\n        </mat-error>\n      </mat-form-field>\n      <div class=\"coordinate\">\n        <mat-form-field appearance=\"outline\">\n          <mat-label>{{'Longitude' | translate}}</mat-label>\n          <input class=\"input\" matInput [formControl]=\"coordinatesForm.longitude\"\n            [placeholder]=\"placeHolder | translate\">\n          <mat-error *ngIf=\"coordinatesForm.longitude.invalid\">{{coordinatesForm.longitude | coordinatesFormError |\n            translate}}</mat-error>\n        </mat-form-field>\n      </div>\n      <button class=\"move\" mat-stroked-button (click)=\"moveToCoordinates()\"\n        [disabled]=\"coordinatesForm.invalid\">\n        <span class=\"label\">{{'Move to' | translate}}</span>\n      </button>\n    </div>\n    <div class=\"exit\" (click)=\"editionMode = false\" (keyDown)=\"editionMode = false\">\n      <mat-icon>clear</mat-icon>\n    </div>\n  </div>\n</ng-template>", styles: ["@charset \"UTF-8\";.current-coordinate,.current-coordinate-edition{position:absolute;right:110px;bottom:10px}.current-coordinate{background-color:#fff;border:1px solid #a1a1a1;border-radius:4px;cursor:pointer;font-size:14px;padding:2.5px 5px;height:22px;display:flex;align-items:center;justify-content:space-around}.current-coordinate .lng,.current-coordinate .lat{width:110px}.current-coordinate .lat{margin-right:10px}.current-coordinate-edition{background-color:#fff;border:1px solid grey;border-radius:4px;padding:5px}.current-coordinate-edition .section{display:flex;align-items:center}.current-coordinate-edition .section .coordinate{padding:0 5px}.current-coordinate-edition .section ::ng-deep .mat-mdc-form-field-infix{padding-left:5px;padding-bottom:5px;padding-top:5px;font-size:14px;min-height:unset}.current-coordinate-edition .section ::ng-deep .mat-mdc-form-field{padding:7px 0;width:130px}.current-coordinate-edition .section ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}.current-coordinate-edition .section .move .label{background-color:#fff}.current-coordinate-edition .exit{cursor:pointer;position:absolute;top:-10px;right:-10px;border-radius:10px;border:1px solid grey;display:flex;align-items:center;justify-content:center;width:20px;height:20px;background-color:#fff}.current-coordinate-edition .exit mat-icon{font-size:15px;height:15px;width:15px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i6$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i5.MatLabel, selector: "mat-label" }, { kind: "directive", type: i5.MatError, selector: "mat-error, [matError]", inputs: ["id"] }, { kind: "directive", type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i5$1.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "directive", type: i6$2.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "pipe", type: i2$1.DecimalPipe, name: "number" }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }, { kind: "pipe", type: CoordinatesErrorPipe, name: "coordinatesFormError" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-coordinates', template: "<div class=\"current-coordinate\" (click)=\"switchToEditionMode()\" (keyDown)=\"switchToEditionMode()\" [matTooltip]=\"'Enter coordinates and centre the map' | translate\"\n  matTooltipPosition=\"above\" *ngIf=\"!editionMode; else editing\">\n  <span class=\"lat\"> {{ 'Lat:' | translate }} {{ currentLat | number:'1.5-5' }} </span>\n  <span class=\"lng\"> {{ 'Lng:' | translate }} {{ currentLng | number:'1.5-5' }} </span>\n</div>\n<ng-template #editing>\n  <div class=\"current-coordinate-edition\">\n    <div class=\"section\" [formGroup]=\"coordinatesForm\">\n      <mat-form-field appearance=\"outline\">\n        <mat-label>{{'Latitude' | translate}}</mat-label>\n        <input class=\"input\" matInput [formControl]=\"coordinatesForm.latitude\"\n          [placeholder]=\"placeHolder | translate\">\n        <mat-error *ngIf=\"coordinatesForm.latitude.invalid\">{{coordinatesForm.latitude | coordinatesFormError | translate}}\n        </mat-error>\n      </mat-form-field>\n      <div class=\"coordinate\">\n        <mat-form-field appearance=\"outline\">\n          <mat-label>{{'Longitude' | translate}}</mat-label>\n          <input class=\"input\" matInput [formControl]=\"coordinatesForm.longitude\"\n            [placeholder]=\"placeHolder | translate\">\n          <mat-error *ngIf=\"coordinatesForm.longitude.invalid\">{{coordinatesForm.longitude | coordinatesFormError |\n            translate}}</mat-error>\n        </mat-form-field>\n      </div>\n      <button class=\"move\" mat-stroked-button (click)=\"moveToCoordinates()\"\n        [disabled]=\"coordinatesForm.invalid\">\n        <span class=\"label\">{{'Move to' | translate}}</span>\n      </button>\n    </div>\n    <div class=\"exit\" (click)=\"editionMode = false\" (keyDown)=\"editionMode = false\">\n      <mat-icon>clear</mat-icon>\n    </div>\n  </div>\n</ng-template>", styles: ["@charset \"UTF-8\";.current-coordinate,.current-coordinate-edition{position:absolute;right:110px;bottom:10px}.current-coordinate{background-color:#fff;border:1px solid #a1a1a1;border-radius:4px;cursor:pointer;font-size:14px;padding:2.5px 5px;height:22px;display:flex;align-items:center;justify-content:space-around}.current-coordinate .lng,.current-coordinate .lat{width:110px}.current-coordinate .lat{margin-right:10px}.current-coordinate-edition{background-color:#fff;border:1px solid grey;border-radius:4px;padding:5px}.current-coordinate-edition .section{display:flex;align-items:center}.current-coordinate-edition .section .coordinate{padding:0 5px}.current-coordinate-edition .section ::ng-deep .mat-mdc-form-field-infix{padding-left:5px;padding-bottom:5px;padding-top:5px;font-size:14px;min-height:unset}.current-coordinate-edition .section ::ng-deep .mat-mdc-form-field{padding:7px 0;width:130px}.current-coordinate-edition .section ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}.current-coordinate-edition .section .move .label{background-color:#fff}.current-coordinate-edition .exit{cursor:pointer;position:absolute;top:-10px;right:-10px;border-radius:10px;border:1px solid grey;display:flex;align-items:center;justify-content:center;width:20px;height:20px;background-color:#fff}.current-coordinate-edition .exit mat-icon{font-size:15px;height:15px;width:15px}\n"] }]
        }], propDecorators: { currentLat: [{
                type: Input
            }], currentLng: [{
                type: Input
            }], moveToCoordinates$: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
class BasemapComponent {
    constructor(basemapService, mapService, mapFrameworkService) {
        this.basemapService = basemapService;
        this.mapService = mapService;
        this.mapFrameworkService = mapFrameworkService;
        this._onDestroy$ = new Subject$1();
        this.basemapChanged = new EventEmitter();
        this.blur = new Subject$1();
        this.showList = false;
        this.basemapService.basemapChanged$.pipe(takeUntil(this._onDestroy$)).subscribe(() => this.basemapChanged.emit());
    }
    ngOnInit() {
        this.initBasemaps();
    }
    initBasemaps() {
        this.basemaps = this.basemapService.basemaps;
        if (this.basemaps) {
            const styles = this.basemaps.styles();
            if (styles) {
                this.showList = styles.length > 0;
                styles.filter(bm => !bm.image).forEach(bm => {
                    if (bm.type !== 'protomap' && !!bm.url) {
                        const splitUrl = bm.url.split('/style.json?key=');
                        if (splitUrl.length === 2) {
                            bm.image = `${splitUrl[0]}/0/0/0.png?key=${splitUrl[1]}`;
                        }
                    }
                });
            }
        }
    }
    /** Removes the old basemap and set the new one that is given as a parameter
     * @param newBasemap: Basemap selected by the user
     */
    onChangeBasemap(newBasemap) {
        const selectedBasemap = this.basemaps.getSelected();
        if (selectedBasemap.type === 'protomap') {
            this.basemapService.removeProtomapBasemap(this.map);
        }
        this.setBaseMapStyle(newBasemap);
    }
    setBaseMapStyle(newBasemap) {
        if (this.map) {
            this.basemapService.setBasemap(this.basemaps.getSelected().styleFile, newBasemap, this.map, this.mapSources);
        }
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapComponent, deps: [{ token: BasemapService }, { token: AbstractArlasMapService }, { token: ArlasMapFrameworkService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: BasemapComponent, selector: "arlas-basemap", inputs: { map: "map", mapSources: "mapSources" }, outputs: { basemapChanged: "basemapChanged", blur: "blur" }, ngImport: i0, template: "<div *ngIf=\"showList\" class=\"basemap-container\">\n  <ng-container *ngFor=\"let style of basemaps?._styles\">\n    <div *ngIf=\"!style.errored\" class=\"basemap\" [class.selected]=\"style.name === basemaps?._selectedStyle?.name\"\n    (click)=\"onChangeBasemap(style)\" (keyDown)=\"onChangeBasemap(style)\">\n      <div class=\"image\">\n        <img *ngIf=\"!!style?.image && style?.image !== ''\" src=\"{{style?.image}}\" (error)=\"style.image = null\" />\n        <div *ngIf=\"!style?.image || (!!style?.image && style?.image === '')\" class=\"no-image\">\n          <mat-icon>wallpaper</mat-icon>\n        </div>\n        <div class=\"name\">{{style.name | translate}}</div>\n      </div>\n    </div>\n  </ng-container>\n</div>\n", styles: ["@charset \"UTF-8\";.basemap-container{border-radius:6px;position:absolute;top:10px;right:45px;display:flex;flex-flow:row wrap;max-width:243px;gap:3px;overflow:hidden}.basemap-container .basemap{border:2px solid white;background-color:#fff;border-radius:6px;cursor:pointer}.basemap-container .basemap .image{height:75px;width:75px;position:relative}.basemap-container .basemap .image .name{font-size:10px;line-height:15px;text-align:center;position:absolute;width:100%;bottom:0;background-color:#f5f5f580;border-radius:0 0 6px 6px;text-shadow:1px 1px 2px white;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.basemap-container .basemap .image img{width:75px;border-radius:6px;image-rendering:auto}.basemap-container .basemap .image .no-image{width:75px;height:75px;background-color:#fff;text-align:center;padding-top:20px}.basemap-container .selected{border:2px solid #337ab7;background-color:#337ab7;color:#337ab7;font-weight:600}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i6$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-basemap', template: "<div *ngIf=\"showList\" class=\"basemap-container\">\n  <ng-container *ngFor=\"let style of basemaps?._styles\">\n    <div *ngIf=\"!style.errored\" class=\"basemap\" [class.selected]=\"style.name === basemaps?._selectedStyle?.name\"\n    (click)=\"onChangeBasemap(style)\" (keyDown)=\"onChangeBasemap(style)\">\n      <div class=\"image\">\n        <img *ngIf=\"!!style?.image && style?.image !== ''\" src=\"{{style?.image}}\" (error)=\"style.image = null\" />\n        <div *ngIf=\"!style?.image || (!!style?.image && style?.image === '')\" class=\"no-image\">\n          <mat-icon>wallpaper</mat-icon>\n        </div>\n        <div class=\"name\">{{style.name | translate}}</div>\n      </div>\n    </div>\n  </ng-container>\n</div>\n", styles: ["@charset \"UTF-8\";.basemap-container{border-radius:6px;position:absolute;top:10px;right:45px;display:flex;flex-flow:row wrap;max-width:243px;gap:3px;overflow:hidden}.basemap-container .basemap{border:2px solid white;background-color:#fff;border-radius:6px;cursor:pointer}.basemap-container .basemap .image{height:75px;width:75px;position:relative}.basemap-container .basemap .image .name{font-size:10px;line-height:15px;text-align:center;position:absolute;width:100%;bottom:0;background-color:#f5f5f580;border-radius:0 0 6px 6px;text-shadow:1px 1px 2px white;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.basemap-container .basemap .image img{width:75px;border-radius:6px;image-rendering:auto}.basemap-container .basemap .image .no-image{width:75px;height:75px;background-color:#fff;text-align:center;padding-top:20px}.basemap-container .selected{border:2px solid #337ab7;background-color:#337ab7;color:#337ab7;font-weight:600}\n"] }]
        }], ctorParameters: () => [{ type: BasemapService }, { type: AbstractArlasMapService }, { type: ArlasMapFrameworkService }], propDecorators: { map: [{
                type: Input
            }], mapSources: [{
                type: Input
            }], basemapChanged: [{
                type: Output
            }], blur: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var PROPERTY_SELECTOR_SOURCE;
(function (PROPERTY_SELECTOR_SOURCE) {
    PROPERTY_SELECTOR_SOURCE["fix"] = "Fix";
    PROPERTY_SELECTOR_SOURCE["provided"] = "Provided";
    PROPERTY_SELECTOR_SOURCE["generated"] = "Generated";
    PROPERTY_SELECTOR_SOURCE["manual"] = "Manual";
    PROPERTY_SELECTOR_SOURCE["interpolated"] = "Interpolated";
    PROPERTY_SELECTOR_SOURCE["metric_on_field"] = "Metric on field";
    PROPERTY_SELECTOR_SOURCE["heatmap_density"] = "Density";
})(PROPERTY_SELECTOR_SOURCE || (PROPERTY_SELECTOR_SOURCE = {}));

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const GET = 'get';
const MATCH = 'match';
const INTERPOLATE = 'interpolate';
const OTHER = marker('other_color');
const IN = 'in';
const NOT_IN = '!';
const HEATMAP_DENSITY = 'Heatmap-density';

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function getMax$1(data) {
    return Math.max(...data.map(hd => +hd.value));
}
const MAX_CIRLE_RADIUS = 7;
const MAX_LINE_WIDTH = 10;

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class LegendService {
    getCircleLegend(paint, visibileMode, legendData, layer) {
        return undefined;
    }
    getLineLegend(paint, visibileMode, legendData, layer) {
        return undefined;
    }
    getFillLegend(paint, visibileMode, legendData, layer) {
        return undefined;
    }
    getHeatmapLegend(paint, visibileMode, legendData, layer) {
        return undefined;
    }
    getLabelLegend(paint, visibileMode, legendData, layer) {
        return undefined;
    }
    static setProvidedColorLegend(colorLegend, field, legendData, filter, translate) {
        colorLegend.title = field;
        if (!Array.isArray(field)) {
            colorLegend.type = PROPERTY_SELECTOR_SOURCE.provided;
            if (field.endsWith('_arlas__color')) {
                colorLegend.type = PROPERTY_SELECTOR_SOURCE.generated;
            }
            colorLegend.manualValues = new Map();
            if (legendData?.get(field)) {
                const keysToColors = legendData.get(field).keysColorsMap;
                const colorList = Array.from(keysToColors.keys()).map(k => [k, keysToColors.get(k)]).flat();
                for (let i = 0; i < colorList.length; i += 2) {
                    colorLegend.manualValues.set(translate ? translate.instant(colorList[i]) : colorList[i], colorList[i + 1]);
                }
                if (colorList.length === 0) {
                    colorLegend.manualValues.set('', '#eee');
                }
            }
            else {
                colorLegend.manualValues.set('', '#eee');
            }
            if (filter) {
                LegendService.filterLegend(colorLegend.manualValues, filter, (field).endsWith('_arlas__color') ? (field).slice(0, -13) : field);
            }
        }
    }
    static setMatchColorLegend(colorLegend, colorExpression, legendData, filter, translate) {
        /** color = ["match", ["get", "field"], .... ]**/
        colorLegend.type = PROPERTY_SELECTOR_SOURCE.manual;
        const colorsLength = colorExpression.length;
        let hasDefaultColor = false;
        if (colorsLength % 2 !== 0) {
            hasDefaultColor = true;
        }
        const field = colorExpression[1].length === 2 ? colorExpression[1][1] : '';
        colorLegend.title = field;
        colorLegend.manualValues = new Map();
        let keysToColors;
        if (legendData?.get(field + '_color')) {
            // If there is a legendData, use only the colors in the keysToColors
            keysToColors = legendData.get(field + '_color').keysColorsMap;
        }
        else {
            // If no legendData for this field, use all the colors of colorExpression
            keysToColors = new Map();
            for (let i = 2; i < colorExpression.length; i += 2) {
                if (hasDefaultColor && i === colorsLength - 3) {
                    keysToColors.set(colorExpression[i] + '', colorExpression[i + 1]);
                    keysToColors.set(OTHER, colorExpression[i + 2]);
                    break;
                }
                else {
                    keysToColors.set(colorExpression[i] + '', colorExpression[i + 1]);
                }
            }
        }
        for (let i = 2; i < colorExpression.length; i += 2) {
            if (hasDefaultColor && i === colorsLength - 3) {
                if (keysToColors.has(colorExpression[i] + '')) {
                    colorLegend.manualValues.set(translate ? translate.instant(colorExpression[i] + '') : colorExpression[i], colorExpression[i + 1]);
                }
                colorLegend.manualValues.set(translate ? translate.instant(OTHER) : OTHER, colorExpression[i + 2]);
                break;
            }
            else if (keysToColors.has(colorExpression[i] + '')) {
                colorLegend.manualValues.set(translate ? translate.instant(colorExpression[i] + '') : colorExpression[i], colorExpression[i + 1]);
            }
        }
        if (filter) {
            LegendService.filterLegend(colorLegend.manualValues, filter, field);
        }
    }
    static setInterpolatedColorLegend(colorLegend, colorExpression, legendData, visibleMode) {
        colorLegend.type = PROPERTY_SELECTOR_SOURCE.interpolated;
        /** color = ["interplate", ['linear'], ["get", "field"], 0, 1... ]**/
        // todo throw exception if interpolation is not linear
        const field = colorExpression[2].length === 2 ? colorExpression[2][1] : HEATMAP_DENSITY;
        colorLegend.title = field;
        colorLegend.interpolatedValues = [];
        const palette = [];
        const colors = colorExpression.slice(3);
        colors.forEach((c, i) => {
            if (i % 2 === 0) {
                palette.push({
                    proportion: c,
                    value: colors[i + 1]
                });
            }
        });
        const minimum = palette[0].proportion;
        const maximum = palette.slice(-1)[0].proportion;
        palette.forEach(c => colorLegend.interpolatedValues.push(c.value));
        const colorValues = colorExpression.filter((c, i) => i > 2 && i % 2 !== 0);
        if (legendData?.get(field) && field !== 'count') {
            colorLegend.minValue = legendData.get(field).minValue;
            colorLegend.maxValue = legendData.get(field).maxValue;
            // For heatmaps, the count is used to fetch data, so we use it for the legend
        }
        else if (field === HEATMAP_DENSITY && legendData?.get('count')) {
            colorLegend.minValue = legendData.get('count').minValue;
            colorLegend.maxValue = legendData.get('count').maxValue;
        }
        else {
            colorLegend.minValue = colorValues[0] + '';
            colorLegend.maxValue = colorValues[colorValues.length - 1] + '';
        }
        if (!visibleMode) {
            /** apply greyscale because the layer is not visible */
            colorLegend.interpolatedValues = colorLegend.interpolatedValues
                .map((c) => tinycolor(c.toString()).greyscale().lighten(20).toHexString());
            palette.forEach(p => {
                p.value = tinycolor(p.value.toString()).greyscale().lighten(20).toHexString();
            });
        }
        return palette.map(c => c.value + ' ' + (100 * (c.proportion - minimum) / (maximum - minimum)) + '%').join(',');
    }
    static filterLegend(colorLegendValues, filter, field) {
        filter.forEach((f, idx) => {
            if (idx !== 0 && idx !== filter.length - 1) {
                switch (f[0]) {
                    case IN: {
                        if (f[1][1] === field) {
                            const valuesToKeep = f[2][1];
                            colorLegendValues.forEach((val, key) => {
                                if (!(valuesToKeep.includes(key))) {
                                    colorLegendValues.delete(key);
                                }
                            });
                        }
                        break;
                    }
                    case NOT_IN: {
                        if (f[1][0] === IN && f[1][1][1] === field) {
                            const valuesToExclude = f[1][2][1];
                            valuesToExclude.forEach(value => {
                                colorLegendValues.delete(value);
                            });
                        }
                        break;
                    }
                }
            }
        });
    }
    static buildColorLegend(colorExpression, visibleMode, legendData, filter, translate) {
        const colorLegend = { visible: true };
        let colorPalette = '';
        if (typeof colorExpression === 'string') {
            colorLegend.type = PROPERTY_SELECTOR_SOURCE.fix;
            colorLegend.fixValue = colorExpression;
        }
        else if (Array.isArray(colorExpression)) {
            if (colorExpression.length === 2) {
                /** color = ["get", "field"]  ==> Generated or Provided */
                const field = colorExpression[1];
                colorLegend.title = field;
                LegendService.setProvidedColorLegend(colorLegend, field, legendData, filter, translate);
            }
            else if (colorExpression.length >= 3) {
                if (colorExpression[0] === MATCH) {
                    LegendService.setMatchColorLegend(colorLegend, colorExpression, legendData, filter, translate);
                }
                else if (colorExpression[0] === INTERPOLATE) {
                    colorPalette = LegendService.setInterpolatedColorLegend(colorLegend, colorExpression, legendData, visibleMode);
                }
            }
        }
        colorLegend.visible = visibleMode;
        return [colorLegend, colorPalette];
    }
    ;
    static buildRadiusLegend(radiusExpression, legendData) {
        const radiusLegend = {};
        const circleRadiusEvolution = new Array();
        if (Array.isArray(radiusExpression)) {
            if (radiusExpression.length >= 3) {
                // Filter out the zoom-dependent radius layers (circle-heatmap)
                if (radiusExpression[0] === INTERPOLATE && radiusExpression[2].length > 1) {
                    const field = radiusExpression[2][1];
                    radiusExpression.filter((w, i) => i >= 3).forEach((w, i) => {
                        if (i % 2 === 0) {
                            circleRadiusEvolution.push({ key: w, value: radiusExpression[i + 1 + 3] });
                        }
                    });
                    radiusLegend.title = field;
                    if (legendData?.get(field)) {
                        radiusLegend.minValue = legendData.get(field).minValue;
                        radiusLegend.maxValue = legendData.get(field).maxValue;
                    }
                    else {
                        radiusLegend.minValue = circleRadiusEvolution[0].key + '';
                        radiusLegend.maxValue = circleRadiusEvolution[circleRadiusEvolution.length - 1].key + '';
                    }
                    radiusLegend.type = PROPERTY_SELECTOR_SOURCE.interpolated;
                    const maxCircleRadius = getMax(circleRadiusEvolution);
                    if (maxCircleRadius > MAX_CIRLE_RADIUS) {
                        circleRadiusEvolution.forEach(lw => lw.value = lw.value * MAX_CIRLE_RADIUS / maxCircleRadius);
                    }
                    radiusLegend.histogram = circleRadiusEvolution;
                }
            }
        }
        return radiusLegend;
    }
    ;
    static buildWidthLegend(lineWidth, legendData) {
        /** if the line width is fix then it is not added to the legend*/
        const widthLegend = {};
        if (Array.isArray(lineWidth)) {
            if (lineWidth.length >= 3) {
                if (lineWidth[0] === INTERPOLATE) {
                    const field = lineWidth[2][1];
                    widthLegend.title = field;
                    if (legendData?.get(field)) {
                        widthLegend.minValue = legendData.get(field).minValue;
                        widthLegend.maxValue = legendData.get(field).maxValue;
                    }
                    widthLegend.type = PROPERTY_SELECTOR_SOURCE.interpolated;
                    const lineWidthEvolution = new Array();
                    lineWidth.filter((w, i) => i >= 3).forEach((w, i) => {
                        if (i % 2 === 0) {
                            lineWidthEvolution.push({ key: w, value: lineWidth[i + 1 + 3] });
                        }
                    });
                    const maxLineWidth = getMax(lineWidthEvolution);
                    if (maxLineWidth > MAX_LINE_WIDTH) {
                        lineWidthEvolution.forEach(lw => lw.value = lw.value * MAX_LINE_WIDTH / maxLineWidth);
                    }
                    widthLegend.histogram = lineWidthEvolution;
                }
            }
        }
        return widthLegend;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LegendService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LegendService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LegendService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class LayerIconComponent {
    constructor() {
        this.colorLegend = {};
        this.strokeColorLegend = {};
        this.widthLegend = {};
        this.radiusLegend = {};
    }
    ngAfterViewInit() {
        if (this.layer) {
            this.drawIcons();
        }
    }
    ngOnChanges(changes) {
        if (changes['layer'] !== undefined) {
            if (this.layer && this.layerIconElement) {
                this.drawIcons();
            }
        }
    }
    drawIcons() {
        const type = this.layer.type;
        const source = this.layer.source;
        switch (type) {
            case 'circle':
            case 'circle-heatmap': {
                if (source.startsWith('feature-metric')) {
                    drawFeatureCircleIcon(this.layerIconElement.nativeElement, this.colorLegend, this.strokeColorLegend, true);
                }
                else if (source.startsWith('feature')) {
                    drawFeatureCircleIcon(this.layerIconElement.nativeElement, this.colorLegend, this.strokeColorLegend);
                }
                else if (source.startsWith('cluster')) {
                    const addBlur = type === 'circle-heatmap';
                    drawClusterCircleIcon(this.layerIconElement.nativeElement, this.colorLegend, this.strokeColorLegend, addBlur);
                }
                break;
            }
            case 'line': {
                if (source.startsWith('feature-metric')) {
                    drawLineIcon(this.layerIconElement.nativeElement, this.colorLegend, this.lineDasharray, true);
                }
                else {
                    drawLineIcon(this.layerIconElement.nativeElement, this.colorLegend, this.lineDasharray);
                }
                break;
            }
            case 'fill': {
                if (source.startsWith('cluster')) {
                    drawClusterFillIcon(this.layerIconElement.nativeElement, this.colorLegend, this.strokeColorLegend);
                }
                else if (source.startsWith('feature-metric')) {
                    drawFeatureFillIcon(this.layerIconElement.nativeElement, this.colorLegend, this.strokeColorLegend, true);
                }
                else {
                    drawFeatureFillIcon(this.layerIconElement.nativeElement, this.colorLegend, this.strokeColorLegend);
                }
                break;
            }
            case 'heatmap': {
                drawHeatmapIcon(this.layerIconElement.nativeElement, this.colorLegend, this.layer.source.toString().startsWith('feature-metric'));
                break;
            }
            case 'symbol': {
                const l = (this.layer.layout);
                if (l['text-field']) {
                    drawTextIcon(this.layerIconElement.nativeElement, this.colorLegend);
                }
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LayerIconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: LayerIconComponent, selector: "arlas-layer-icon", inputs: { layer: "layer", colorLegend: "colorLegend", strokeColorLegend: "strokeColorLegend", widthLegend: "widthLegend", radiusLegend: "radiusLegend", lineDasharray: "lineDasharray" }, viewQueries: [{ propertyName: "layerIconElement", first: true, predicate: ["layer_icon"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: "<div class=\"legend-icon\">\n  <svg #layer_icon class=\"legend-icon__svg\"></svg>\n</div>\n", styles: ["@charset \"UTF-8\";.legend-icon{width:20px;height:20px}.legend-icon__svg{height:100%;width:100%}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LayerIconComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-layer-icon', template: "<div class=\"legend-icon\">\n  <svg #layer_icon class=\"legend-icon__svg\"></svg>\n</div>\n", styles: ["@charset \"UTF-8\";.legend-icon{width:20px;height:20px}.legend-icon__svg{height:100%;width:100%}\n"] }]
        }], ctorParameters: () => [], propDecorators: { layer: [{
                type: Input
            }], colorLegend: [{
                type: Input
            }], strokeColorLegend: [{
                type: Input
            }], widthLegend: [{
                type: Input
            }], radiusLegend: [{
                type: Input
            }], lineDasharray: [{
                type: Input
            }], layerIconElement: [{
                type: ViewChild,
                args: ['layer_icon', { read: ElementRef, static: false }]
            }] } });
/**
 * Draws the rectangles icon for cluster mode
 * @param svgNode SVG element on which we append the rectangles using d3.
 * @param colorLegend Color legend, to give the drawn icons rectangles the same color on the map
 * @param strokeColorLegend Color legend, to give the drawn icons rectangles the same stroke color on the map
 */
function drawClusterFillIcon(svgNode, colorLegend, strokeColorLegend) {
    const fillFourColors = getClusterFillColors(colorLegend);
    let strokeFourColors = fillFourColors;
    if (strokeColorLegend) {
        strokeFourColors = getClusterFillColors(strokeColorLegend);
    }
    const svg = select(svgNode);
    svg.selectAll('g').remove();
    svg.append('g').append('rect')
        .attr('height', 7).attr('width', 7)
        .attr('fill', fillFourColors[0]).attr('fill-opacity', 0.8)
        .attr('stroke', strokeFourColors[0]).attr('stroke-width', 0.6)
        .attr('y', 3).attr('x', 3);
    svg.append('g').append('rect')
        .attr('height', 7).attr('width', 7)
        .attr('fill', fillFourColors[1]).attr('fill-opacity', 0.6)
        .attr('stroke', strokeFourColors[1]).attr('stroke-width', 0.6)
        .attr('y', 10).attr('x', 3);
    svg.append('g').append('rect')
        .attr('height', 7).attr('width', 7)
        .attr('fill', fillFourColors[2]).attr('fill-opacity', 0.6)
        .attr('stroke', strokeFourColors[2]).attr('stroke-width', 0.6)
        .attr('y', 10).attr('x', 10);
    svg.append('g').append('rect')
        .attr('height', 7).attr('width', 7)
        .attr('fill', fillFourColors[3]).attr('fill-opacity', 0.6)
        .attr('stroke', strokeFourColors[3]).attr('stroke-width', 0.6)
        .attr('y', 3).attr('x', 10);
}
/**
 * Draws the rectangles icon for feature and feature-metric modes
 * @param svgNode SVG element on which we append the rectangles using d3.
 * @param colorLegend Color legend, to give the drawn icons rectangles the same color on the map
 * @param strokeColorLegend Color legend, to give the drawn icons rectangles the same stroke color on the map
 * @param [isMetric=false] Whether the layer depends on a metric
 */
function drawFeatureFillIcon(svgNode, colorLegend, strokeColorLegend, isMetric = false) {
    const fillColor = getOneColor(colorLegend);
    let strokeColor = fillColor;
    if (strokeColorLegend) {
        strokeColor = getOneColor(strokeColorLegend);
    }
    const polygon = [
        { 'x': 0, 'y': 2 },
        { 'x': 18, 'y': 2 },
        { 'x': 13, 'y': 18 },
        { 'x': 1, 'y': 18 },
        { 'x': 8, 'y': 9 },
        { 'x': 0, 'y': 2 }
    ];
    const svg = select(svgNode);
    svg.selectAll('g').remove();
    svg.append('g').selectAll('polygon')
        .data([polygon])
        .enter().append('polygon')
        .attr('points', (d) => d.map(d => [d.x, d.y].join(',')).join(' ')).attr('fill', fillColor)
        .attr('fill-opacity', 0.5)
        .attr('stroke', strokeColor)
        .attr('stroke-width', 0.9);
    if (isMetric) {
        svg.append('g').append('text').text('∑')
            .attr('x', 14).attr('y', 14).attr('font-size', '0.5em').attr('font-weight', 'bold').attr('fill', colorLegend.fixValue);
    }
}
function getOneColor(legend) {
    let color = '';
    if (legend.type === PROPERTY_SELECTOR_SOURCE.interpolated) {
        const iv = legend.interpolatedValues;
        color = iv[0] + '';
    }
    else if (legend.type === PROPERTY_SELECTOR_SOURCE.fix) {
        color = legend.fixValue + '';
    }
    else if (legend.type === PROPERTY_SELECTOR_SOURCE.manual || legend.type === PROPERTY_SELECTOR_SOURCE.generated
        || legend.type === PROPERTY_SELECTOR_SOURCE.provided) {
        const mv = legend.manualValues;
        color = mv.values().next().value;
    }
    return color;
}
function drawTextIcon(svgNode, colorLegend) {
    const svg = select(svgNode);
    svg.selectAll('g').remove();
    svg.append('g').append('text').text(' T ').attr('transform', ' translate(5 0)')
        .attr('y', 14).attr('font-size', '0.9em').attr('font-family', 'Garamond').attr('fill', colorLegend.fixValue);
}
/**
 * draws the heatmap icon for cluster mode
 * @param svgNode SVG element on which we append the heamap circles using d3.
 * @param colorLegend Color legend, to give the drawn icons circles the same color on the map
 * @param small Whether to create a small version of the icon
 */
function drawHeatmapIcon(svgNode, colorLegend, small) {
    const heatmapColors = [];
    if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.interpolated) {
        const iv = colorLegend.interpolatedValues;
        if (iv) {
            if (iv.length === 1) {
                heatmapColors.push(iv[0], iv[0], iv[0]);
            }
            else if (iv.length === 2) {
                heatmapColors.push(iv[0], iv[0], iv[1]);
            }
            else if (iv.length === 3) {
                heatmapColors.push(iv[1], iv[Math.trunc(iv.length / 2)], iv[iv.length - 1]);
            }
            else if (iv.length >= 4) {
                heatmapColors.push(iv[1], iv[Math.trunc(iv.length / 3)], iv[Math.trunc(2 * iv.length / 3)], iv[iv.length - 1]);
            }
        }
    }
    const svg = select(svgNode);
    svg.selectAll('defs').remove();
    svg.append('defs')
        .append('filter').attr('id', 'blur')
        .append('feGaussianBlur').attr('stdDeviation', 0.8);
    if (small) {
        svg.selectAll('g').remove();
        svg.append('g')
            .append('circle')
            .attr('cx', 10).attr('cy', 10)
            .attr('r', 7)
            .style('fill', heatmapColors[0])
            .attr('filter', 'url(#blur)');
    }
    else {
        svg.selectAll('circle').remove();
        svg.selectAll('circle')
            .data(heatmapColors).enter()
            .append('circle')
            .attr('cx', 10).attr('cy', 10)
            .attr('r', (d, i) => {
            if (i === 0) {
                return 10;
            }
            if (i === 1) {
                return 8;
            }
            if (i === 2) {
                return 6;
            }
            if (i === 3) {
                return 3;
            }
        })
            .style('fill', (d, i) => d)
            .attr('filter', 'url(#blur)');
    }
}
/**
 * Draws the line icon for feature mode
 * @param svgNode SVG element on which we append the line using d3.
 * @param colorLegend Color legend, to give the drawn icons line the same color on the map
 * @param dashArray Array representing the dash pattern
 * @param [isMetric=false] Whether the layer depends on a metric
 */
function drawLineIcon(svgNode, colorLegend, dashArray, isMetric = false) {
    let lineColor = '';
    if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.fix) {
        lineColor = colorLegend.fixValue + '';
    }
    else if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.interpolated) {
        const iv = colorLegend.interpolatedValues;
        if (iv) {
            lineColor = iv[0] + '';
        }
        else {
            lineColor = '#2da4ff';
        }
    }
    else if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.manual || colorLegend.type === PROPERTY_SELECTOR_SOURCE.generated
        || colorLegend.type === PROPERTY_SELECTOR_SOURCE.provided) {
        const mv = colorLegend.manualValues;
        lineColor = mv.values().next().value;
    }
    let svgDashArray = '0';
    if (!!dashArray && dashArray.length > 1) {
        const joinedDashArray = dashArray.join(',');
        if (joinedDashArray === '2,5') {
            svgDashArray = '0, 2, 3';
        }
        else if (joinedDashArray === '0.1,5') {
            svgDashArray = '1,2.5';
        }
        else {
            svgDashArray = '4,2,1';
        }
    }
    const svg = select(svgNode);
    svg.selectAll('g').remove();
    svg.append('g').append('line')
        .attr('x1', 0).attr('y1', 18)
        .attr('x2', 6).attr('y2', 10)
        .attr('cx', 2).attr('cy', 2)
        .attr('stroke', lineColor).attr('stroke-width', 1.5).attr('stroke-dasharray', svgDashArray);
    svg.append('g').append('line')
        .attr('x1', 6).attr('y1', 10)
        .attr('x2', 12).attr('y2', 4)
        .attr('cx', 2).attr('cy', 2)
        .attr('stroke', lineColor).attr('stroke-width', 1.5).attr('stroke-dasharray', svgDashArray);
    svg.append('g').append('line')
        .attr('x1', 12).attr('y1', 4)
        .attr('x2', 18).attr('y2', 0)
        .attr('cx', 2).attr('cy', 2)
        .attr('stroke', lineColor).attr('stroke-width', 1.5).attr('stroke-dasharray', svgDashArray);
    if (isMetric) {
        svg.append('g').append('text').text('∑')
            .attr('x', 10).attr('y', 16).attr('font-size', '0.5em').attr('font-weight', 'bold').attr('fill', colorLegend.fixValue);
    }
}
/**
 * Draws the circle icon for feature mode
 * @param svgNode SVG element on which we append the circles using d3.
 * @param colorLegend Color legend, to give the drawn icons circles the same color on the map
 * @param strokeColorLegend Color legend, to give the drawn icons circles the same stroke color on the map
 * @param [isMetric=false] Whether the layer depends on a metric
 */
function drawFeatureCircleIcon(svgNode, colorLegend, strokeColorLegend, isMetric = false) {
    const colorsList = [];
    const strokeColorsList = [];
    populateListFromLegend(colorsList, colorLegend);
    populateListFromLegend(strokeColorsList, strokeColorLegend);
    const svg = select(svgNode);
    svg.selectAll('circle').remove();
    svg.selectAll('g').remove();
    svg.selectAll('circle')
        .data(colorsList).enter()
        .append('circle')
        .attr('cx', (d, i) => {
        if (colorsList.length === 1) {
            return 10;
        }
        else {
            if (i === 0) {
                return 6;
            }
            if (i === 1) {
                return 12;
            }
            if (i === 2) {
                return 5;
            }
        }
    })
        .attr('cy', (d, i) => {
        if (colorsList.length === 1) {
            return 10;
        }
        else {
            if (i === 0) {
                return 5;
            }
            if (i === 1) {
                return 10;
            }
            if (i === 2) {
                return 15;
            }
        }
    })
        .attr('r', (d, i) => {
        if (colorsList.length === 1) {
            return 7;
        }
        else {
            return 3;
        }
    })
        .style('fill', (d, i) => d).style('fill-opacity', colorsList.length === 1 ? 0.6 : 0.8)
        .style('stroke', (d, i) => strokeColorsList[i]).style('stroke-width', 0.5);
    if (isMetric) {
        svg.append('g').append('text').text('∑')
            .attr('x', 10).attr('y', 16).attr('font-size', '0.5em').attr('font-weight', 'bold').attr('fill', colorLegend.fixValue);
    }
}
/**
 * draws the circle icon for cluster mode
 * @param svgNode SVG element on which we append the circles using d3.
 * @param colorLegend Color legend, to give the drawn icons circles the same color on the map
 * @param strokeColorLegend Color legend, to give the drawn icons circles the same stroke color on the map
 * @param addBlur Whether to add blur to the drawn circles
 */
function drawClusterCircleIcon(svgNode, colorLegend, strokeColorLegend, addBlur = false) {
    // todo include radius legend in drawing icons
    const colorsList = [];
    const strokeColorsList = [];
    populateListFromLegend(colorsList, colorLegend);
    populateListFromLegend(strokeColorsList, strokeColorLegend);
    const svg = select(svgNode);
    svg.selectAll('circle').remove();
    svg.append('defs')
        .append('filter')
        .attr('id', 'blurHeatmapCircle')
        .attr('x', '-10%')
        .attr('y', '-40%')
        .attr('width', '160%')
        .attr('height', '160%')
        .append('feGaussianBlur').attr('stdDeviation', 1.9);
    svg.selectAll('circle')
        .data(colorsList).enter()
        .append('circle')
        .attr('cx', (d, i) => {
        if (i === 0) {
            return 12;
        }
        if (i === 1) {
            return 6;
        }
        if (i === 2) {
            return 10;
        }
    })
        .attr('cy', (d, i) => {
        if (i === 0) {
            return 7;
        }
        if (i === 1) {
            return 11;
        }
        if (i === 2) {
            return 15;
        }
    })
        .attr('r', (d, i) => {
        if (i === 0) {
            return 6;
        }
        if (i === 1) {
            return 5;
        }
        if (i === 2) {
            return 3;
        }
    })
        .style('fill', (d, i) => d).style('fill-opacity', 0.7)
        .style('stroke', (d, i) => strokeColorsList[i]).style('stroke-width', 0.8);
    if (addBlur) {
        svg.selectAll('circle').attr('filter', 'url(#blurHeatmapCircle)');
    }
}
function populateListFromLegend(list, legend) {
    if (legend.type === PROPERTY_SELECTOR_SOURCE.fix) {
        list.push(legend.fixValue);
        list.push(legend.fixValue);
        list.push(legend.fixValue);
    }
    else if (legend.type === PROPERTY_SELECTOR_SOURCE.interpolated) {
        const iv = legend.interpolatedValues;
        if (iv?.length === 1) {
            list.push(iv[0], iv[0], iv[0]);
        }
        else if (iv.length === 2) {
            list.push(iv[0], iv[0], iv[1]);
        }
        else if (iv.length >= 3) {
            list.push(iv[0], iv[Math.trunc(iv.length / 2)], iv[iv.length - 1]);
        }
    }
    else if (legend.type === PROPERTY_SELECTOR_SOURCE.manual || legend.type === PROPERTY_SELECTOR_SOURCE.generated
        || legend.type === PROPERTY_SELECTOR_SOURCE.provided) {
        const iv = legend.manualValues;
        if (iv) {
            if (iv.size === 1) {
                const color = iv.values().next().value;
                list.push(color, color, color);
            }
            else if (iv.size === 2) {
                list.push(Array.from(iv.values())[0], Array.from(iv.values())[0], Array.from(iv.values())[1]);
            }
            else if (iv.size >= 3) {
                list.push(Array.from(iv.values())[0], Array.from(iv.values())[Math.trunc(Array.from(iv.keys()).length / 2)], Array.from(iv.values())[Array.from(iv.keys()).length - 1]);
            }
        }
        else if (!iv || iv.size === 0) {
            list.push('#eee', '#eee', '#eee');
        }
    }
}
function getClusterFillColors(colorLegend) {
    const fourColors = [];
    if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.interpolated) {
        const iv = colorLegend.interpolatedValues;
        if (iv) {
            if (iv.length === 1) {
                for (let i = 0; i < 4; i++) {
                    fourColors.push(iv[0]);
                }
            }
            else if (iv.length === 2) {
                fourColors.push(iv[0]);
                fourColors.push(iv[1]);
                fourColors.push(iv[0]);
                fourColors.push(iv[1]);
            }
            else if (iv.length >= 3) {
                fourColors.push(iv[0]);
                fourColors.push(iv[Math.trunc(2 * iv.length / 3)]);
                fourColors.push(iv[iv.length - 1]);
                fourColors.push(iv[Math.trunc(iv.length / 3)]);
            }
        }
    }
    else if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.fix) {
        const c = colorLegend.fixValue;
        fourColors.push(c, c, c, c);
    }
    return fourColors;
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class FormatLegendPipe {
    constructor(collectionService) {
        this.collectionService = collectionService;
        this.metrics = [
            'avg',
            'sum',
            'min',
            'max',
            'cardinality',
            'count'
        ];
    }
    transform(field) {
        let params = {
            translateKey: this.collectionService.getDisplayFieldName(field),
            format: 'original'
        };
        if (!field) {
            return null;
        }
        const parts = field.split(':');
        // Regular normalized
        const containsNormalizedPartOrMetric = parts.length === 2
            // Normalized by key
            || parts.length === 3
            // Metric
            || (parts.length === 1 && this.containsMetrics(parts[0]));
        if (containsNormalizedPartOrMetric) {
            const valueSplit = parts[0].split('_');
            if (valueSplit.length === 0) {
                return params;
            }
            const hasExtraEmptyValue = valueSplit[valueSplit.length - 1] === '';
            if (hasExtraEmptyValue) {
                valueSplit.splice(valueSplit.length - 1, 1);
            }
            const metric = this.getMetric(valueSplit);
            const field = this.getField(valueSplit);
            const normalized = parts[1] ?? '';
            const normalizedKey = parts[2] ?? '';
            params = this.buildInterpolatedParams(params, metric, field, normalized, normalizedKey);
        }
        else if (parts[0].endsWith('_arlas__color')) {
            params.translateKey = this.collectionService.getDisplayFieldName(params.translateKey.replace('_arlas__color', ''));
        }
        return params;
    }
    buildInterpolatedParams(params, metric, field, normalized, normalizedKey) {
        const legendParams = {
            ...params,
            field: this.collectionService.getDisplayFieldName(field),
            normalized: '',
            metric,
        };
        if (!metric) {
            legendParams.format = 'noMetric';
            legendParams.translateKey = marker('legend without metric');
        }
        else if (field && normalized) {
            legendParams.format = 'full';
            legendParams.translateKey = marker('legend');
        }
        else if (field) {
            legendParams.format = 'metricField';
            legendParams.translateKey = marker('legend without normalized');
        }
        else if (normalized) {
            legendParams.format = 'metricNormalised';
            legendParams.translateKey = marker('legend without field');
        }
        if (normalized) {
            if (normalizedKey) {
                legendParams.normalized = marker('normalized by key');
                legendParams.normalizedKey = normalizedKey;
            }
            else {
                legendParams.normalized = marker('normalized');
            }
        }
        return legendParams;
    }
    getMetric(valueSplit) {
        if (this.isMetrics(valueSplit[valueSplit.length - 1])) {
            return valueSplit[valueSplit.length - 1];
        }
    }
    getField(valueSplit) {
        // If last split is a metric, then exclude it
        if (this.isMetrics(valueSplit[valueSplit.length - 1])) {
            return valueSplit.slice(0, valueSplit.length - 1).join('_');
        }
        return valueSplit.join('_');
    }
    isMetrics(metrics) {
        return this.metrics.includes(metrics);
    }
    containsMetrics(value) {
        for (const metric of this.metrics) {
            if (value.includes(metric)) {
                return true;
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatLegendPipe, deps: [{ token: i2.CollectionService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: FormatLegendPipe, name: "formatLegend" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatLegendPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'formatLegend'
                }]
        }], ctorParameters: () => [{ type: i2.CollectionService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class LegendItemComponent {
    constructor() {
        this.PROPERTY_SELECTOR_SOURCE = PROPERTY_SELECTOR_SOURCE;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LegendItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: LegendItemComponent, selector: "arlas-legend-item", inputs: { legend: "legend", title: "title", layer: "layer", colorPalette: "colorPalette" }, viewQueries: [{ propertyName: "interpolatedElement", first: true, predicate: ["interpolated_svg"], descendants: true, read: ElementRef }], ngImport: i0, template: "<div *ngIf=\"legend && legend.type && legend.visible !== false && layer\" class=\"legend\">\n  <ng-container *ngIf=\"(legend.title | formatLegend) as l\">\n    <div class=\"legend__title\">\n      {{ title | translate}} {{ l.translateKey | translate: {metric: l.metric | translate, field: l.field | translate, normalized: l.normalized | translate: {normalizedKey: l.normalizedKey | translate} } }}\n    </div>\n  </ng-container>\n\n  <div class=\"legend--manual\" *ngIf=\"legend.type === PROPERTY_SELECTOR_SOURCE.manual\n        || legend.type === PROPERTY_SELECTOR_SOURCE.generated\n        || legend.type === PROPERTY_SELECTOR_SOURCE.provided\">\n    <div class=\"legend--manual__item\" *ngFor=\"let manualColor of legend.manualValues | keyvalue\">\n      <div [style.backgroundColor]=\"manualColor.value\"\n        [class.circle-tip]=\"layer.type === 'circle'\"\n        [class.line-tip]=\"layer.type === 'line'\"\n        [class.fill-tip]=\"layer.type === 'fill'\">\n      </div>\n      <div class=\"legend--manual__item__key\" [matTooltip]=\"manualColor.key | translate\" [matTooltipPosition]=\"'left'\">\n        {{manualColor.key | translate}}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"legend--interpolated\" *ngIf=\"legend.type === PROPERTY_SELECTOR_SOURCE.interpolated\">\n    <div *ngIf=\"!!colorPalette; else size\" class=\"legend--interpolated__palette\"\n      [style.background]=\"'linear-gradient(to right, ' + colorPalette + ')'\"></div>\n    <ng-template #size>\n      <div class=\"legend--interpolated__svg\">\n        <svg #interpolated_svg></svg>\n      </div>\n    </ng-template>\n    <div class=\"legend--interpolated__range\">\n      <div class=\"legend--interpolated__range__value\">\n        {{legend?.minValue | formatNumber:'NUMBER_FORMAT_CHAR' | translate}}\n      </div>\n      <div class=\"legend--interpolated__range__value\">\n        {{legend?.maxValue | formatNumber:'NUMBER_FORMAT_CHAR' | translate}}\n      </div>\n    </div>\n  </div>\n</div>", styles: ["@charset \"UTF-8\";.legend{padding-bottom:2px}.legend__title{text-align:center;font-size:12px;color:#666;text-overflow:ellipsis;overflow:hidden;font-family:Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif}.legend--manual{display:flex;flex-flow:wrap;margin-top:5px;max-height:160px;overflow-y:auto}.legend--manual__item{display:flex;align-items:center;min-width:50%}.legend--manual__item .circle-tip{width:12px;height:12px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;margin-top:2px}.legend--manual__item .line-tip{width:20px;height:4px;border-radius:2px}.legend--manual__item .fill-tip{width:10px;height:10px}.legend--manual__item__key{font-size:12px;margin-left:5px;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.legend--interpolated{height:100%;padding-top:5px}.legend--interpolated__palette{height:5px;border-radius:2px}.legend--interpolated__range{display:flex;justify-content:space-between;padding-top:2.5px}.legend--interpolated__range__value{font-size:12px;color:#666}\n"], dependencies: [{ kind: "directive", type: i5$1.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }, { kind: "pipe", type: i2.FormatNumberPipe, name: "formatNumber" }, { kind: "pipe", type: i2$1.KeyValuePipe, name: "keyvalue" }, { kind: "pipe", type: FormatLegendPipe, name: "formatLegend" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LegendItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-legend-item', template: "<div *ngIf=\"legend && legend.type && legend.visible !== false && layer\" class=\"legend\">\n  <ng-container *ngIf=\"(legend.title | formatLegend) as l\">\n    <div class=\"legend__title\">\n      {{ title | translate}} {{ l.translateKey | translate: {metric: l.metric | translate, field: l.field | translate, normalized: l.normalized | translate: {normalizedKey: l.normalizedKey | translate} } }}\n    </div>\n  </ng-container>\n\n  <div class=\"legend--manual\" *ngIf=\"legend.type === PROPERTY_SELECTOR_SOURCE.manual\n        || legend.type === PROPERTY_SELECTOR_SOURCE.generated\n        || legend.type === PROPERTY_SELECTOR_SOURCE.provided\">\n    <div class=\"legend--manual__item\" *ngFor=\"let manualColor of legend.manualValues | keyvalue\">\n      <div [style.backgroundColor]=\"manualColor.value\"\n        [class.circle-tip]=\"layer.type === 'circle'\"\n        [class.line-tip]=\"layer.type === 'line'\"\n        [class.fill-tip]=\"layer.type === 'fill'\">\n      </div>\n      <div class=\"legend--manual__item__key\" [matTooltip]=\"manualColor.key | translate\" [matTooltipPosition]=\"'left'\">\n        {{manualColor.key | translate}}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"legend--interpolated\" *ngIf=\"legend.type === PROPERTY_SELECTOR_SOURCE.interpolated\">\n    <div *ngIf=\"!!colorPalette; else size\" class=\"legend--interpolated__palette\"\n      [style.background]=\"'linear-gradient(to right, ' + colorPalette + ')'\"></div>\n    <ng-template #size>\n      <div class=\"legend--interpolated__svg\">\n        <svg #interpolated_svg></svg>\n      </div>\n    </ng-template>\n    <div class=\"legend--interpolated__range\">\n      <div class=\"legend--interpolated__range__value\">\n        {{legend?.minValue | formatNumber:'NUMBER_FORMAT_CHAR' | translate}}\n      </div>\n      <div class=\"legend--interpolated__range__value\">\n        {{legend?.maxValue | formatNumber:'NUMBER_FORMAT_CHAR' | translate}}\n      </div>\n    </div>\n  </div>\n</div>", styles: ["@charset \"UTF-8\";.legend{padding-bottom:2px}.legend__title{text-align:center;font-size:12px;color:#666;text-overflow:ellipsis;overflow:hidden;font-family:Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif}.legend--manual{display:flex;flex-flow:wrap;margin-top:5px;max-height:160px;overflow-y:auto}.legend--manual__item{display:flex;align-items:center;min-width:50%}.legend--manual__item .circle-tip{width:12px;height:12px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;margin-top:2px}.legend--manual__item .line-tip{width:20px;height:4px;border-radius:2px}.legend--manual__item .fill-tip{width:10px;height:10px}.legend--manual__item__key{font-size:12px;margin-left:5px;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.legend--interpolated{height:100%;padding-top:5px}.legend--interpolated__palette{height:5px;border-radius:2px}.legend--interpolated__range{display:flex;justify-content:space-between;padding-top:2.5px}.legend--interpolated__range__value{font-size:12px;color:#666}\n"] }]
        }], ctorParameters: () => [], propDecorators: { legend: [{
                type: Input
            }], title: [{
                type: Input
            }], layer: [{
                type: Input
            }], colorPalette: [{
                type: Input
            }], interpolatedElement: [{
                type: ViewChild,
                args: ['interpolated_svg', { read: ElementRef, static: false }]
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class LayerIdToName {
    /** FROM V15.0.0 layer ids look like 'arlas_id:NAME:timestamp
     * This pipe extracts the 'NAME' in that id
     */
    transform(id) {
        return getLayerName(id);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LayerIdToName, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: LayerIdToName, name: "layerIdToName" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LayerIdToName, decorators: [{
            type: Pipe,
            args: [{
                    name: 'layerIdToName'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class LegendComponent {
    constructor(translate, colorService, legendService) {
        this.translate = translate;
        this.colorService = colorService;
        this.legendService = legendService;
        /**
         * @Input : Angular
         * @description Subject of [collection, [field, legendData]] map. The map subscribes to it to keep
         * the legend updated with the data displayed on the map.
         */
        this.legendUpdater = new Subject();
        /**
         * @Input : Angular
         * @description Subject of [field, boolean] map. The map subscribes to it to keep
         * the legend updated with the visibility of the layer.
         */
        this.visibilityUpdater = new Subject();
        /**
         * @Output : Angular
         * @description Notifies the parent component that this layer is visible or not
         */
        this.visibilityStatus = new Subject();
        /**
         * @Output : Angular
         * @description Notifies the parent component that the user wants to download the layer
         */
        this.downloadSourceEmitter = new Subject();
        this.colorLegend = signal({});
        this.hasColorLegend = computed(() => this.colorLegend().type !== undefined && this.colorLegend().type !== 'Fix');
        this.strokeColorLegend = signal({});
        this.hasStrokeLegend = computed(() => this.strokeColorLegend().type !== undefined && this.strokeColorLegend().type !== 'Fix');
        this.widthLegend = signal({});
        this.hasWidthLegend = computed(() => this.widthLegend().type !== undefined && this.widthLegend().type !== 'Fix');
        this.radiusLegend = signal({});
        this.hasRadiusLegend = computed(() => this.radiusLegend().type !== undefined && this.radiusLegend().type !== 'Fix');
        this.displayLegendDetailToggle = computed(() => this.hasColorLegend() || this.hasStrokeLegend() || this.hasWidthLegend() || this.hasRadiusLegend());
        this.detail = false;
        this.visibleMode = false;
        this.PROPERTY_SELECTOR_SOURCE = PROPERTY_SELECTOR_SOURCE;
        this.legendData = new Map();
        this.colorPalette = '';
        this.strokeColorPalette = '';
        this.MAX_CIRLE_RADIUS = 7;
        this.LEGEND_WIDTH = 210;
        this._onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.legendUpdater
            .pipe(takeUntil(this._onDestroy$))
            .subscribe(legendDataPerCollection => {
            this.legendData = legendDataPerCollection.get(this.collection);
            if (this.layer) {
                this.drawLegends(this.visibleMode);
            }
        });
        this.visibilityUpdater
            .pipe(takeUntil(this._onDestroy$))
            .subscribe(visibilityUpdater => {
            /** check legend visibility according to Data source status (mapcontirbutor) */
            if (this.layer) {
                /** if the visibility updater contains the layer we pick the visibility status otherwise we keep it unchaged */
                this.visibleMode = visibilityUpdater.get(this.layer.id) !== undefined ? visibilityUpdater.get(this.layer.id) : this.visibleMode;
            }
            else {
                this.visibleMode = false;
            }
            /** check legend visibility according to VisibilityRules */
            if (this.visibleMode && this.layer && !!this.layer.minzoom && !!this.layer.maxzoom) {
                this.visibleMode = (this.zoom <= this.layer.maxzoom && this.zoom >= this.layer.minzoom);
            }
            /** check legend visibility according to legend enabled or not */
            if (!this.enabled) {
                this.visibleMode = false;
            }
            if (!this.visibleMode) {
                this.detail = this.visibleMode;
            }
            /** check legend visibility for external layers that are not set by config nor map contributors */
            if (this.layer && !this.layer.id.startsWith(ARLAS_ID) &&
                !this.layer.id.startsWith(FILLSTROKE_LAYER_PREFIX) && !this.layer.id.startsWith(HOVER_LAYER_PREFIX)
                && !this.layer.id.startsWith(SELECT_LAYER_PREFIX)) {
                this.visibleMode = this.enabled;
                if (!!this.layer.metadata && this.layer.metadata.showLegend === false) {
                    this.visibleMode = false;
                }
            }
            if (this.layer) {
                this.drawLegends(this.visibleMode);
            }
            this.visibilityStatus.next(this.visibleMode);
        });
    }
    ngAfterViewInit() {
        if (this.layer) {
            this.drawLegends(this.visibleMode);
        }
    }
    ngOnChanges(changes) {
        if (changes['layer'] !== undefined) {
            if (this.layer) {
                this.drawLegends(this.visibleMode);
            }
        }
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    downloadLayerSource(layer, downloadType) {
        const download = {
            layer,
            downloadType
        };
        this.downloadSourceEmitter.next(download);
    }
    showDetail(event) {
        this.detail = !this.detail;
        event.stopPropagation();
    }
    /** Parses the `paint` attribute of a layer and draws the legend elements such as
     * - color palette
     * - line width evolution
     * - circle radius evolution
     */
    drawLegends(visibileMode) {
        const type = this.layer.type;
        const paint = this.layer.paint;
        switch (type) {
            case 'circle': {
                const circleLegend = this.legendService.getCircleLegend(paint, visibileMode, this.legendData, this.layer);
                this.colorLegend.set(circleLegend.color);
                // For circle-heatmap layer the stroke can't be configured, so hide it
                if (this.layer.metadata?.hiddenProps?.geomType !== 'circle-heatmap') {
                    this.strokeColorLegend.set(circleLegend.strokeColor);
                }
                this.colorPalette = circleLegend.colorPalette;
                this.strokeColorPalette = circleLegend.strokeColorPalette;
                this.radiusLegend.set(circleLegend.radius);
                if (this.circleRadiusLegend?.interpolatedElement) {
                    const circleRadiusEvolution = circleLegend.radius.histogram;
                    drawCircleSupportLine(this.circleRadiusLegend.interpolatedElement.nativeElement, circleRadiusEvolution, this.colorLegend(), this.LEGEND_WIDTH, Math.min(this.MAX_CIRLE_RADIUS, getMax(circleRadiusEvolution)) * 2);
                }
                break;
            }
            case 'line': {
                const lineLegend = this.legendService.getLineLegend(paint, visibileMode, this.legendData, this.layer);
                this.lineDasharray = lineLegend.dashes;
                this.colorLegend.set(lineLegend.color);
                this.colorPalette = lineLegend.colorPalette;
                this.widthLegend.set(lineLegend.width);
                if (this.lineWidthLegend?.interpolatedElement) {
                    const lineWidthEvolution = lineLegend.width.histogram;
                    drawLineWidth(this.lineWidthLegend.interpolatedElement.nativeElement, lineWidthEvolution, this.colorLegend(), this.LEGEND_WIDTH, MAX_LINE_WIDTH);
                }
                break;
            }
            case 'fill': {
                const fillLegend = this.legendService.getFillLegend(paint, visibileMode, this.legendData, this.layer);
                this.colorLegend.set(fillLegend.color);
                this.colorPalette = fillLegend.colorPalette;
                this.strokeColorLegend.set(fillLegend?.strokeColor);
                this.strokeColorPalette = fillLegend?.strokeColorPalette;
                break;
            }
            case 'heatmap': {
                const heatmapLegend = this.legendService.getHeatmapLegend(paint, visibileMode, this.legendData, this.layer);
                this.colorLegend.set(heatmapLegend.color);
                this.colorPalette = heatmapLegend.colorPalette;
                this.radiusLegend.set(heatmapLegend.radius);
                if (this.circleRadiusLegend?.interpolatedElement) {
                    const heatmapRadiusEvolution = heatmapLegend.radius.histogram;
                    drawCircleSupportLine(this.circleRadiusLegend.interpolatedElement.nativeElement, heatmapRadiusEvolution, this.colorLegend(), this.LEGEND_WIDTH, Math.min(this.MAX_CIRLE_RADIUS, getMax(heatmapRadiusEvolution)) * 2);
                }
                break;
            }
            case 'symbol': {
                const symbolLegend = this.legendService.getLabelLegend(paint, visibileMode, this.legendData, this.layer);
                this.colorLegend.set(symbolLegend.color);
                this.colorPalette = symbolLegend.colorPalette;
                this.widthLegend.set(symbolLegend.size);
                if (!!this.lineWidthLegend && !!this.lineWidthLegend.interpolatedElement) {
                    const lineWidthEvolution = symbolLegend.size.histogram;
                    drawLineWidth(this.lineWidthLegend.interpolatedElement.nativeElement, lineWidthEvolution, this.colorLegend(), this.LEGEND_WIDTH, MAX_LINE_WIDTH);
                }
                break;
            }
        }
        if (!this.colorLegend().fixValue) {
            this.colorLegend().fixValue = visibileMode ? '#444' : '#d3d3d3';
        }
        const layer = { ...this.layer };
        this.layer = null;
        this.layer = { ...layer };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LegendComponent, deps: [{ token: i3.TranslateService }, { token: i2.ArlasColorService }, { token: LegendService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.13", type: LegendComponent, selector: "arlas-legend", inputs: { layer: "layer", collection: "collection", zoom: "zoom", enabled: "enabled", legendUpdater: "legendUpdater", visibilityUpdater: "visibilityUpdater" }, outputs: { visibilityStatus: "visibilityStatus", downloadSourceEmitter: "downloadSourceEmitter" }, viewQueries: [{ propertyName: "lineWidthLegend", first: true, predicate: ["width_legend"], descendants: true }, { propertyName: "circleRadiusLegend", first: true, predicate: ["radius_legend"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "\n<div class=\"layer_wrapper\">\n    <div class=collection_color [matTooltip]=\"'Collection:' | translate: {collection: (collection | getCollectionDisplayName)}\"\n      [style.backgroundColor]=\"!!collection ? (collection | getColor) : 'transparent'\"></div>\n    <div class=\"layer_container\" >\n      <div class=\"layer_icon_container\">\n        <div class=\"layer_icon\" >\n          <arlas-layer-icon [layer]=\"layer\" [colorLegend]=\"colorLegend()\" [strokeColorLegend]=\"strokeColorLegend()\"\n            [lineDasharray]=\"lineDasharray\" [widthLegend]=\"widthLegend()\" [radiusLegend]=\"radiusLegend()\"></arlas-layer-icon>\n        </div>\n        <div class=\"layer_name\" [style.color]=\"visibleMode ? '#444': '#d3d3d3'\">\n          {{layer?.id | layerIdToName | translate}}\n        </div>\n      </div>\n      <div class=\"layer_detail\">\n        <div class=\"download_button\">\n          <mat-icon class=\"download_icon\" [matMenuTriggerFor]=\"menu\" [matTooltip]=\"'Download the layer\\'s data' | translate\">file_download</mat-icon>\n          <mat-menu #menu=\"matMenu\">\n            <button mat-menu-item (click)=\"downloadLayerSource(layer, 'csv')\">\n              {{'CSV' | translate}}\n            </button>\n            <button mat-menu-item (click)=\"downloadLayerSource(layer, 'geojson')\">\n              {{'GeoJson' | translate}}\n            </button>\n          </mat-menu>\n        </div>\n\n        @if (displayLegendDetailToggle()) {\n          <div class=\"detail_button\" (click)=\"showDetail($event)\" (keyDown)=\"showDetail($event)\">\n            <mat-icon class=\"detail_icon\">{{ detail ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}</mat-icon>\n          </div>\n        }\n      </div>\n    </div>\n\n    <div [hidden]=\"!detail\" class=\"legend-wrapper\">\n      <arlas-legend-item [hidden]=\"!hasColorLegend()\" [legend]=\"colorLegend()\" [layer]=\"layer\"\n        [title]=\"'Fill:' | marker\" [colorPalette]=\"colorPalette\"></arlas-legend-item>\n\n      <arlas-legend-item [hidden]=\"!hasStrokeLegend()\" [legend]=\"strokeColorLegend()\" [layer]=\"layer\"\n        [title]=\"'Stroke:' | marker\" [colorPalette]=\"colorPalette\"></arlas-legend-item>\n\n      <arlas-legend-item [hidden]=\"!hasWidthLegend()\" #width_legend [legend]=\"widthLegend()\" [layer]=\"layer\"\n        [title]=\"'Width:' | marker\"></arlas-legend-item>\n\n      <arlas-legend-item [hidden]=\"!hasRadiusLegend()\" #radius_legend [legend]=\"radiusLegend()\" [layer]=\"layer\"\n        [title]=\"'Radius:' | marker\"></arlas-legend-item>\n    </div>\n  </div>\n", styles: ["@charset \"UTF-8\";.layer_name{font-size:14px}.layer_wrapper{border-top:.4px #eaeaea solid}.collection_color{width:4px;background-color:transparent;height:100%;position:absolute;cursor:pointer;z-index:1000}.layer_container{display:flex;position:relative;justify-content:space-between;padding-left:15px;padding-top:2.5px;padding-bottom:2.5px}.layer_icon_container{display:flex;padding-left:5px}.layer_detail{display:flex}.detail_button,.download_button{background-color:#fff;height:20px;width:20px;cursor:pointer}.detail_icon,.download_icon{color:#555;font-size:16px;width:20px;height:20px;display:flex;align-items:center;justify-content:center}.layer_icon{margin-right:5px;display:flex}.legend-wrapper{width:210px;padding-left:10px}\n"], dependencies: [{ kind: "component", type: i6$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5$2.MatMenu, selector: "mat-menu", inputs: ["backdropClass", "aria-label", "aria-labelledby", "aria-describedby", "xPosition", "yPosition", "overlapTrigger", "hasBackdrop", "class", "classList"], outputs: ["closed", "close"], exportAs: ["matMenu"] }, { kind: "component", type: i5$2.MatMenuItem, selector: "[mat-menu-item]", inputs: ["role", "disabled", "disableRipple"], exportAs: ["matMenuItem"] }, { kind: "directive", type: i5$2.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", inputs: ["mat-menu-trigger-for", "matMenuTriggerFor", "matMenuTriggerData", "matMenuTriggerRestoreFocus"], outputs: ["menuOpened", "onMenuOpen", "menuClosed", "onMenuClose"], exportAs: ["matMenuTrigger"] }, { kind: "directive", type: i5$1.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "component", type: LayerIconComponent, selector: "arlas-layer-icon", inputs: ["layer", "colorLegend", "strokeColorLegend", "widthLegend", "radiusLegend", "lineDasharray"] }, { kind: "component", type: LegendItemComponent, selector: "arlas-legend-item", inputs: ["legend", "title", "layer", "colorPalette"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }, { kind: "pipe", type: i2.GetCollectionDisplayNamePipe, name: "getCollectionDisplayName" }, { kind: "pipe", type: i2.GetColorPipe, name: "getColor" }, { kind: "pipe", type: i9.MarkerPipe, name: "marker" }, { kind: "pipe", type: LayerIdToName, name: "layerIdToName" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: LegendComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-legend', template: "\n<div class=\"layer_wrapper\">\n    <div class=collection_color [matTooltip]=\"'Collection:' | translate: {collection: (collection | getCollectionDisplayName)}\"\n      [style.backgroundColor]=\"!!collection ? (collection | getColor) : 'transparent'\"></div>\n    <div class=\"layer_container\" >\n      <div class=\"layer_icon_container\">\n        <div class=\"layer_icon\" >\n          <arlas-layer-icon [layer]=\"layer\" [colorLegend]=\"colorLegend()\" [strokeColorLegend]=\"strokeColorLegend()\"\n            [lineDasharray]=\"lineDasharray\" [widthLegend]=\"widthLegend()\" [radiusLegend]=\"radiusLegend()\"></arlas-layer-icon>\n        </div>\n        <div class=\"layer_name\" [style.color]=\"visibleMode ? '#444': '#d3d3d3'\">\n          {{layer?.id | layerIdToName | translate}}\n        </div>\n      </div>\n      <div class=\"layer_detail\">\n        <div class=\"download_button\">\n          <mat-icon class=\"download_icon\" [matMenuTriggerFor]=\"menu\" [matTooltip]=\"'Download the layer\\'s data' | translate\">file_download</mat-icon>\n          <mat-menu #menu=\"matMenu\">\n            <button mat-menu-item (click)=\"downloadLayerSource(layer, 'csv')\">\n              {{'CSV' | translate}}\n            </button>\n            <button mat-menu-item (click)=\"downloadLayerSource(layer, 'geojson')\">\n              {{'GeoJson' | translate}}\n            </button>\n          </mat-menu>\n        </div>\n\n        @if (displayLegendDetailToggle()) {\n          <div class=\"detail_button\" (click)=\"showDetail($event)\" (keyDown)=\"showDetail($event)\">\n            <mat-icon class=\"detail_icon\">{{ detail ? 'keyboard_arrow_up' : 'keyboard_arrow_down' }}</mat-icon>\n          </div>\n        }\n      </div>\n    </div>\n\n    <div [hidden]=\"!detail\" class=\"legend-wrapper\">\n      <arlas-legend-item [hidden]=\"!hasColorLegend()\" [legend]=\"colorLegend()\" [layer]=\"layer\"\n        [title]=\"'Fill:' | marker\" [colorPalette]=\"colorPalette\"></arlas-legend-item>\n\n      <arlas-legend-item [hidden]=\"!hasStrokeLegend()\" [legend]=\"strokeColorLegend()\" [layer]=\"layer\"\n        [title]=\"'Stroke:' | marker\" [colorPalette]=\"colorPalette\"></arlas-legend-item>\n\n      <arlas-legend-item [hidden]=\"!hasWidthLegend()\" #width_legend [legend]=\"widthLegend()\" [layer]=\"layer\"\n        [title]=\"'Width:' | marker\"></arlas-legend-item>\n\n      <arlas-legend-item [hidden]=\"!hasRadiusLegend()\" #radius_legend [legend]=\"radiusLegend()\" [layer]=\"layer\"\n        [title]=\"'Radius:' | marker\"></arlas-legend-item>\n    </div>\n  </div>\n", styles: ["@charset \"UTF-8\";.layer_name{font-size:14px}.layer_wrapper{border-top:.4px #eaeaea solid}.collection_color{width:4px;background-color:transparent;height:100%;position:absolute;cursor:pointer;z-index:1000}.layer_container{display:flex;position:relative;justify-content:space-between;padding-left:15px;padding-top:2.5px;padding-bottom:2.5px}.layer_icon_container{display:flex;padding-left:5px}.layer_detail{display:flex}.detail_button,.download_button{background-color:#fff;height:20px;width:20px;cursor:pointer}.detail_icon,.download_icon{color:#555;font-size:16px;width:20px;height:20px;display:flex;align-items:center;justify-content:center}.layer_icon{margin-right:5px;display:flex}.legend-wrapper{width:210px;padding-left:10px}\n"] }]
        }], ctorParameters: () => [{ type: i3.TranslateService }, { type: i2.ArlasColorService }, { type: LegendService }], propDecorators: { layer: [{
                type: Input
            }], collection: [{
                type: Input
            }], zoom: [{
                type: Input
            }], enabled: [{
                type: Input
            }], legendUpdater: [{
                type: Input
            }], visibilityUpdater: [{
                type: Input
            }], visibilityStatus: [{
                type: Output
            }], downloadSourceEmitter: [{
                type: Output
            }], lineWidthLegend: [{
                type: ViewChild,
                args: ['width_legend', { static: false }]
            }], circleRadiusLegend: [{
                type: ViewChild,
                args: ['radius_legend', { static: false }]
            }] } });
/**
 * draws the line width legend
 * @param svgNode SVG element on which we append the line using d3.
 * @param lineWidths List of {key, linewidth}
 * @param cLegend Color legend, to give the drawn legend lines the same color on the map
 * @param legendWidth The width that the svg will take to draw the legend
 * @param legendHeight The height that the svg will take to draw the legend
 */
function drawLineWidth(svgNode, lineWidths, cLegend, legendWidth, legendHeight) {
    const maxHeight = getMax(lineWidths);
    const xDomain = (scaleLinear()).range([0, legendWidth]);
    const xDomainExtent = [lineWidths[0].key, lineWidths[lineWidths.length - 1].key];
    xDomain.domain(xDomainExtent);
    const yDomain = scaleLinear().range([maxHeight, 0]);
    yDomain.domain([0, maxHeight]);
    const svg = select(svgNode).attr('width', legendWidth).attr('height', legendHeight);
    svg.selectAll('g').remove();
    const context = svg.append('g').attr('class', 'context');
    const ar = area$1()
        .curve(curveLinear)
        .x((d) => xDomain(d.key))
        .y0(maxHeight)
        .y1((d) => yDomain(d.value));
    const widthLineColor = getMiddleColor(cLegend);
    context.append('path')
        .datum(lineWidths)
        .style('fill', widthLineColor)
        .style('fill-opacity', 0.6)
        .style('stroke', widthLineColor)
        .style('stroke-opacity', 0.6)
        .style('stroke-width', 0.5)
        .attr('d', ar);
}
function getMiddleColor(colorLegend) {
    let color = '';
    if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.fix) {
        color = colorLegend.fixValue;
    }
    else if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.interpolated) {
        const iv = colorLegend.interpolatedValues;
        if (iv.length === 1 || iv.length === 2) {
            color = iv[0];
        }
        else if (iv.length >= 3) {
            color = iv[Math.trunc(iv.length / 2)];
        }
    }
    else if (colorLegend.type === PROPERTY_SELECTOR_SOURCE.manual || colorLegend.type === PROPERTY_SELECTOR_SOURCE.generated
        || colorLegend.type === PROPERTY_SELECTOR_SOURCE.provided) {
        const iv = colorLegend.manualValues;
        if (iv) {
            if (iv.size === 1) {
                color = iv.keys().next().value;
            }
            else if (iv.size >= 2) {
                color = Array.from(iv.values())[Math.trunc(Array.from(iv.keys()).length / 2)];
            }
        }
    }
    return color;
}
/**
 * draws the circle radius legend
 * @param svgNode SVG element on which we append the circles using d3.
 * @param circlesRadiuses List of {key, circleradius}
 * @param cLegend Color legend, to give the drawn legend circles the same color on the map
 * @param legendWidth The width that the svg will take to draw the legend
 * @param legendHeight The height that the svg will take to draw the legend
 */
function drawCircleSupportLine(svgNode, circlesRadiuses, cLegend, legendWidth, legendHeight) {
    const circleDiameters = [];
    circlesRadiuses.forEach(cr => circleDiameters.push({ key: cr.key, value: cr.value * 2 }));
    const maxHeight = getMax(circleDiameters);
    const firstRadius = circlesRadiuses[0].value;
    const lastRadius = circlesRadiuses[circlesRadiuses.length - 1].value;
    const xDomain = (scaleLinear()).range([0, legendWidth - firstRadius - lastRadius]);
    const xDomainExtent = [circleDiameters[0].key, circleDiameters[circleDiameters.length - 1].key];
    xDomain.domain(xDomainExtent);
    const yDomain = scaleLinear().range([maxHeight, 0]);
    yDomain.domain([0, maxHeight]);
    const svg = select(svgNode).attr('width', legendWidth).attr('height', legendHeight);
    svg.selectAll('g').remove();
    const context = svg.append('g').attr('class', 'context');
    const l = line()
        .x((d) => xDomain(d.key))
        .y((d) => yDomain(d.value));
    context.append('path')
        .datum(circleDiameters)
        .attr('fill', 'none')
        .attr('stroke', '#eaeaea')
        .attr('stroke-width', 0.8)
        .attr('transform', 'translate(' + firstRadius + ', 0)')
        .attr('d', l);
    context.append('g').append('line')
        .attr('x1', 0).attr('y1', maxHeight)
        .attr('x2', legendWidth - firstRadius - lastRadius).attr('y2', maxHeight)
        .attr('cx', 2).attr('cy', 2).attr('fill', 'none')
        .attr('stroke', '#eaeaea')
        .attr('stroke-width', 0.8)
        .attr('transform', 'translate(' + firstRadius + ', 0)');
    const circles = [circlesRadiuses[0], circlesRadiuses[circlesRadiuses.length - 1]];
    const circleColor = getMiddleColor(cLegend);
    context.append('g')
        .selectAll('dot').data(circles).enter().append('circle')
        .attr('r', (d) => d.value)
        .attr('cx', (d) => xDomain(d.key))
        .attr('cy', (d) => maxHeight - d.value)
        .attr('transform', 'translate(' + firstRadius + ', 0)')
        .style('fill', circleColor)
        .style('fill-opacity', 0.6)
        .style('stroke', circleColor)
        .style('stroke-width', 0.5);
}
function getMax(data) {
    return Math.max(...data.map(hd => +hd.value));
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetCollectionPipe {
    transform(value, layersMap) {
        let collection;
        if (layersMap?.get(value)?.metadata?.collection) {
            collection = layersMap.get(value).metadata.collection;
        }
        return collection;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionPipe, name: "getCollection" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'getCollection' }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
class ArlasMapComponent {
    constructor(drawService, basemapService, translate, mapFrameworkService, mapService) {
        this.drawService = drawService;
        this.basemapService = basemapService;
        this.translate = translate;
        this.mapFrameworkService = mapFrameworkService;
        this.mapService = mapService;
        /** Whether the legend is visible (open) or not.*/
        this.legendOpen = true;
        /** Used to clear geojson sources. */
        this.emptyData = {
            'type': 'FeatureCollection',
            'features': []
        };
        /** Whether the list of basemaps is shown. */
        this.showBasemapList = false;
        /** Visibility status of each visualisation set*. */
        this.visibilityStatus = new Map();
        this._onDestroy$ = new Subject();
        /** ANGULAR INPUTS */
        /** @description Html identifier given to the map container (it's a div ;))*/
        this.id = 'mapgl';
        /** @description An object with north,east,south,west properies which represent an offset in pixels */
        /** Origin is top-left and x-axis is west to east and y-axis north to south.*/
        this.offset = { north: 0, east: 0, south: 0, west: 0 };
        /** --- SCALE & COORDINATES */
        /** @description Whether the map scale is displayed. */
        this.displayScale = true;
        /** @description Maximim width in pixels that the map scale could take. */
        this.maxWidthScale = 100;
        /** @description Unit display for the map scale. */
        this.unitScale = 'metric';
        /** @description Whether to display the coordinates of the mouse while moving. */
        this.displayCurrentCoordinates = false;
        /** @description If true, the coordinates values are wrapped between -180 and 180. */
        this.wrapLatLng = true;
        /** @description List of available basemaps. */
        this.basemapStyles = new Array();
        /** --- INITIAL MAP VIEW : ZOOMs, CENTER, BOUNDS */
        /** @description Zoom of the map when it's initialized. */
        this.initZoom = 2;
        /** @description Max zoom of the map. */
        this.maxZoom = 22;
        /** @description Min zoom of the map. */
        this.minZoom = 0;
        /** @description Coordinates of the map's center when it's first loaded. */
        this.initCenter = [2.1972656250000004, 45.706179285330855];
        /** @description The padding added in the top-left and bottom-right corners of a map container that shouldn't be accounted */
        /** for when setting the view to fit bounds.*/
        this.fitBoundsOffSet = [0, 0];
        /**  @description Padding value applied around a fitBounds to fully show the area targeted. */
        this.fitBoundsPadding = 10;
        /** @description The maximum zoom level so that the bounds fit the map view. */
        this.fitBoundsMaxZoom = 22;
        /** @description Subject to which the component subscribes to redraw on the map the `data` of the given `source`. */
        this.redrawSource = new Subject();
        /** --- DRAW */
        /**  @description Options object for draw tools : https://github.com/mapbox/mapbox-gl-draw/blob/master/docs/API.md#options */
        this.drawOption = {};
        /** @description Features drawn at component start */
        this.drawData = ({ ...this.emptyData });
        /** @description Whether the draw tools are activated. */
        this.drawButtonEnabled = false;
        /** @description Whether the drawing buffer is activated */
        /** If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL(). Default: false */
        this.preserveDrawingBuffer = false;
        /** --- ATTRIBUTION */
        /** @description Position of the map attribution. */
        this.mapAttributionPosition = 'bottom-right';
        /** --- LEGEND AND VISUALISATIONS */
        /** @description Subject of [collection, [field, legendData]] map. The map subscribes to it to keep */
        /** the legend updated with the data displayed on the map. */
        this.legendUpdater = new Subject();
        /** @description Subject of [layerId, boolean] map. The map subscribes to it to keep */
        /** the legend updated with the visibility of the layer.*/
        this.visibilityUpdater = new Subject();
        /** ANGULAR OUTPUTS */
        /** @description Emits true after the map is loaded and all sources & layers are added. */
        this.onMapLoaded = new Subject();
        /** @description Emits the map extent when the browser tab is closed/refreshed. */
        this.onMapClosed = new EventEmitter();
        /**
         * @deprecated
         * @description  Emits the event of moving the map. */
        this.onMove = new EventEmitter();
        /** @description Emits the visible visualisation sets' names */
        this.visualisations = new EventEmitter();
        /** @description Emits the features that were clicked on. */
        this.onFeatureClick = new EventEmitter();
        /** @description Emits the features that were hovered. */
        this.onFeatureHover = new EventEmitter();
        /** @description Emits the geojson of all aois added to the map. */
        this.onAoiChanged = new EventEmitter();
        /** @description Emits the the dimensions of the polygon/bbox that is being drawn. */
        this.onAoiEdit = new EventEmitter();
        /** @description Emits an event when the basemap has been changed by the user. */
        this.onBasemapChanged = new Subject();
        /** @description Emits which layers are displayed on the map. */
        this.legendVisibiltyStatus = new Subject();
        /** @description  Notifies that the user wants to download the selected layer */
        this.downloadSourceEmitter = new Subject();
        this.ICONS_BASE_PATH = 'assets/icons/';
        this.basemapService.protomapBasemapAdded$.pipe(takeUntilDestroyed())
            .subscribe(() => this.reorderLayers());
    }
    ngAfterViewInit() {
        /** init values */
        if (!this.initCenter) {
            this.initCenter = [0, 0];
        }
        if (this.initZoom === undefined || this.initZoom === null) {
            this.initZoom = 3;
        }
        if (this.maxZoom === undefined || this.maxZoom === null) {
            this.maxZoom = 23;
        }
        this.minZoom = this.minZoom ?? 0;
        /** BASEMAPS */
        if (this.defaultBasemapStyle && typeof this.defaultBasemapStyle.styleFile === 'string') {
            this.defaultBasemapStyle.url = this.defaultBasemapStyle.styleFile;
        }
        this.basemapStyles.forEach(bm => {
            if (typeof bm.styleFile === 'string') {
                bm.url = (bm.styleFile);
            }
        });
        this.basemapService.setBasemaps(new ArlasBasemaps(this.defaultBasemapStyle, this.basemapStyles));
        this.basemapService.fetchSources$()
            .pipe(finalize(() => this.declareMap()))
            .subscribe();
    }
    ngOnChanges(changes) {
        if (this.map && this.map.getMapProvider() !== undefined) {
            if (changes['boundsToFit'] !== undefined) {
                const newBoundsToFit = changes['boundsToFit'].currentValue;
                this.map.fitBounds(newBoundsToFit, {
                    maxZoom: this.fitBoundsMaxZoom,
                    offset: this.fitBoundsOffSet
                });
            }
            if (changes['featureToHightLight'] !== undefined
                && changes['featureToHightLight'].currentValue !== changes['featureToHightLight'].previousValue) {
                const featureToHightLight = changes['featureToHightLight'].currentValue;
                this.highlightFeature(featureToHightLight);
            }
            if (changes['featuresToSelect'] !== undefined
                && changes['featuresToSelect'].currentValue !== changes['featuresToSelect'].previousValue) {
                const featuresToSelect = changes['featuresToSelect'].currentValue;
                this.selectFeatures(featuresToSelect);
            }
        }
    }
    /** If transformRequest' @Input was not set, set a default value : a function that maintains the same url */
    initTransformRequest() {
        if (!this.transformRequest) {
            this.transformRequest = this.mapFrameworkService.getInitTransformRequest();
        }
    }
    /** Zooms on clicked feature from map mouse event e.
     * @param mouseEvent Map mouse event provided by the map instance.
     */
    zoomOnClick(mouseEvent) {
        const zoom = this.map.getZoom();
        let newZoom;
        if (zoom >= 0 && zoom < 3) {
            newZoom = 4;
        }
        else if (zoom >= 3 && zoom < 5) {
            newZoom = 5;
        }
        else if (zoom >= 5 && zoom < 7) {
            newZoom = 7;
        }
        else if (zoom >= 7 && zoom < 10) {
            newZoom = 10;
        }
        else if (zoom >= 10 && zoom < 11) {
            newZoom = 11;
        }
        else {
            newZoom = 12;
        }
        this.mapFrameworkService.flyTo(mouseEvent.lngLat.lat, mouseEvent.lngLat.lng, newZoom, this.map);
    }
    /**
     * Queries all rendered features on the position that was clicked on, on a layer; and emits those features.
     * @param mapLayerMouseEvent Map mouse event provided by a layer instance.
     */
    queryRender(mapLayerMouseEvent) {
        const hasCrossOrDrawLayer = this.mapFrameworkService.queryFeatures(mapLayerMouseEvent, this.map, CROSS_LAYER_PREFIX);
        if (!this.drawService.isDrawingBbox && !this.drawService.isDrawingPolygon
            && !this.drawService.isDrawingCircle && !this.drawService.isInSimpleDrawMode && !hasCrossOrDrawLayer) {
            this.onFeatureClick.next({ features: mapLayerMouseEvent.features, point: [mapLayerMouseEvent.lngLat.lng, mapLayerMouseEvent.lngLat.lat] });
        }
    }
    /** @description Adds the custom icons given in the component's input */
    addIcons() {
        if (this.icons) {
            this.icons.forEach(icon => {
                const iconName = icon.path.split('.')[0];
                const iconPath = this.ICONS_BASE_PATH + icon.path;
                const iconErrorMessage = 'The icon "' + this.ICONS_BASE_PATH + icon.path + '" is not found';
                this.mapFrameworkService.addImage(iconName, iconPath, this.map, iconErrorMessage, { 'sdf': icon.recolorable });
            });
        }
        this.mapFrameworkService.addImage('rotate', this.ICONS_BASE_PATH + 'rotate/01.png', this.map, 'Rotate not found');
        this.mapFrameworkService.addImage('resize', this.ICONS_BASE_PATH + 'resize/01.png', this.map, 'Resize not found');
    }
    /**
     * @description Creates the map instance and adds the basemap, arlas data
     * and starts listening to arlas data changes and layers visibility updates.
     * It also starts emiting map moveend event.
     */
    declareMap() {
        this.initTransformRequest();
        const arlasMapOption = {
            container: this.id,
            style: this.basemapService.getInitStyle(this.basemapService.basemaps.getSelected()),
            center: this.initCenter,
            zoom: this.initZoom,
            maxZoom: this.maxZoom,
            minZoom: this.minZoom,
            renderWorldCopies: true,
            preserveDrawingBuffer: this.preserveDrawingBuffer,
            locale: {
                'NavigationControl.ZoomIn': this.translate.instant(ZOOM_IN),
                'NavigationControl.ZoomOut': this.translate.instant(ZOOM_OUT),
                'NavigationControl.ResetBearing': this.translate.instant(RESET_BEARING)
            },
            pitchWithRotate: false,
            transformRequest: this.transformRequest,
            attributionControl: false,
        };
        const mapProviderOptions = this.mapFrameworkService.buildMapProviderOption(arlasMapOption);
        const config = {
            displayCurrentCoordinates: this.displayCurrentCoordinates,
            fitBoundsPadding: this.fitBoundsPadding,
            margePanForLoad: this.margePanForLoad,
            margePanForTest: this.margePanForTest,
            offset: this.offset,
            wrapLatLng: this.wrapLatLng,
            maxWidthScale: this.maxWidthScale,
            unitScale: this.unitScale,
            mapProviderOptions,
            controls: {
                mapAttribution: {
                    enable: true,
                    position: this.mapAttributionPosition,
                    config: {
                        compact: false
                    }
                },
                scale: {
                    enable: this.displayScale
                },
                navigationControl: {
                    enable: true
                },
                pitchToggle: {
                    enable: true,
                    config: { bearing: -20, pitch: 70, minpitchzoom: 11 }
                }
            }
        };
        this.map = this.mapFrameworkService.createMap(config);
        fromEvent(window, 'beforeunload').subscribe(() => {
            this.onMapClosed.next(this.map.getMapExtend());
        });
        this.map.onCustomEvent('beforeOnLoadInit', () => {
            this.basemapService.declareProtomapProtocol(this.map);
            this.basemapService.addProtomapBasemap(this.map);
            this.addIcons();
            this.mapService.declareArlasDataSources(this.dataSources, this.emptyData, this.map);
            this.mapService.declareBasemapSources(this.mapSources, this.map);
            this.mapService.addArlasDataLayers(this.visualisationSetsConfig, this.mapLayers, this.map);
            this.listenToLayersEvents();
        });
        this.mapFrameworkService.onMapEvent('load', this.map, () => {
            if (this.mapLayers !== null) {
                this.visibilityUpdater.subscribe(visibilityStatus => {
                    this.mapService.updateVisibility(visibilityStatus, this.visualisationSetsConfig, this.map);
                });
            }
            this.onMapLoaded.next(true);
        });
        this.map.onMoveEnd(this.mapService.visualisationsSets).subscribe((moveResult => {
            this.onMove.next(moveResult);
        }));
        if (this.redrawSource) {
            this.redrawSource.pipe(takeUntil(this._onDestroy$)).subscribe(sd => {
                this.mapFrameworkService.setDataToGeojsonSource(this.mapFrameworkService.getSource(sd.source, this.map), {
                    'type': 'FeatureCollection',
                    'features': sd.data
                });
            });
        }
    }
    /**
     * @description Listens to events on mapLayers input (configured layers).
     */
    listenToLayersEvents() {
        /** Zooms on the clicked feature of the given layers. */
        this.mapLayers.events.zoomOnClick.forEach(layerId => {
            this.mapFrameworkService.onLayerEvent('click', this.map, layerId, (e) => this.zoomOnClick(e));
        });
        this.mapLayers.events.onHover.forEach(layerId => {
            /** Emits the hovered feature on mousemove. */
            this.mapFrameworkService.onLayerEvent('mousemove', this.map, layerId, (e) => this.onFeatureHover.next({ features: e.features, point: [e.lngLat.lng, e.lngLat.lat] }));
            /** Emits an empty object on mouse leaving a feature. */
            this.mapFrameworkService.onLayerEvent('mouseleave', this.map, layerId, (e) => this.onFeatureHover.next({}));
        });
        /** Emits the clicked on feature. */
        this.mapLayers.events.emitOnClick.forEach(layerId => {
            this.mapFrameworkService.onLayerEvent('click', this.map, layerId, (e) => this.queryRender(e));
        });
        const drawPolygonLayers = [
            'gl-draw-polygon-stroke-inactive',
            'gl-draw-polygon-stroke-active',
            'gl-draw-polygon-stroke-static'
        ].map(layer => ['.cold', '.hot']
            .map(id => layer.concat(id)))
            .reduce((p, ac) => ac.concat(p), []);
        /** Sets mouse cursor on drawn features */
        drawPolygonLayers.forEach(layerId => {
            this.mapFrameworkService.onLayerEvent('mousemove', this.map, layerId, (e) => this.mapFrameworkService.setMapCursor(this.map, 'pointer'));
            this.mapFrameworkService.onLayerEvent('mouseleave', this.map, layerId, (e) => {
                if (this.drawService.isDrawing()) {
                    this.mapFrameworkService.setMapCursor(this.map, 'crosshair');
                }
                else {
                    this.mapFrameworkService.setMapCursor(this.map, '');
                }
            });
        });
    }
    /** Sets the layers order according to the current order of `visualisationSetsConfig` list*/
    reorderLayers() {
        this.mapService.reorderLayers(this.visualisationSetsConfig, this.map);
    }
    /** @description Display the basemapswitcher */
    showBasemapSwitcher() {
        this.showBasemapList = true;
    }
    /** @description Emits event notifiying that the basemap has been changed */
    onChangeBasemapStyle() {
        this.onBasemapChanged.next(true);
    }
    /**
     * Updates the visibility status of the layer and emits that update.
     * @param visualisation visualisation set name
     * @param l layer id
     * @param visible whether the layer is enabled and visible in the visualisation set
     */
    emitLegendVisibility(visualisation, l, visible) {
        // Copy the map so the pipe updates the values
        this.visibilityStatus = new Map(this.visibilityStatus);
        this.visibilityStatus.set(visualisation + ARLAS_VSET + l, visible);
        this.legendVisibiltyStatus.next(this.visibilityStatus);
    }
    /**
     * @description Emits the visible visualisation set
     * @param visualisationName Name of the visualisation.
     */
    emitVisualisations(visualisationName) {
        const layers = this.mapService.updateLayoutVisibility(visualisationName, this.visualisationSetsConfig, this.map);
        this.visualisations.emit(layers);
        this.reorderLayers();
    }
    downloadLayerSource(downaload) {
        const downlodedSource = {
            layerId: downaload.layer.id,
            layerName: getLayerName(downaload.layer.id),
            collection: downaload.layer.metadata.collection,
            sourceName: downaload.layer.source,
            downloadType: downaload.downloadType
        };
        this.downloadSourceEmitter.next(downlodedSource);
    }
    /** puts the visualisation set list in the new order after dropping */
    drop(event) {
        moveItemInArray(this.visualisationSetsConfig, event.previousIndex, event.currentIndex);
        this.reorderLayers();
    }
    /** puts the layers list in the new order after dropping */
    dropLayer(event, visuName) {
        const layers = Array.from(this.mapService.findVisualisationSetLayer(visuName, this.visualisationSetsConfig));
        moveItemInArray(layers, event.previousIndex, event.currentIndex);
        this.mapService.setVisualisationSetLayers(visuName, layers, this.visualisationSetsConfig);
        this.reorderLayers();
    }
    hideBasemapSwitcher() {
        this.showBasemapList = false;
    }
    /**
     * Fit to given bounds. Options are for padding.
     * @param bounds Bounds of the map to fit to.
     */
    fitToPaddedBounds(bounds) {
        this.map.fitToPaddedBounds(bounds);
    }
    /**
     * Centers the map to the given latitude/longitude coordinates.
     * @param lngLat Latitude/longitude coordinates.
     */
    moveToCoordinates(lngLat) {
        this.map.setCenter(lngLat);
    }
    /** Highlights, in all data sources,the feature(s) having the given elementIdentifier */
    highlightFeature(featureToHightLight) {
        this.mapService.highlightFeature(this.mapLayers, this.map, featureToHightLight);
    }
    /** Selects, in all data sources,the feature(s) having the given elementIdentifier */
    selectFeatures(elementToSelect) {
        this.mapService.selectFeatures(this.mapLayers, this.map, elementToSelect);
    }
    /** Selects, in all data sources, all the features having the given elementIdentifiers and under the given collection.
     * @param features list of features identifiers.
     * @param collection data collection (metadata of the data source).
    */
    selectFeaturesByCollection(features, collection) {
        this.mapService.selectFeaturesByCollection(this.mapLayers, this.map, features, collection);
    }
    static getMapJsonSchema() {
        return mapJsonSchema;
    }
    /** Destroys all the components subscriptions. */
    ngOnDestroy() {
        if (this.map) {
            this.map.unsubscribeEvents();
        }
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    /** @description Enables bbox drawing mode.*/
    addGeoBox() {
        this.drawComponent.addGeoBox();
    }
    /**
     * @description Removes all the aois if none of them is selected. Otherwise it removes the selected one only
     */
    removeAois() {
        this.drawComponent.removeAois();
    }
    /** @description Deletes the selected drawn geometry. If no drawn geometry is selected, all geometries are deteleted */
    deleteSelectedItem() {
        this.drawComponent.deleteSelectedItem();
    }
    /**
     * @description Switches to a drawing mode of a DRAW_POLYGON, DRAW_CIRCLE or DRAW_RADIUS_CIRCLE.
     * @param mode Draw mode (DRAW_POLYGON, DRAW_CIRCLE or DRAW_RADIUS_CIRCLE). Default to DRAW_POLYGON
     * @param option Mapboxdraw option.
     */
    switchToDrawMode(mode, option) {
        this.drawComponent.switchToDrawMode(mode, option);
    }
    /**
     * @description Switches to direct_select mode.
     * @param option Mapboxdraw option.
     */
    switchToDirectSelectMode(option) {
        this.drawComponent.switchToDirectSelectMode(option);
    }
    /**
     * @description Switches to simple_select mode.
     * @param option Mapboxdraw option.
     */
    switchToEditMode() {
        this.drawComponent.switchToEditMode();
    }
    /**
     * @description Returns all the drawn polygons as wkt or geojson.
     * @param mode 'wkt' | 'geojson'
     * @returns Wkt string or Geojson object.
     */
    getAllPolygon(mode) {
        return this.drawComponent.getAllPolygon(mode);
    }
    /**
     * @description returns the selected polygon geometry in WKT or GeoJson given the mode
     * @param mode : 'wkt' | 'geojson'
     * @returns Wkt string or Geojson object.
     */
    getSelectedPolygon(mode) {
        return this.drawComponent.getSelectedPolygon(mode);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapComponent, deps: [{ token: MapboxAoiDrawService }, { token: BasemapService }, { token: i3.TranslateService }, { token: ArlasMapFrameworkService }, { token: AbstractArlasMapService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ArlasMapComponent, selector: "arlas-map", inputs: { id: "id", offset: "offset", mapLayers: "mapLayers", displayScale: "displayScale", maxWidthScale: "maxWidthScale", unitScale: "unitScale", displayCurrentCoordinates: "displayCurrentCoordinates", wrapLatLng: "wrapLatLng", defaultBasemapStyle: "defaultBasemapStyle", basemapStyles: "basemapStyles", initZoom: "initZoom", maxZoom: "maxZoom", minZoom: "minZoom", initCenter: "initCenter", boundsToFit: "boundsToFit", fitBoundsOffSet: "fitBoundsOffSet", fitBoundsPadding: "fitBoundsPadding", fitBoundsMaxZoom: "fitBoundsMaxZoom", margePanForLoad: "margePanForLoad", margePanForTest: "margePanForTest", transformRequest: "transformRequest", featureToHightLight: "featureToHightLight", featuresToSelect: "featuresToSelect", mapSources: "mapSources", redrawSource: "redrawSource", dataSources: "dataSources", drawOption: "drawOption", drawData: "drawData", drawButtonEnabled: "drawButtonEnabled", drawPolygonVerticesLimit: "drawPolygonVerticesLimit", preserveDrawingBuffer: "preserveDrawingBuffer", mapAttributionPosition: "mapAttributionPosition", icons: "icons", legendUpdater: "legendUpdater", visibilityUpdater: "visibilityUpdater", visualisationSetsConfig: "visualisationSetsConfig" }, outputs: { onMapLoaded: "onMapLoaded", onMapClosed: "onMapClosed", onMove: "onMove", visualisations: "visualisations", onFeatureClick: "onFeatureClick", onFeatureHover: "onFeatureHover", onAoiChanged: "onAoiChanged", onAoiEdit: "onAoiEdit", onBasemapChanged: "onBasemapChanged", legendVisibiltyStatus: "legendVisibiltyStatus", downloadSourceEmitter: "downloadSourceEmitter" }, viewQueries: [{ propertyName: "drawComponent", first: true, predicate: ["drawComponent"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div id=\"{{id}}\" class=\"map__container\">\n  <div class=\"map__visu-list\" *ngIf=\"visualisationSetsConfig?.length > 0\">\n    <div class=\"map__legend-button\" [matTooltipPosition]=\"'left'\" matTooltip=\"{{'Manage layers' | translate}}\">\n      <mat-icon (click)=\"legendOpen=!legendOpen\" (keyDown)=\"legendOpen=!legendOpen\">layers</mat-icon>\n    </div>\n    <div [hidden]=\"!legendOpen\" class=\"map__visu-list--container\" cdkDropList\n      (cdkDropListDropped)=\"drop($event)\">\n      <div cdkDrag class=\"map__visu-item\" *ngFor=\"let visu of visualisationSetsConfig\">\n        <div cdkDragHandle class=\"map__visu-title\">\n          <span class=\"map__visu-title-text\" [class.map__visu-title-text--disabled]=\"!visu.enabled\">\n            {{visu.name | translate}}</span>\n          <mat-slide-toggle [checked]=\"visu.enabled\" (change)=\"emitVisualisations(visu.name)\"\n            [matTooltip]=\"'show_layers' | translate\" [hideIcon]=\"true\"></mat-slide-toggle>\n        </div>\n        <div class=\"map__visu-content\" cdkDropList (cdkDropListDropped)=\"dropLayer($event, visu.name)\">\n          <div cdkDrag *ngFor=\"let l of visu.layers\" class=\"map__visu-layer\"\n            [class.cdk-visually-hidden]=\"((visu.name + ':arlas_vset:' + l) | getValue:visibilityStatus) !== true\">\n            <div cdkDragHandle class=\"map__visu-layer-drag\">\n              <mat-icon>drag_indicator</mat-icon>\n            </div>\n            <arlas-legend [collection]=\"l | getCollection: mapService.layersMap \" [enabled]=\"visu.enabled\"\n              [layer]=\"l | getValue: mapService.layersMap \" [zoom]=\"map?.zoom\"\n              (visibilityStatus)=\"emitLegendVisibility(visu.name, l, $event)\" [legendUpdater]=\"legendUpdater\"\n              [visibilityUpdater]=\"visibilityUpdater\"\n              (downloadSourceEmitter)=\"downloadLayerSource($event)\"></arlas-legend>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<arlas-coordinates *ngIf=\"displayCurrentCoordinates\" [currentLat]=\"map?.currentLat\" [currentLng]=\"map?.currentLng\"\n  (moveToCoordinates$)=\"moveToCoordinates($event)\"></arlas-coordinates>\n\n<arlas-basemap *ngIf=\"showBasemapList\" [mapSources]=\"mapSources\" [map]=\"map\" (mouseleave)=\"hideBasemapSwitcher()\"\n  (basemapChanged)=\"onChangeBasemapStyle()\"></arlas-basemap>\n\n\n<arlas-draw #drawComponent *ngIf=\"map\" [map]=\"map\" [emptyData]=\"emptyData\" [drawData]=\"drawData\"\n  [drawButtonEnabled]=\"drawButtonEnabled\" [drawOption]=\"drawOption\"\n  [drawPolygonVerticesLimit]=\"drawPolygonVerticesLimit\" [preserveDrawingBuffer]=\"preserveDrawingBuffer\"\n  (onAoiChanged)=\"onAoiChanged.emit($event)\"\n  (onAoiEdit)=\"onAoiEdit.emit($event)\"></arlas-draw>", styles: ["@charset \"UTF-8\";.map__container{width:100%;height:100%;position:absolute!important}.map__visu-list{position:absolute;display:flex;flex-direction:column;top:220px;right:7px;z-index:1;background:transparent;flex-wrap:wrap-reverse}.map__legend-button{cursor:pointer;margin-bottom:4px;border-radius:3px;background-color:#fff;width:30px;height:30px;padding:3px}.map__legend-button:hover{background-color:#f5f5f5}.map__visu-list--container{padding:1px 1px 3px;border-radius:2px;max-height:calc(100vh - 415px);overflow-y:auto;overflow-x:hidden}.map__visu-item{margin:1px;padding:unset;padding-right:3px;width:225px;border:.8px solid #ddd;background:#fff;border-radius:3px}.map__visu-title{display:flex;justify-content:space-between;padding:1px 5px 1px 0;font-weight:550;font-size:14px;cursor:grab;--mdc-switch-track-width: 24px;--mdc-switch-track-height: 5px;--mdc-switch-handle-width: 12px;--mdc-switch-state-layer-size: 0;--mat-switch-selected-handle-horizontal-margin: 0 1px}.map__visu-title:hover .map__visu-toggle .map__visu-drag{visibility:visible}.map__visu-title .mdc-switch__handle{--mat-switch-unselected-handle-size: 12px;--mat-switch-selected-handle-size: 12px;--mat-switch-pressed-handle-size: 12px;--mdc-switch-unselected-handle-color: lightgrey;--mdc-switch-unselected-focus-handle-color: lightgrey;--mdc-switch-unselected-hover-handle-color: lightgrey;--mdc-switch-unselected-pressed-handle-color: lightgrey}.map__visu-title-text{color:#333;padding:3px}.map__visu-title-text--disabled{color:#bbb}.map__visu-content{max-height:300px;overflow-y:auto;overflow-x:hidden}.map__visu-layer{background-color:#fff;position:relative;overflow:hidden}.map__visu-layer-drag{position:absolute;top:5px;left:0;display:flex;padding-left:3px}.map__visu-layer-drag mat-icon{font-size:18px;width:18px;height:18px;color:#999}.map__visu-layer:hover .map__visu-layer-drag{cursor:grab;z-index:2}.map__visu-layer:hover .map__visu-layer-drag mat-icon{color:#444}.draw-tooltip--hide{display:none}.draw-tooltip--show{display:block;position:fixed;overflow:hidden;font-size:.8em;background-color:#fff;border-radius:2px;padding:2px;box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f}::-webkit-scrollbar{width:3px!important;height:4px!important;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}.cdk-drag-preview{box-sizing:border-box;font-size:.75em;border-radius:3px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.cdk-drag-preview .map__visu-layer .map__visu-layer-drag mat-icon{color:#444}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.draw-control-disabled{display:none}\n"], dependencies: [{ kind: "component", type: i6$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i7$1.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["name", "id", "labelPosition", "aria-label", "aria-labelledby", "aria-describedby", "required", "color", "disabled", "disableRipple", "tabIndex", "checked", "hideIcon", "disabledInteractive"], outputs: ["change", "toggleChange"], exportAs: ["matSlideToggle"] }, { kind: "directive", type: i5$1.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "directive", type: i9$1.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep", "cdkDropListElementContainer"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { kind: "directive", type: i9$1.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer", "cdkDragScale"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { kind: "directive", type: i9$1.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: CoordinatesComponent, selector: "arlas-coordinates", inputs: ["currentLat", "currentLng"], outputs: ["moveToCoordinates$"] }, { kind: "component", type: BasemapComponent, selector: "arlas-basemap", inputs: ["map", "mapSources"], outputs: ["basemapChanged", "blur"] }, { kind: "component", type: LegendComponent, selector: "arlas-legend", inputs: ["layer", "collection", "zoom", "enabled", "legendUpdater", "visibilityUpdater"], outputs: ["visibilityStatus", "downloadSourceEmitter"] }, { kind: "component", type: ArlasDrawComponent, selector: "arlas-draw", inputs: ["map", "emptyData", "drawOption", "drawData", "drawButtonEnabled", "drawPolygonVerticesLimit", "preserveDrawingBuffer"], outputs: ["onAoiChanged", "onAoiEdit"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }, { kind: "pipe", type: i2.GetValuePipe, name: "getValue" }, { kind: "pipe", type: GetCollectionPipe, name: "getCollection" }], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map', encapsulation: ViewEncapsulation.None, template: "<div id=\"{{id}}\" class=\"map__container\">\n  <div class=\"map__visu-list\" *ngIf=\"visualisationSetsConfig?.length > 0\">\n    <div class=\"map__legend-button\" [matTooltipPosition]=\"'left'\" matTooltip=\"{{'Manage layers' | translate}}\">\n      <mat-icon (click)=\"legendOpen=!legendOpen\" (keyDown)=\"legendOpen=!legendOpen\">layers</mat-icon>\n    </div>\n    <div [hidden]=\"!legendOpen\" class=\"map__visu-list--container\" cdkDropList\n      (cdkDropListDropped)=\"drop($event)\">\n      <div cdkDrag class=\"map__visu-item\" *ngFor=\"let visu of visualisationSetsConfig\">\n        <div cdkDragHandle class=\"map__visu-title\">\n          <span class=\"map__visu-title-text\" [class.map__visu-title-text--disabled]=\"!visu.enabled\">\n            {{visu.name | translate}}</span>\n          <mat-slide-toggle [checked]=\"visu.enabled\" (change)=\"emitVisualisations(visu.name)\"\n            [matTooltip]=\"'show_layers' | translate\" [hideIcon]=\"true\"></mat-slide-toggle>\n        </div>\n        <div class=\"map__visu-content\" cdkDropList (cdkDropListDropped)=\"dropLayer($event, visu.name)\">\n          <div cdkDrag *ngFor=\"let l of visu.layers\" class=\"map__visu-layer\"\n            [class.cdk-visually-hidden]=\"((visu.name + ':arlas_vset:' + l) | getValue:visibilityStatus) !== true\">\n            <div cdkDragHandle class=\"map__visu-layer-drag\">\n              <mat-icon>drag_indicator</mat-icon>\n            </div>\n            <arlas-legend [collection]=\"l | getCollection: mapService.layersMap \" [enabled]=\"visu.enabled\"\n              [layer]=\"l | getValue: mapService.layersMap \" [zoom]=\"map?.zoom\"\n              (visibilityStatus)=\"emitLegendVisibility(visu.name, l, $event)\" [legendUpdater]=\"legendUpdater\"\n              [visibilityUpdater]=\"visibilityUpdater\"\n              (downloadSourceEmitter)=\"downloadLayerSource($event)\"></arlas-legend>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<arlas-coordinates *ngIf=\"displayCurrentCoordinates\" [currentLat]=\"map?.currentLat\" [currentLng]=\"map?.currentLng\"\n  (moveToCoordinates$)=\"moveToCoordinates($event)\"></arlas-coordinates>\n\n<arlas-basemap *ngIf=\"showBasemapList\" [mapSources]=\"mapSources\" [map]=\"map\" (mouseleave)=\"hideBasemapSwitcher()\"\n  (basemapChanged)=\"onChangeBasemapStyle()\"></arlas-basemap>\n\n\n<arlas-draw #drawComponent *ngIf=\"map\" [map]=\"map\" [emptyData]=\"emptyData\" [drawData]=\"drawData\"\n  [drawButtonEnabled]=\"drawButtonEnabled\" [drawOption]=\"drawOption\"\n  [drawPolygonVerticesLimit]=\"drawPolygonVerticesLimit\" [preserveDrawingBuffer]=\"preserveDrawingBuffer\"\n  (onAoiChanged)=\"onAoiChanged.emit($event)\"\n  (onAoiEdit)=\"onAoiEdit.emit($event)\"></arlas-draw>", styles: ["@charset \"UTF-8\";.map__container{width:100%;height:100%;position:absolute!important}.map__visu-list{position:absolute;display:flex;flex-direction:column;top:220px;right:7px;z-index:1;background:transparent;flex-wrap:wrap-reverse}.map__legend-button{cursor:pointer;margin-bottom:4px;border-radius:3px;background-color:#fff;width:30px;height:30px;padding:3px}.map__legend-button:hover{background-color:#f5f5f5}.map__visu-list--container{padding:1px 1px 3px;border-radius:2px;max-height:calc(100vh - 415px);overflow-y:auto;overflow-x:hidden}.map__visu-item{margin:1px;padding:unset;padding-right:3px;width:225px;border:.8px solid #ddd;background:#fff;border-radius:3px}.map__visu-title{display:flex;justify-content:space-between;padding:1px 5px 1px 0;font-weight:550;font-size:14px;cursor:grab;--mdc-switch-track-width: 24px;--mdc-switch-track-height: 5px;--mdc-switch-handle-width: 12px;--mdc-switch-state-layer-size: 0;--mat-switch-selected-handle-horizontal-margin: 0 1px}.map__visu-title:hover .map__visu-toggle .map__visu-drag{visibility:visible}.map__visu-title .mdc-switch__handle{--mat-switch-unselected-handle-size: 12px;--mat-switch-selected-handle-size: 12px;--mat-switch-pressed-handle-size: 12px;--mdc-switch-unselected-handle-color: lightgrey;--mdc-switch-unselected-focus-handle-color: lightgrey;--mdc-switch-unselected-hover-handle-color: lightgrey;--mdc-switch-unselected-pressed-handle-color: lightgrey}.map__visu-title-text{color:#333;padding:3px}.map__visu-title-text--disabled{color:#bbb}.map__visu-content{max-height:300px;overflow-y:auto;overflow-x:hidden}.map__visu-layer{background-color:#fff;position:relative;overflow:hidden}.map__visu-layer-drag{position:absolute;top:5px;left:0;display:flex;padding-left:3px}.map__visu-layer-drag mat-icon{font-size:18px;width:18px;height:18px;color:#999}.map__visu-layer:hover .map__visu-layer-drag{cursor:grab;z-index:2}.map__visu-layer:hover .map__visu-layer-drag mat-icon{color:#444}.draw-tooltip--hide{display:none}.draw-tooltip--show{display:block;position:fixed;overflow:hidden;font-size:.8em;background-color:#fff;border-radius:2px;padding:2px;box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f}::-webkit-scrollbar{width:3px!important;height:4px!important;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}.cdk-drag-preview{box-sizing:border-box;font-size:.75em;border-radius:3px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.cdk-drag-preview .map__visu-layer .map__visu-layer-drag mat-icon{color:#444}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.draw-control-disabled{display:none}\n"] }]
        }], ctorParameters: () => [{ type: MapboxAoiDrawService }, { type: BasemapService }, { type: i3.TranslateService }, { type: ArlasMapFrameworkService }, { type: AbstractArlasMapService }], propDecorators: { drawComponent: [{
                type: ViewChild,
                args: ['drawComponent', { static: false }]
            }], id: [{
                type: Input
            }], offset: [{
                type: Input
            }], mapLayers: [{
                type: Input
            }], displayScale: [{
                type: Input
            }], maxWidthScale: [{
                type: Input
            }], unitScale: [{
                type: Input
            }], displayCurrentCoordinates: [{
                type: Input
            }], wrapLatLng: [{
                type: Input
            }], defaultBasemapStyle: [{
                type: Input
            }], basemapStyles: [{
                type: Input
            }], initZoom: [{
                type: Input
            }], maxZoom: [{
                type: Input
            }], minZoom: [{
                type: Input
            }], initCenter: [{
                type: Input
            }], boundsToFit: [{
                type: Input
            }], fitBoundsOffSet: [{
                type: Input
            }], fitBoundsPadding: [{
                type: Input
            }], fitBoundsMaxZoom: [{
                type: Input
            }], margePanForLoad: [{
                type: Input
            }], margePanForTest: [{
                type: Input
            }], transformRequest: [{
                type: Input
            }], featureToHightLight: [{
                type: Input
            }], featuresToSelect: [{
                type: Input
            }], mapSources: [{
                type: Input
            }], redrawSource: [{
                type: Input
            }], dataSources: [{
                type: Input
            }], drawOption: [{
                type: Input
            }], drawData: [{
                type: Input
            }], drawButtonEnabled: [{
                type: Input
            }], drawPolygonVerticesLimit: [{
                type: Input
            }], preserveDrawingBuffer: [{
                type: Input
            }], mapAttributionPosition: [{
                type: Input
            }], icons: [{
                type: Input
            }], legendUpdater: [{
                type: Input
            }], visibilityUpdater: [{
                type: Input
            }], visualisationSetsConfig: [{
                type: Input
            }], onMapLoaded: [{
                type: Output
            }], onMapClosed: [{
                type: Output
            }], onMove: [{
                type: Output
            }], visualisations: [{
                type: Output
            }], onFeatureClick: [{
                type: Output
            }], onFeatureHover: [{
                type: Output
            }], onAoiChanged: [{
                type: Output
            }], onAoiEdit: [{
                type: Output
            }], onBasemapChanged: [{
                type: Output
            }], legendVisibiltyStatus: [{
                type: Output
            }], downloadSourceEmitter: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const gpsi = gpsi_.default;
const shp = shp_.default;
const extent = extent_.default;
class MapImportDialogComponent {
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
        this.displayError = false;
        this.isRunning = false;
        this.fitResult = false;
        this.wktContent = '';
        this.SHP = marker('shp');
        this.KML = marker('kml');
        this.WKT = marker('wkt');
        this.GEOJSON = marker('geojson');
        this.file = new Subject();
        this.importRun = new Subject();
        this.fitResult = data.defaultFitResult ?? false;
        this.allowedImportType = this.data.allowedImportType.filter(t => [this.SHP, this.KML, this.WKT, this.GEOJSON].includes(t));
        if (this.allowedImportType.indexOf(this.SHP) > -1) {
            this.importType = this.SHP;
        }
        else if (this.allowedImportType.indexOf(this.KML) > -1) {
            this.importType = this.KML;
        }
        else if (this.allowedImportType.indexOf(this.WKT) > -1) {
            this.importType = this.WKT;
        }
        else {
            this.importType = this.GEOJSON;
        }
        this.changeType();
    }
    onFileChange(files) {
        this.file.next(files.item(0));
        this.currentFile = files.item(0);
        this.displayError = false;
    }
    import() {
        this.importRun.next({ type: this.importType, fitResult: this.fitResult, wktContent: this.wktContent });
    }
    onTextChange() { }
    changeType() {
        if (this.importType === this.SHP) {
            this.allowedFileExtension = '.zip';
        }
        else if (this.importType === this.KML) {
            this.allowedFileExtension = '.kml,.kmz';
        }
        else if (this.importType === this.GEOJSON) {
            this.allowedFileExtension = '.json,.geojson';
        }
    }
    onCancel() {
        this.dialogRef.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportDialogComponent, deps: [{ token: i1.MatDialogRef }, { token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapImportDialogComponent, selector: "arlas-map-import-dialog", outputs: { file: "file", importRun: "importRun" }, viewQueries: [{ propertyName: "fileInput", first: true, predicate: ["fileInput"], descendants: true }], ngImport: i0, template: "<h1 mat-dialog-title class=\"mapgl-import-title\">{{ 'Import file' | translate}}</h1>\n<div mat-dialog-content class=\"mapgl-import-body\">\n  <mat-radio-group class=\"mapgl-import-radio-group\" [(ngModel)]=\"importType\" (change)=\"changeType()\">\n    <mat-radio-button *ngFor=\"let type of allowedImportType\" [value]=\"type\" class=\"mapgl-import-radio-button\">\n      {{ type | translate }}\n    </mat-radio-button>\n  </mat-radio-group>\n\n  <input *ngIf=\"importType !== WKT\" type=\"file\" class=\"mapgl-import-upload\" #fileInput accept=\"{{allowedFileExtension}}\" (change)=\"onFileChange($event.target.files)\">\n  <textarea *ngIf=\"importType === WKT\" class=\"mapgl-import-text-area\" [(ngModel)]=\"wktContent\" placeholder=\"{{'Paste your WKT' | translate}}\" (change)=\"onTextChange()\"></textarea>\n\n  <div class=\"mapgl-import-zoom\">\n    <mat-checkbox [(ngModel)]=\"fitResult\">{{ 'Zoom to result' | translate}}</mat-checkbox>\n  </div>\n  <div *ngIf=\"displayError\" class=\"mapgl-import-error\">\n    {{ errorMessage | translate}} <ng-container *ngIf=\"errorThreshold !== ''\"> - ({{'Max:' | translate }} {{errorThreshold}})</ng-container>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-import-actions\">\n  <button mat-button (click)=\"onCancel()\">{{ 'Cancel' | translate}}</button>\n  <button mat-button [disabled]=\"((importType === SHP || importType === KML || importType === GEOJSON) && !currentFile) || isRunning || (importType === WKT && wktContent === '')\" (click)=\"import()\">{{ 'Import' | translate}}</button>\n  <mat-progress-spinner *ngIf=\"isRunning\" [color]=\"'accent'\" [diameter]=\"40\" [mode]=\"'indeterminate'\">\n  </mat-progress-spinner>\n</div>\n", styles: ["@charset \"UTF-8\";::ng-deep .map-import-dialog{--mdc-dialog-subhead-size: 20px;--mdc-dialog-subhead-tracking: 0;--mat-dialog-with-actions-content-padding: 0}::ng-deep .map-import-dialog .mdc-dialog__surface{padding:12px 24px}::ng-deep .map-import-dialog .mat-mdc-dialog-content{padding:0}.mapgl-import-body{min-width:500px;display:flex;flex-direction:column}.mapgl-import-zoom{display:flex;align-content:center;align-items:center;height:60px}.mapgl-import-error{color:#f44336;font-size:75%}.mapgl-import-upload{padding-left:10px;padding-top:10px}.mapgl-import-upload:focus{outline:none}.mapgl-import-radio-button{padding:10px}.mapgl-import-text-area{box-sizing:border-box;width:100%;height:200px;resize:vertical}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i8.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "component", type: i5$3.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "disabledInteractive", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "directive", type: i1.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i1.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "component", type: i6$3.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "directive", type: i7$2.MatRadioGroup, selector: "mat-radio-group", inputs: ["color", "name", "labelPosition", "value", "selected", "disabled", "required", "disabledInteractive"], outputs: ["change"], exportAs: ["matRadioGroup"] }, { kind: "component", type: i7$2.MatRadioButton, selector: "mat-radio-button", inputs: ["id", "name", "aria-label", "aria-labelledby", "aria-describedby", "disableRipple", "tabIndex", "checked", "value", "labelPosition", "disabled", "required", "color", "disabledInteractive"], outputs: ["change"], exportAs: ["matRadioButton"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-import-dialog', template: "<h1 mat-dialog-title class=\"mapgl-import-title\">{{ 'Import file' | translate}}</h1>\n<div mat-dialog-content class=\"mapgl-import-body\">\n  <mat-radio-group class=\"mapgl-import-radio-group\" [(ngModel)]=\"importType\" (change)=\"changeType()\">\n    <mat-radio-button *ngFor=\"let type of allowedImportType\" [value]=\"type\" class=\"mapgl-import-radio-button\">\n      {{ type | translate }}\n    </mat-radio-button>\n  </mat-radio-group>\n\n  <input *ngIf=\"importType !== WKT\" type=\"file\" class=\"mapgl-import-upload\" #fileInput accept=\"{{allowedFileExtension}}\" (change)=\"onFileChange($event.target.files)\">\n  <textarea *ngIf=\"importType === WKT\" class=\"mapgl-import-text-area\" [(ngModel)]=\"wktContent\" placeholder=\"{{'Paste your WKT' | translate}}\" (change)=\"onTextChange()\"></textarea>\n\n  <div class=\"mapgl-import-zoom\">\n    <mat-checkbox [(ngModel)]=\"fitResult\">{{ 'Zoom to result' | translate}}</mat-checkbox>\n  </div>\n  <div *ngIf=\"displayError\" class=\"mapgl-import-error\">\n    {{ errorMessage | translate}} <ng-container *ngIf=\"errorThreshold !== ''\"> - ({{'Max:' | translate }} {{errorThreshold}})</ng-container>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-import-actions\">\n  <button mat-button (click)=\"onCancel()\">{{ 'Cancel' | translate}}</button>\n  <button mat-button [disabled]=\"((importType === SHP || importType === KML || importType === GEOJSON) && !currentFile) || isRunning || (importType === WKT && wktContent === '')\" (click)=\"import()\">{{ 'Import' | translate}}</button>\n  <mat-progress-spinner *ngIf=\"isRunning\" [color]=\"'accent'\" [diameter]=\"40\" [mode]=\"'indeterminate'\">\n  </mat-progress-spinner>\n</div>\n", styles: ["@charset \"UTF-8\";::ng-deep .map-import-dialog{--mdc-dialog-subhead-size: 20px;--mdc-dialog-subhead-tracking: 0;--mat-dialog-with-actions-content-padding: 0}::ng-deep .map-import-dialog .mdc-dialog__surface{padding:12px 24px}::ng-deep .map-import-dialog .mat-mdc-dialog-content{padding:0}.mapgl-import-body{min-width:500px;display:flex;flex-direction:column}.mapgl-import-zoom{display:flex;align-content:center;align-items:center;height:60px}.mapgl-import-error{color:#f44336;font-size:75%}.mapgl-import-upload{padding-left:10px;padding-top:10px}.mapgl-import-upload:focus{outline:none}.mapgl-import-radio-button{padding:10px}.mapgl-import-text-area{box-sizing:border-box;width:100%;height:200px;resize:vertical}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialogRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }], propDecorators: { file: [{
                type: Output
            }], importRun: [{
                type: Output
            }], fileInput: [{
                type: ViewChild,
                args: ['fileInput', { static: false }]
            }] } });
const SIMPLE_GEOMETRY_OBJECT = ['Polygon', 'Point', 'LineString'];
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
class MapImportComponent {
    constructor(dialog, mapService) {
        this.dialog = dialog;
        this.mapService = mapService;
        this.SHP = 'shp';
        this.KML = 'kml';
        this.WKT = 'wkt';
        this.GEOJSON = 'geojson';
        this.SELF_INTERSECT = marker('Geometry is not valid due to self-intersection');
        this.PARSING_ISSUE = marker('Problem parsing input file');
        this.FILE_TOO_LARGE = marker('File is too large');
        this.GEOMETRY_INVALID = marker('Geometry is not valid');
        this.TOO_MANY_VERTICES = marker('Too many vertices in a polygon');
        this.TOO_MANY_FEATURES = marker('Too many features');
        this.TIMEOUT = marker('Timeout');
        this.tooManyVertex = false;
        this.fitResult = false;
        this.SOURCE_NAME_POLYGON_LABEL = 'polygon_label';
        this.emptyData = {
            'type': 'FeatureCollection',
            'features': []
        };
        this.featureIndex = 0;
        this.maxLoadingTime = 20000;
        this.allowedImportType = [this.SHP, this.KML, this.WKT, this.GEOJSON];
        this.allowedGeometryObjectType = ['Polygon'];
        this.imported = new Subject();
        this.error = new Subject();
    }
    promiseTimeout(ms, promise) {
        // Create a promise that rejects in <ms> milliseconds
        const timeout = new Promise((resolve, reject) => {
            const id = setTimeout(() => {
                clearTimeout(id);
                reject(new Error(this.TIMEOUT));
            }, ms);
        });
        // Returns a race between our timeout and the passed in promise
        return Promise.race([
            promise,
            timeout
        ]);
    }
    buildAllowedGeometryForImportType(importType) {
        this._currentAllowedGeom = [];
        this.allowedGeometryObjectType.forEach(allowed => {
            this._currentAllowedGeom = this._currentAllowedGeom.concat(this.getAllowedGeom(allowed));
        });
        if (importType === this.KML) {
            this._currentAllowedGeom.push('GeometryCollection', 'MultiGeometry');
        }
        else if (importType === this.WKT) {
            this._currentAllowedGeom.push('GeometryCollection');
        }
    }
    getAllowedGeom(allowed) {
        if (allowed === 'Polygon') {
            return ['Polygon', 'MultiPolygon'];
        }
        if (allowed === 'Point') {
            return ['Point', 'MultiPoint'];
        }
    }
    openDialog(defaultFitResult) {
        this.dialogRef = this.dialog.open(MapImportDialogComponent, { data: { allowedImportType: this.allowedImportType, defaultFitResult }, panelClass: 'map-import-dialog' });
        this.dialogRef.componentInstance.file.subscribe((file) => {
            this.currentFile = file;
        });
        this.dialogRef.componentInstance.importRun.subscribe(importOptions => {
            this.fitResult = importOptions.fitResult;
            this.buildAllowedGeometryForImportType(importOptions.type);
            this.import(importOptions.type, importOptions.wktContent);
        });
    }
    import(importType, content) {
        this.dialogRef.componentInstance.isRunning = true;
        this.tooManyVertex = false;
        this.jszip = new JSZip();
        let processPromise;
        if (importType === this.SHP) {
            processPromise = this.processAllShape();
        }
        else if (importType === this.KML) {
            processPromise = this.processAllKml();
        }
        else if (importType === this.WKT) {
            processPromise = this.processWKT(content);
        }
        else if (importType === this.GEOJSON) {
            processPromise = this.processJson();
        }
        this.promiseTimeout(this.maxLoadingTime, processPromise).catch(error => {
            if (importType !== this.WKT) {
                this.reader.abort();
            }
            this.throwError(error);
        });
    }
    buildFeature(geom, feature, geometryType, bbox) {
        const f = {
            type: 'Feature',
            geometry: {
                coordinates: geom,
                type: geometryType ?? geom.type
            },
            properties: feature.properties
        };
        if (bbox) {
            f.geometry['bbox'] = feature.geometry.bbox;
        }
        return f;
    }
    handleSimpleGeometry(feature, centroids, importedGeojson) {
        // avoid self intersect control for point
        if (feature.geometry.type === 'Point' || gpsi(feature).geometry.coordinates.length === 0) {
            this.addFeature(feature, centroids, importedGeojson, ++this.featureIndex);
        }
        else {
            throw new Error('Geometry is not valid due to self-intersection');
        }
    }
    handleMultiGeometry(feature, centroids, importedGeojson) {
        // Create a new Polygon feature for each polygon in the MultiPolygon
        // All properties of the MultiPolygon are copied in each feature created
        const geomType = (feature.geometry.type === 'MultiPolygon') ? 'Polygon' : 'Point';
        feature.geometry.coordinates.forEach(geom => {
            const newFeature = this.buildFeature(geom, feature, geomType, true);
            this.handleSimpleGeometry(newFeature, centroids, importedGeojson);
        });
    }
    handleGeometryCollection(feature, centroids, importedGeojson) {
        // Create a new Polygon feature for each polygon in the MultiPolygon
        // All properties of the MultiPolygon are copied in each feature created
        const simpleGeometry = this._currentAllowedGeom.filter(g => SIMPLE_GEOMETRY_OBJECT.includes(g));
        feature.geometry.geometries.filter(geom => simpleGeometry.includes(geom.type)).forEach(geom => {
            const newFeature = this.buildFeature(geom, feature);
            this.handleSimpleGeometry(newFeature, centroids, importedGeojson);
        });
    }
    handleFeatureCollection(feature, centroids, importedGeojson) {
        feature.features.filter(feature => this._currentAllowedGeom.includes(feature.geometry.type))
            .forEach((feature) => {
            const multiGeometry = this._currentAllowedGeom.filter(g => !SIMPLE_GEOMETRY_OBJECT.includes(g));
            if (multiGeometry.includes(feature.geometry.type)) {
                this.handleMultiGeometry(feature, centroids, importedGeojson);
            }
            else {
                this.handleSimpleGeometry(feature, centroids, importedGeojson);
            }
        });
    }
    /** *************/
    /** *** KML *****/
    /** *************/
    readKmlFile() {
        return new Promise((resolve, reject) => {
            this.reader = new FileReader();
            const reader = this.reader;
            reader.onload = () => {
                resolve(reader.result);
            };
            reader.onerror = () => {
                reader.abort();
                reject(new Error(this.PARSING_ISSUE));
            };
            if (this.maxFileSize && this.currentFile.size > this.maxFileSize) {
                reject(new Error(this.FILE_TOO_LARGE));
            }
            else if (this.currentFile.name.split('.').pop().toLowerCase() === this.KML) {
                reader.readAsText(this.currentFile);
            }
            else if (this.currentFile.name.split('.').pop().toLowerCase() === 'kmz') {
                reader.readAsArrayBuffer(this.currentFile);
            }
            else {
                reject(new Error(marker('Only `kml` or `zip` file is allowed')));
            }
        });
    }
    resolveFileFromGzip(result, resolve) {
        this.jszip.loadAsync(result).then(kmzContent => {
            const kmlFile = Object.keys(kmzContent.files).filter(file => file.split('.').pop().toLowerCase() === this.KML)[0];
            this.jszip.file(kmlFile).async('text').then((data) => resolve(data));
        });
    }
    processAllKml() {
        const readKmlFile = this.readKmlFile();
        let readKmzFile = readKmlFile;
        if (this.currentFile.name.split('.').pop().toLowerCase() === 'kmz') {
            readKmzFile = readKmlFile.then(result => new Promise((resolve, reject) => {
                this.resolveFileFromGzip(result, resolve);
            }));
        }
        const parseKml = readKmzFile.then((file) => new Promise((resolve, reject) => {
            const geojson = toGeoJSON.kml((new DOMParser()).parseFromString(file, 'text/xml'));
            resolve(geojson);
        }));
        const geojsonParserPromise = parseKml.then((geojson) => new Promise((resolve, reject) => {
            this.computeGeojson(geojson, reject, resolve);
        }));
        return Promise.all([geojsonParserPromise])
            .then(([importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** * GEOJSON ***/
    /** *************/
    readJsonFile() {
        return new Promise((resolve, reject) => {
            this.reader = new FileReader();
            const reader = this.reader;
            reader.onload = () => {
                resolve(reader.result);
            };
            reader.onerror = () => {
                reader.abort();
                reject(new Error(this.PARSING_ISSUE));
            };
            if (this.maxFileSize && this.currentFile.size > this.maxFileSize) {
                reject(new Error(this.FILE_TOO_LARGE));
            }
            else {
                const extension = this.currentFile.name.split('.').pop().toLowerCase();
                if (extension === 'json' || extension === 'geojson') {
                    reader.readAsText(this.currentFile);
                }
                else {
                    reject(new Error(marker('Only `json` or `geojson` file is allowed')));
                }
            }
        });
    }
    processJson() {
        const readJsonFile = this.readJsonFile();
        const parseJson = readJsonFile.then((fileContent) => new Promise((resolve, reject) => {
            const feature = JSON.parse(fileContent);
            if (valid(feature) && (this._currentAllowedGeom.includes(feature.geometry) || feature.type === 'FeatureCollection')) {
                const centroides = new Array();
                const importedGeojson = {
                    type: 'FeatureCollection',
                    features: []
                };
                try {
                    if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'Point')) {
                        this.handleSimpleGeometry(feature, centroides, importedGeojson);
                    }
                    else if (feature.geometry && (feature.geometry.type === 'MultiPolygon' || feature.geometry.type === 'MultiPoint')) {
                        this.handleMultiGeometry(feature, centroides, importedGeojson);
                    }
                    else if (feature.type && feature.type === 'FeatureCollection') {
                        this.handleFeatureCollection(feature, centroides, importedGeojson);
                    }
                    resolve({ geojson: importedGeojson, centroides: centroides });
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                reject(new Error(this.GEOMETRY_INVALID));
            }
        }));
        return Promise.all([parseJson])
            .then(([importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** ** SHAPE ****/
    /** *************/
    readZipFile() {
        return new Promise((resolve, reject) => {
            this.reader = new FileReader();
            const reader = this.reader;
            reader.onload = () => {
                const resultToArray = new Uint8Array(reader.result);
                if (resultToArray.length === 0) {
                    reader.abort();
                    reject(new Error(marker('File is empty')));
                }
                else {
                    resolve(reader.result);
                }
            };
            reader.onerror = () => {
                reader.abort();
                reject(new Error(this.PARSING_ISSUE));
            };
            if (this.maxFileSize && this.currentFile.size > this.maxFileSize) {
                reject(new Error(this.FILE_TOO_LARGE));
            }
            else if (this.currentFile.name.split('.').pop().toLowerCase() !== 'zip') {
                reject(new Error(marker('Only `zip` file is allowed')));
            }
            else {
                reader.readAsArrayBuffer(this.currentFile);
            }
        });
    }
    areFilesInvalid(zipResult) {
        const testArray = Object.keys(zipResult.files).map(fileName => fileName.split('.').pop().toLowerCase());
        return (testArray.filter(elem => elem === this.SHP || elem === 'shx' || elem === 'dbf').length < 3) &&
            (testArray.filter(elem => elem === 'json').length !== 1);
    }
    processAllShape() {
        const fileReaderPromise = this.readZipFile();
        const zipLoaderPromise = fileReaderPromise.then((buffer) => new Promise((resolve, reject) => {
            this.jszip.loadAsync(buffer).then(zipResult => {
                if (this.areFilesInvalid(zipResult)) {
                    reject(new Error(marker('Zip file must contain at least a `*.shp`, `*.shx` and `*.dbf` or a `*.json`')));
                }
                else {
                    resolve(buffer);
                }
            });
        }));
        const shapeParserPromise = zipLoaderPromise
            .then(buffer => shp(buffer));
        const geojsonParserPromise = shapeParserPromise.then(geojson => new Promise((resolve, reject) => {
            this.computeGeojson(geojson, reject, resolve);
        }));
        return Promise.all([fileReaderPromise, zipLoaderPromise, shapeParserPromise, geojsonParserPromise])
            .then(([a, b, c, importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** **  WKT  ****/
    /** *************/
    processWKT(wkt) {
        const wktParserPromise = new Promise((resolve, reject) => {
            const geojsonWKT = parse(wkt);
            const centroides = new Array();
            const importedGeojson = {
                type: 'FeatureCollection',
                features: []
            };
            if (geojsonWKT && valid(geojsonWKT) && this._currentAllowedGeom.includes(geojsonWKT.type)) {
                const feature = {
                    type: 'Feature',
                    geometry: geojsonWKT,
                    properties: { arlas_id: null }
                };
                this.handleGeom(feature, centroides, importedGeojson, reject);
                resolve({ geojson: importedGeojson, centroides: centroides });
            }
            else {
                reject(new Error(this.GEOMETRY_INVALID));
            }
        });
        return Promise.all([wktParserPromise]).then(([importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** ** TOOLS ****/
    /** *************/
    clearPolygons() {
        // Clean source of imported polygons
        const labelSource = this.mapService.getSource(this.SOURCE_NAME_POLYGON_LABEL, this.mapComponent.map);
        this.featureIndex = 0;
        this.mapComponent.onAoiChanged.next(this.emptyData);
        if (labelSource !== undefined) {
            this.mapService.setDataToGeojsonSource(labelSource, this.emptyData);
        }
    }
    addFeature(feature, centroides, importedGeojson, index) {
        feature.properties.arlas_id = index;
        const cent = this.calcCentroid(feature);
        centroides.push(cent);
        importedGeojson.features.push(feature);
    }
    setImportedData(importedResult) {
        if (this.tooManyVertex) {
            throw new Error(this.TOO_MANY_VERTICES);
        }
        else if (this.maxFeatures && importedResult.geojson.features.length > this.maxFeatures) {
            throw new Error(this.TOO_MANY_FEATURES);
        }
        else if (importedResult.geojson.features.length > 0) {
            this.dialogRef.componentInstance.isRunning = false;
            if (this.fitResult) {
                this.mapComponent.fitToPaddedBounds(extent(importedResult.geojson));
            }
            if (this.mapComponent.drawData.features.length > 0) {
                this.mapComponent.drawData.features.forEach(df => importedResult.geojson.features.push(df));
            }
            this.mapComponent.drawComponent.draw.changeMode('static');
            this.imported.next(importedResult.geojson.features);
            this.mapComponent.onAoiChanged.next(importedResult.geojson);
            this.dialogRef.close();
        }
        else {
            throw new Error(marker('No polygon to display in this file'));
        }
    }
    calcCentroid(feature) {
        let cent;
        if (feature.type === 'Point') {
            cent = centroid(feature);
        }
        else {
            if (!this.maxVertexByPolygon) {
                this.maxVertexByPolygon = 100;
            }
            if (this.maxVertexByPolygon && feature.geometry.coordinates[0].length - 1 > this.maxVertexByPolygon) {
                this.tooManyVertex = true;
            }
            const poly = polygon(feature.geometry.coordinates);
            cent = centroid(poly);
        }
        cent.properties.arlas_id = feature.properties.arlas_id;
        return cent;
    }
    throwError(error) {
        this.dialogRef.componentInstance.displayError = true;
        this.dialogRef.componentInstance.isRunning = false;
        this.dialogRef.componentInstance.errorMessage = error.message;
        switch (this.dialogRef.componentInstance.errorMessage) {
            case this.TOO_MANY_FEATURES:
                this.dialogRef.componentInstance.errorThreshold = this.maxFeatures.toString();
                break;
            case this.TOO_MANY_VERTICES:
                this.dialogRef.componentInstance.errorThreshold = this.maxVertexByPolygon.toString();
                break;
            case this.FILE_TOO_LARGE:
                this.dialogRef.componentInstance.errorThreshold = this.formatBytes(this.maxFileSize);
                break;
            case this.TIMEOUT:
                this.dialogRef.componentInstance.errorThreshold = this.maxLoadingTime + ' ms';
                break;
            default:
                this.dialogRef.componentInstance.errorThreshold = '';
        }
        if (this.dialogRef.componentInstance.fileInput) {
            this.dialogRef.componentInstance.fileInput.nativeElement.value = '';
        }
        this.dialogRef.componentInstance.currentFile = null;
        this.error.next(error.message);
    }
    formatBytes(bytes, decimals = 2) {
        if (bytes === 0) {
            return '0 Bytes';
        }
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    computeGeojson(geojson, reject, resolve) {
        if (valid(geojson)) {
            const centroides = new Array();
            const importedGeojson = {
                type: 'FeatureCollection',
                features: []
            };
            geojson.features.filter(feature => this._currentAllowedGeom.includes(feature.geometry.type))
                .forEach((feature) => {
                this.handleGeom(feature, centroides, importedGeojson, reject);
            });
            resolve({ geojson: importedGeojson, centroides: centroides });
        }
        else {
            reject(new Error('Geometry is not valid'));
        }
    }
    handleGeom(feature, centroides, importedGeojson, reject) {
        try {
            if (feature.geometry.type === 'GeometryCollection' || feature.geometry.type === 'MultiGeometry') {
                // Create a new Polygon feature for each polygon in the MultiPolygon
                // All properties of the MultiPolygon are copied in each feature created
                this.handleGeometryCollection(feature, centroides, importedGeojson);
            }
            else if (feature.geometry.type === 'MultiPolygon' || feature.geometry.type === 'MultiPoint') {
                this.handleMultiGeometry(feature, centroides, importedGeojson);
            }
            else {
                this.handleSimpleGeometry(feature, centroides, importedGeojson);
            }
        }
        catch (e) {
            reject(new Error('Error during import'));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportComponent, deps: [{ token: i1.MatDialog }, { token: ArlasMapFrameworkService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapImportComponent, selector: "arlas-map-import", inputs: { mapComponent: "mapComponent", maxVertexByPolygon: "maxVertexByPolygon", maxFeatures: "maxFeatures", maxFileSize: "maxFileSize", maxLoadingTime: "maxLoadingTime", allowedImportType: "allowedImportType", allowedGeometryObjectType: "allowedGeometryObjectType" }, outputs: { imported: "imported", error: "error" }, ngImport: i0, template: "\n\n", styles: ["@charset \"UTF-8\";\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-import', template: "\n\n", styles: ["@charset \"UTF-8\";\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }, { type: ArlasMapFrameworkService }], propDecorators: { mapComponent: [{
                type: Input
            }], maxVertexByPolygon: [{
                type: Input
            }], maxFeatures: [{
                type: Input
            }], maxFileSize: [{
                type: Input
            }], maxLoadingTime: [{
                type: Input
            }], allowedImportType: [{
                type: Input
            }], allowedGeometryObjectType: [{
                type: Input
            }], imported: [{
                type: Output
            }], error: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MapSettingsModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsModule, declarations: [MapSettingsComponent, MapSettingsDialogComponent], imports: [CommonModule,
            FormsModule,
            MatTabsModule,
            MatDialogModule,
            MatFormFieldModule,
            MatSelectModule,
            MatButtonToggleModule,
            MatIconModule,
            MatButtonModule,
            MatRadioModule,
            ReactiveFormsModule,
            TranslateModule,
            GetCollectionDisplayModule], exports: [MapSettingsComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsModule, imports: [CommonModule,
            FormsModule,
            MatTabsModule,
            MatDialogModule,
            MatFormFieldModule,
            MatSelectModule,
            MatButtonToggleModule,
            MatIconModule,
            MatButtonModule,
            MatRadioModule,
            ReactiveFormsModule,
            TranslateModule,
            GetCollectionDisplayModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatTabsModule,
                        MatDialogModule,
                        MatFormFieldModule,
                        MatSelectModule,
                        MatButtonToggleModule,
                        MatIconModule,
                        MatButtonModule,
                        MatRadioModule,
                        ReactiveFormsModule,
                        TranslateModule,
                        GetCollectionDisplayModule
                    ],
                    declarations: [MapSettingsComponent, MapSettingsDialogComponent],
                    exports: [MapSettingsComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MapImportModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: MapImportModule, declarations: [MapImportComponent, MapImportDialogComponent], imports: [CommonModule,
            FormsModule,
            MatButtonModule,
            MatCheckboxModule,
            MatDialogModule,
            MatProgressSpinnerModule,
            MatSelectModule,
            MatRadioModule,
            TranslateModule], exports: [MapImportComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportModule, imports: [CommonModule,
            FormsModule,
            MatButtonModule,
            MatCheckboxModule,
            MatDialogModule,
            MatProgressSpinnerModule,
            MatSelectModule,
            MatRadioModule,
            TranslateModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatButtonModule,
                        MatCheckboxModule,
                        MatDialogModule,
                        MatProgressSpinnerModule,
                        MatSelectModule,
                        MatRadioModule,
                        TranslateModule
                    ],
                    declarations: [MapImportComponent, MapImportDialogComponent],
                    exports: [MapImportComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class BasemapModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: BasemapModule, declarations: [BasemapComponent], imports: [CommonModule,
            MatIconModule,
            TranslateModule], exports: [BasemapComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapModule, imports: [CommonModule,
            MatIconModule,
            TranslateModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        TranslateModule
                    ],
                    declarations: [BasemapComponent],
                    exports: [BasemapComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class CoordinatesModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesModule, declarations: [CoordinatesComponent, CoordinatesErrorPipe], imports: [CommonModule,
            MatIconModule,
            MatFormFieldModule,
            FormsModule,
            ReactiveFormsModule,
            MatTooltipModule,
            MatInputModule,
            TranslateModule], exports: [CoordinatesComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesModule, imports: [CommonModule,
            MatIconModule,
            MatFormFieldModule,
            FormsModule,
            ReactiveFormsModule,
            MatTooltipModule,
            MatInputModule,
            TranslateModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CoordinatesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatFormFieldModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatTooltipModule,
                        MatInputModule,
                        TranslateModule
                    ],
                    declarations: [CoordinatesComponent, CoordinatesErrorPipe],
                    exports: [CoordinatesComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ArlasMapModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapModule, declarations: [ArlasMapComponent,
            LayerIconComponent,
            LegendComponent,
            LegendItemComponent,
            ArlasDrawComponent,
            LayerIdToName,
            GetCollectionPipe,
            FormatLegendPipe], imports: [MatSnackBarModule,
            TranslateModule,
            MatIconModule,
            MatMenuModule,
            MatSlideToggleModule,
            MatTooltipModule,
            MatFormFieldModule,
            GetCollectionDisplayModule,
            GetColorModule,
            DragDropModule,
            GetValueModule,
            FormatNumberModule,
            CommonModule,
            CoordinatesModule,
            MapSettingsModule,
            MapImportModule,
            BasemapModule,
            MarkerModule], exports: [LayerIconComponent,
            LegendComponent,
            LegendItemComponent,
            LayerIdToName,
            ArlasMapComponent,
            MapImportComponent,
            MapSettingsComponent,
            GetCollectionPipe,
            FormatLegendPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapModule, providers: [
            MapboxAoiDrawService,
            ArlasColorService
        ], imports: [MatSnackBarModule,
            TranslateModule,
            MatIconModule,
            MatMenuModule,
            MatSlideToggleModule,
            MatTooltipModule,
            MatFormFieldModule,
            GetCollectionDisplayModule,
            GetColorModule,
            DragDropModule,
            GetValueModule,
            FormatNumberModule,
            CommonModule,
            CoordinatesModule,
            MapSettingsModule,
            MapImportModule,
            BasemapModule,
            MarkerModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasMapModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        ArlasMapComponent,
                        LayerIconComponent,
                        LegendComponent,
                        LegendItemComponent,
                        ArlasDrawComponent,
                        LayerIdToName,
                        GetCollectionPipe,
                        FormatLegendPipe
                    ],
                    imports: [
                        MatSnackBarModule,
                        TranslateModule,
                        MatIconModule,
                        MatMenuModule,
                        MatSlideToggleModule,
                        MatTooltipModule,
                        MatFormFieldModule,
                        GetCollectionDisplayModule,
                        GetColorModule,
                        DragDropModule,
                        GetValueModule,
                        FormatNumberModule,
                        CommonModule,
                        CoordinatesModule,
                        MapSettingsModule,
                        MapImportModule,
                        BasemapModule,
                        MarkerModule
                    ],
                    providers: [
                        MapboxAoiDrawService,
                        ArlasColorService
                    ],
                    exports: [
                        LayerIconComponent,
                        LegendComponent,
                        LegendItemComponent,
                        LayerIdToName,
                        ArlasMapComponent,
                        MapImportComponent,
                        MapSettingsComponent,
                        GetCollectionPipe,
                        FormatLegendPipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class BboxFormErrorPipe {
    transform(formControl) {
        if (formControl.hasError('required')) {
            return marker('You must enter a coordinate');
        }
        else if (formControl.latitudeErrors) {
            return marker('Both corners have the same latitudes, modify one of them.');
        }
        return formControl.hasError('pattern') ? marker('Enter a coordinate in decimal (1.1) or sexagesimal (1° 6\' 3")') : '';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BboxFormErrorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: BboxFormErrorPipe, name: "bboxFormError" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BboxFormErrorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bboxFormError'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class BboxFormGroup extends FormGroup {
    constructor(corner) {
        const firstCorner = new PointFormGroup(corner.lat - 0.5, corner.lng - 0.5);
        const secondCorner = new PointFormGroup(corner.lat + 0.5, corner.lng + 0.5);
        super({
            firstCorner,
            secondCorner
        });
        this.latitudeErrors = false;
        this.subscriptions = new Array();
        this.firstCorner = firstCorner;
        this.secondCorner = secondCorner;
        const latSub = this.firstCorner.latitude.valueChanges.subscribe(v => {
            this.firstCornerLatitude = v;
            this.secondCornerLatitude = this.secondCorner.latitude.value;
            if (this.secondCornerLatitude !== undefined) {
                if (Coordinate.parse(this.firstCornerLatitude) === Coordinate.parse(this.secondCornerLatitude)) {
                    this.latitudeErrors = true;
                }
                else {
                    this.latitudeErrors = false;
                }
            }
        });
        this.subscriptions.push(latSub);
        const lonSub = this.secondCorner.latitude.valueChanges.subscribe(v => {
            this.secondCornerLatitude = v;
            this.firstCornerLatitude = this.firstCorner.latitude.value;
            if (this.firstCornerLatitude !== undefined) {
                if (Coordinate.parse(this.firstCornerLatitude) === Coordinate.parse(this.secondCornerLatitude)) {
                    this.latitudeErrors = true;
                }
                else {
                    this.latitudeErrors = false;
                }
            }
        });
        this.subscriptions.push(lonSub);
    }
    getFirstCorner() {
        return {
            lat: Coordinate.parse(this.firstCorner.latitude.value),
            lng: Coordinate.parse(this.firstCorner.longitude.value)
        };
    }
    getSecondCorner() {
        return {
            lat: Coordinate.parse(this.secondCorner.latitude.value),
            lng: Coordinate.parse(this.secondCorner.longitude.value)
        };
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class BboxGeneratorComponent {
    constructor(drawService, cdr, data, dialogRef) {
        this.drawService = drawService;
        this.cdr = cdr;
        this.data = data;
        this.dialogRef = dialogRef;
        /**
         * @constant
         */
        this.DESCRIPTION = marker('Enter coordinates in decimal or sexagesimal degrees');
        /**
         * @constant
         */
        this.placeHolder = marker('Decimal: 1.1 or Sexagesimal 1°6\'3" coordinate');
    }
    ngOnInit() {
        if (!!this.data && !this.data.initCorner) {
            this.data.initCorner = {
                lat: 0,
                lng: 0
            };
        }
        this.bboxForm = new BboxFormGroup(this.data.initCorner);
    }
    ngAfterViewInit() {
        this.cdr.detectChanges();
    }
    ngOnDestroy() {
        this.bboxForm.subscriptions.forEach(s => s.unsubscribe());
    }
    close() {
        this.dialogRef.close();
    }
    generateBbox() {
        this.drawService.drawBbox(this.bboxForm.getFirstCorner(), this.bboxForm.getSecondCorner());
        this.dialogRef.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BboxGeneratorComponent, deps: [{ token: MapboxAoiDrawService }, { token: i0.ChangeDetectorRef }, { token: MAT_DIALOG_DATA }, { token: i1.MatDialogRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: BboxGeneratorComponent, selector: "arlas-bbox-generator", ngImport: i0, template: "<div class=\"wrapper\">\n    <div class=\"title-wrapper\">\n        <span>{{'BBox generator' | translate}}</span>\n        <mat-icon class=\"clear\" (click)=\"close()\" (keyDown)=\"close()\">clear</mat-icon>\n    </div>\n    <div class=\"content\">\n        <div class=\"description\">\n            <mat-icon>info</mat-icon>\n            <span>{{DESCRIPTION | translate}}</span>\n        </div>\n        <div class=\"section\" *ngIf=\"bboxForm?.firstCorner\" [formGroup]=\"bboxForm?.firstCorner\">\n            <div class=\"title\">{{'First corner' | translate}}</div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\" >\n                    <mat-label>{{'Latitude' |translate}}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.firstCorner.latitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.firstCorner.latitude.invalid\">{{bboxForm.firstCorner.latitude | bboxFormError | translate}}</mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\">\n                    <mat-label>{{'Longitude'|translate }}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.firstCorner.longitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.firstCorner.longitude.invalid\">{{bboxForm.firstCorner.longitude | bboxFormError | translate}}</mat-error>\n                </mat-form-field>\n            </div>\n        </div>\n        <div class=\"section\" *ngIf=\"bboxForm?.secondCorner\" [formGroup]=\"bboxForm?.secondCorner\">\n            <div class=\"title\">{{'Second corner' | translate}}</div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\" >\n                    <mat-label>{{'Latitude' | translate}}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.secondCorner.latitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.secondCorner.latitude.invalid\">{{bboxForm.secondCorner.latitude | bboxFormError | translate}} </mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\">\n                    <mat-label>{{'Longitude' | translate}}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.secondCorner.longitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.secondCorner.longitude.invalid\">{{bboxForm.secondCorner.longitude | bboxFormError | translate}}</mat-error>\n                </mat-form-field>\n            </div>\n\n\n        </div>\n        <div class=\"errors\" *ngIf=\"bboxForm.latitudeErrors\">\n            <mat-icon>report</mat-icon>\n            <mat-error>{{bboxForm | bboxFormError | translate}}</mat-error>\n        </div>\n    </div>\n    <div class=\"actions\">\n        <button mat-button [mat-dialog-close]=\"null\">{{'Close' | translate}}\n        </button>\n        <button class=\"create-action\" mat-stroked-button (click)=\"generateBbox()\"\n            [disabled]=\"bboxForm.invalid || bboxForm.latitudeErrors\">\n            <span class=\"label\">{{'Generate AOI' | translate}}</span>\n        </button>\n    </div>\n</div>", styles: ["@charset \"UTF-8\";.wrapper{padding:5px;border-radius:4px;background-color:#fff;font-size:16px;min-width:365px}.wrapper .title-wrapper{display:flex;justify-content:space-between;align-items:center;font-weight:600}.wrapper .title-wrapper .clear{cursor:pointer}.wrapper .content{display:flex;flex-direction:column}.wrapper .content .description{margin:5px 0;display:flex;align-items:center;font-size:14px;color:#929292}.wrapper .content .description mat-icon{font-size:18px;height:18px;width:18px;margin-right:5px}.wrapper .content .section{display:flex;flex-direction:column}.wrapper .content .section .title{margin-bottom:5px}.wrapper .content .section .coordinate{width:100%}.wrapper .content .section .coordinate mat-form-field{width:100%}.wrapper .content .section .coordinate .input{font-size:14px}.wrapper .content .section .coordinate ::ng-deep .mat-mdc-form-field-infix{padding-left:10px;padding-bottom:10px;padding-top:10px;font-size:14px;display:flex}.wrapper .content .section .coordinate ::ng-deep .mat-mdc-form-field{padding:7px 0;width:130px}.wrapper .content .section .coordinate ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}.wrapper .content .errors{margin-bottom:10px;display:flex;align-items:center;font-size:12px}.wrapper .content .errors mat-icon{font-size:16px;height:16px;width:16px;margin-right:5px;color:#f44336}.wrapper .actions{display:flex;justify-content:flex-end}.wrapper .actions .create-action{margin-left:5px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i1.MatDialogClose, selector: "[mat-dialog-close], [matDialogClose]", inputs: ["aria-label", "type", "mat-dialog-close", "matDialogClose"], exportAs: ["matDialogClose"] }, { kind: "component", type: i5.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i5.MatLabel, selector: "mat-label" }, { kind: "directive", type: i5.MatError, selector: "mat-error, [matError]", inputs: ["id"] }, { kind: "component", type: i6$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i8.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "directive", type: i6$2.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }, { kind: "pipe", type: BboxFormErrorPipe, name: "bboxFormError" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BboxGeneratorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-bbox-generator', template: "<div class=\"wrapper\">\n    <div class=\"title-wrapper\">\n        <span>{{'BBox generator' | translate}}</span>\n        <mat-icon class=\"clear\" (click)=\"close()\" (keyDown)=\"close()\">clear</mat-icon>\n    </div>\n    <div class=\"content\">\n        <div class=\"description\">\n            <mat-icon>info</mat-icon>\n            <span>{{DESCRIPTION | translate}}</span>\n        </div>\n        <div class=\"section\" *ngIf=\"bboxForm?.firstCorner\" [formGroup]=\"bboxForm?.firstCorner\">\n            <div class=\"title\">{{'First corner' | translate}}</div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\" >\n                    <mat-label>{{'Latitude' |translate}}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.firstCorner.latitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.firstCorner.latitude.invalid\">{{bboxForm.firstCorner.latitude | bboxFormError | translate}}</mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\">\n                    <mat-label>{{'Longitude'|translate }}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.firstCorner.longitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.firstCorner.longitude.invalid\">{{bboxForm.firstCorner.longitude | bboxFormError | translate}}</mat-error>\n                </mat-form-field>\n            </div>\n        </div>\n        <div class=\"section\" *ngIf=\"bboxForm?.secondCorner\" [formGroup]=\"bboxForm?.secondCorner\">\n            <div class=\"title\">{{'Second corner' | translate}}</div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\" >\n                    <mat-label>{{'Latitude' | translate}}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.secondCorner.latitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.secondCorner.latitude.invalid\">{{bboxForm.secondCorner.latitude | bboxFormError | translate}} </mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"coordinate\">\n                <mat-form-field appearance=\"outline\">\n                    <mat-label>{{'Longitude' | translate}}</mat-label>\n                    <input class=\"input\"  matInput [formControl]=\"bboxForm.secondCorner.longitude\" [placeholder]=\"placeHolder | translate\">\n                    <mat-error *ngIf=\"bboxForm.secondCorner.longitude.invalid\">{{bboxForm.secondCorner.longitude | bboxFormError | translate}}</mat-error>\n                </mat-form-field>\n            </div>\n\n\n        </div>\n        <div class=\"errors\" *ngIf=\"bboxForm.latitudeErrors\">\n            <mat-icon>report</mat-icon>\n            <mat-error>{{bboxForm | bboxFormError | translate}}</mat-error>\n        </div>\n    </div>\n    <div class=\"actions\">\n        <button mat-button [mat-dialog-close]=\"null\">{{'Close' | translate}}\n        </button>\n        <button class=\"create-action\" mat-stroked-button (click)=\"generateBbox()\"\n            [disabled]=\"bboxForm.invalid || bboxForm.latitudeErrors\">\n            <span class=\"label\">{{'Generate AOI' | translate}}</span>\n        </button>\n    </div>\n</div>", styles: ["@charset \"UTF-8\";.wrapper{padding:5px;border-radius:4px;background-color:#fff;font-size:16px;min-width:365px}.wrapper .title-wrapper{display:flex;justify-content:space-between;align-items:center;font-weight:600}.wrapper .title-wrapper .clear{cursor:pointer}.wrapper .content{display:flex;flex-direction:column}.wrapper .content .description{margin:5px 0;display:flex;align-items:center;font-size:14px;color:#929292}.wrapper .content .description mat-icon{font-size:18px;height:18px;width:18px;margin-right:5px}.wrapper .content .section{display:flex;flex-direction:column}.wrapper .content .section .title{margin-bottom:5px}.wrapper .content .section .coordinate{width:100%}.wrapper .content .section .coordinate mat-form-field{width:100%}.wrapper .content .section .coordinate .input{font-size:14px}.wrapper .content .section .coordinate ::ng-deep .mat-mdc-form-field-infix{padding-left:10px;padding-bottom:10px;padding-top:10px;font-size:14px;display:flex}.wrapper .content .section .coordinate ::ng-deep .mat-mdc-form-field{padding:7px 0;width:130px}.wrapper .content .section .coordinate ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}.wrapper .content .errors{margin-bottom:10px;display:flex;align-items:center;font-size:12px}.wrapper .content .errors mat-icon{font-size:16px;height:16px;width:16px;margin-right:5px;color:#f44336}.wrapper .actions{display:flex;justify-content:flex-end}.wrapper .actions .create-action{margin-left:5px}\n"] }]
        }], ctorParameters: () => [{ type: MapboxAoiDrawService }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }, { type: i1.MatDialogRef }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class BboxGeneratorModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BboxGeneratorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: BboxGeneratorModule, declarations: [BboxGeneratorComponent, BboxFormErrorPipe], imports: [CommonModule,
            FormsModule,
            MatDialogModule,
            MatFormFieldModule,
            MatIconModule,
            MatButtonModule,
            MatInputModule,
            ReactiveFormsModule,
            TranslateModule], exports: [BboxGeneratorComponent, BboxFormErrorPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BboxGeneratorModule, imports: [CommonModule,
            FormsModule,
            MatDialogModule,
            MatFormFieldModule,
            MatIconModule,
            MatButtonModule,
            MatInputModule,
            ReactiveFormsModule,
            TranslateModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BboxGeneratorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatDialogModule,
                        MatFormFieldModule,
                        MatIconModule,
                        MatButtonModule,
                        MatInputModule,
                        ReactiveFormsModule,
                        TranslateModule
                    ],
                    declarations: [BboxGeneratorComponent, BboxFormErrorPipe],
                    exports: [BboxGeneratorComponent, BboxFormErrorPipe]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class AbstractDraw {
    constructor(config, enabled, map) {
        const modes = MapboxDraw.modes;
        this.config = JSON.parse(JSON.stringify(config));
        this.config.modes = Object.assign(modes, config.modes);
        this.drawProvider = new MapboxDraw(this.config);
        this.arlasMap = map;
        this.enabled = enabled;
    }
    onAdd(map) {
        const controlContainer = this.drawProvider.onAdd(map);
        if (!this.enabled) {
            controlContainer.className += ' draw-control-disabled';
        }
        return controlContainer;
    }
    onRemove(map) {
        return this.drawProvider.onRemove(map);
    }
    setMode(drawModes, replaceMode) {
        this.drawProvider.modes[drawModes] = replaceMode;
    }
    getAllFeatures() {
        return this.getAll().features;
    }
    onDrawCreate(fn) {
        this.on('draw.create', (e) => {
            fn(e);
        });
    }
    onDrawDelete(fn) {
        this.on('draw.delete', (e) => {
            fn(e);
        });
    }
    onDrawEditSaveInitialFeature(fn) {
        this.on('draw.edit.saveInitialFeature', (e) => {
            fn(e);
        });
    }
    onDrawInvalidGeometry(fn) {
        this.on('draw.invalidGeometry', (e) => {
            fn(e);
        });
    }
    onDrawModeChange(fn) {
        this.on('draw.modechange', (e) => {
            fn(e);
        });
    }
    onDrawOnClick(fn) {
        this.on('draw.onClick', (e) => {
            fn(e);
        });
    }
    onDrawOnStart(fn) {
        this.on('draw.onStart', (e) => {
            fn(e);
        });
    }
    onDrawOnStop(fn) {
        this.on('draw.onStop', (e) => {
            fn(e);
        });
    }
    onDrawSelectionchange(fn) {
        this.on('draw.selectionchange', (e) => {
            fn(e);
        });
    }
    onDrawUpdate(fn) {
        this.on('draw.update', (e) => {
            fn(e);
        });
    }
    getMode(modes) {
        return this.drawProvider.modes[modes];
    }
    on(event, func) {
        this.arlasMap.on(event, func);
    }
    add(feature) {
        this.drawProvider.add(feature);
    }
    get(featureId) {
        return this.drawProvider.get(featureId);
    }
    delete(ids) {
        this.drawProvider.delete(ids);
        return this;
    }
    deleteAll() {
        this.drawProvider.deleteAll();
        return this;
    }
    set(featureCollection) {
        return this.drawProvider.set(featureCollection);
    }
    trash() {
        this.drawProvider.trash();
        return this;
    }
    combineFeatures() {
        this.drawProvider.combineFeatures();
        return this;
    }
    uncombineFeatures() {
        this.drawProvider.uncombineFeatures();
        return this;
    }
    getCurrentMode() {
        return this.drawProvider.getMode();
    }
    getFeatureIdsAt(point) {
        return this.drawProvider.getFeatureIdsAt(point);
    }
    getSelectedIds() {
        return this.drawProvider.getSelectedIds();
    }
    getSelected() {
        return this.drawProvider.getSelected();
    }
    getAll() {
        return this.drawProvider.getAll();
    }
    getSelectedFeatures() {
        return this.getSelected().features;
    }
    setFeatureProperty(featureId, property, value) {
        this.drawProvider.setFeatureProperty(featureId, property, value);
        return this;
    }
    changeMode(mode, opt) {
        this.drawProvider.changeMode(mode, opt);
        return this;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class PitchToggle {
    constructor(bearing, pitch, minpitchzoom) {
        this.image3D = 'url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMCIgaGVpZ2h0PSIzM' +
            'CI+ICAgIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkeT0iLjM1ZW0iIHN0eWxlPSJmb250LXNpemU6IDE0cHg7IGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLEFya' +
            'WFsLEhlbHZldGljYSxzYW5zLXNlcmlmOyBmb250LXdlaWdodDogYm9sZDsgdGV4dC1hbmNob3I6IG1pZGRsZTsiPjNEPC90ZXh0Pjwvc3ZnPg==)';
        this.image2D = 'url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMCIgaGVpZ2h0PSIzM' +
            'CI+ICAgIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkeT0iLjM1ZW0iIHN0eWxlPSJmb250LXNpemU6IDE0cHg7IGZvbnQtZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLEFyaWF' +
            'sLEhlbHZldGljYSxzYW5zLXNlcmlmOyBmb250LXdlaWdodDogYm9sZDsgdGV4dC1hbmNob3I6IG1pZGRsZTsiPjJEPC90ZXh0Pjwvc3ZnPg==)';
        this.btnClasses = [];
        this.containerClasses = [];
        this.bearing = bearing;
        this.pitch = pitch;
        this.minpitchzoom = minpitchzoom;
        this._buildClasses();
    }
    _buildClasses() {
        this.btnClasses = [];
        this.containerClasses = [];
    }
    onAdd(map) {
        this.map = map;
        this.btn = document.createElement('button');
        this.btn.className = this.btnClasses.join(' ');
        this.btn.style.backgroundImage = this.image3D;
        this.btn.type = 'button';
        this.btn['aria-label'] = marker('Toggle Pitch');
        this.btn.onclick = () => {
            if (map.getPitch() === 0) {
                const options = { pitch: this.pitch, bearing: this.bearing, minpitchzoom: null };
                if (this.minpitchzoom && map.getZoom() > this.minpitchzoom) {
                    options.minpitchzoom = this.minpitchzoom;
                }
                map.easeTo(options);
                this.btn.style.backgroundImage = this.image2D;
            }
            else {
                map.easeTo({ pitch: 0, bearing: 0 });
                this.btn.style.backgroundImage = this.image3D;
            }
        };
        this.container = document.createElement('div');
        this.container.className = this.containerClasses.join(' ');
        this.container.appendChild(this.btn);
        return this.container;
    }
    onRemove() {
        this.container.parentNode.removeChild(this.container);
        this.map = undefined;
    }
}
class ControlButton {
    constructor(name, tooltip) {
        this.btnClasses = [];
        this.containerClasses = [];
        this.name = name;
        this.tooltip = tooltip;
        this._buildClasses();
    }
    _buildClasses() {
        this.btnClasses = [];
        this.containerClasses = [];
    }
    onAdd(map) {
        this.map = map;
        this.btn = document.createElement('button');
        this.btn.className = this.btnClasses.join(' ');
        this.btn.type = 'button';
        this.btn.id = 'layers_switcher_btn';
        this.container = document.createElement('div');
        this.container.className = this.containerClasses.join(' ');
        this.container.setAttribute('title', this.tooltip);
        this.container.appendChild(this.btn);
        return this.container;
    }
    onRemove() {
        this.container.parentNode.removeChild(this.container);
        this.map = undefined;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/** Data source of a layer */
class ArlasMapSource {
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/** This file describes how to style a vector layer */
var VectorStyleEnum;
(function (VectorStyleEnum) {
    VectorStyleEnum["circle"] = "circle";
    VectorStyleEnum["fill"] = "fill";
    VectorStyleEnum["line"] = "line";
})(VectorStyleEnum || (VectorStyleEnum = {}));
class VectorStyle {
    constructor(type, style) {
        this.type = type;
        this.style = style;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/*
 * Public API Surface of arlas-map
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ARLAS_ID, ARLAS_VSET, AbstractArlasMapGL, AbstractArlasMapService, AbstractDraw, ArlasBasemaps, ArlasLngLat, ArlasLngLatBounds, ArlasMapComponent, ArlasMapFrameworkService, ArlasMapModule, ArlasMapSource, BasemapComponent, BasemapService, BboxFormErrorPipe, BboxFormGroup, BboxGeneratorComponent, BboxGeneratorModule, CROSS_LAYER_PREFIX, ControlButton, Coordinate, CoordinatesComponent, CoordinatesErrorPipe, ExternalEvent, FILLSTROKE_LAYER_PREFIX, FormatLegendPipe, GEOJSON_SOURCE_TYPE, GET, GeoQueryOperator, GetCollectionPipe, HEATMAP_DENSITY, HOVER_LAYER_PREFIX, IN, INTERPOLATE, LAYER_SWITCHER_TOOLTIP, LayerIconComponent, LayerIdToName, LegendComponent, LegendItemComponent, LegendService, MATCH, MAX_CIRLE_RADIUS, MAX_LINE_WIDTH, MapImportComponent, MapImportDialogComponent, MapImportModule, MapSettingsComponent, MapSettingsDialogComponent, MapSettingsModule, MapboxAoiDrawService, NOT_IN, OTHER, PROPERTY_SELECTOR_SOURCE, PitchToggle, RESET_BEARING, SCROLLABLE_ARLAS_ID, SELECT_LAYER_PREFIX, VectorStyle, VectorStyleEnum, ZOOM_IN, ZOOM_OUT, circleMode, createSupplementaryPointsForCircle, directModeOverride, dragPan, getLayerName, getMax$1 as getMax, latLngToWKT, limitVertexDirectSelectMode, radiusCircleMode, rectangleMode, simpleSelectModeOverride, stripDirectSelectMode, stripMode, defaultTheme$1 as styles, validGeomDrawPolygonMode };
//# sourceMappingURL=arlas-map.mjs.map
