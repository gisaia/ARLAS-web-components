/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { Component, ElementRef, Inject, Input, Output, ViewChild } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialog, MatDialogRef } from '@angular/material/dialog';
import * as toGeoJSON from '@tmcw/togeojson';
import centroid from '@turf/centroid';
import JSZip from 'jszip';
import { polygon } from '@turf/helpers';
import { Subject } from 'rxjs';
import * as shp_ from 'shpjs/dist/shp';
import * as extent_ from 'turf-extent';
import { parse } from 'wellknown';
import { valid } from 'geojson-validation';
import { marker } from '@colsen1991/ngx-translate-extract-marker';
import * as gpsi_ from 'geojson-polygon-self-intersections';
import { ArlasMapComponent } from '../arlas-map.component';
import { ArlasMapFrameworkService } from '../arlas-map-framework.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/dialog";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
import * as i4 from "@angular/material/button";
import * as i5 from "@angular/material/checkbox";
import * as i6 from "@angular/material/progress-spinner";
import * as i7 from "@angular/material/radio";
import * as i8 from "@ngx-translate/core";
import * as i9 from "../arlas-map-framework.service";
const gpsi = gpsi_.default;
const shp = shp_.default;
const extent = extent_.default;
export class MapImportDialogComponent {
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
        this.displayError = false;
        this.isRunning = false;
        this.fitResult = false;
        this.wktContent = '';
        this.SHP = marker('shp');
        this.KML = marker('kml');
        this.WKT = marker('wkt');
        this.GEOJSON = marker('geojson');
        this.file = new Subject();
        this.importRun = new Subject();
        this.fitResult = data.defaultFitResult ?? false;
        this.allowedImportType = this.data.allowedImportType.filter(t => [this.SHP, this.KML, this.WKT, this.GEOJSON].includes(t));
        if (this.allowedImportType.indexOf(this.SHP) > -1) {
            this.importType = this.SHP;
        }
        else if (this.allowedImportType.indexOf(this.KML) > -1) {
            this.importType = this.KML;
        }
        else if (this.allowedImportType.indexOf(this.WKT) > -1) {
            this.importType = this.WKT;
        }
        else {
            this.importType = this.GEOJSON;
        }
        this.changeType();
    }
    onFileChange(files) {
        this.file.next(files.item(0));
        this.currentFile = files.item(0);
        this.displayError = false;
    }
    import() {
        this.importRun.next({ type: this.importType, fitResult: this.fitResult, wktContent: this.wktContent });
    }
    onTextChange() { }
    changeType() {
        if (this.importType === this.SHP) {
            this.allowedFileExtension = '.zip';
        }
        else if (this.importType === this.KML) {
            this.allowedFileExtension = '.kml,.kmz';
        }
        else if (this.importType === this.GEOJSON) {
            this.allowedFileExtension = '.json,.geojson';
        }
    }
    onCancel() {
        this.dialogRef.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportDialogComponent, deps: [{ token: i1.MatDialogRef }, { token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapImportDialogComponent, selector: "arlas-map-import-dialog", outputs: { file: "file", importRun: "importRun" }, viewQueries: [{ propertyName: "fileInput", first: true, predicate: ["fileInput"], descendants: true }], ngImport: i0, template: "<h1 mat-dialog-title class=\"mapgl-import-title\">{{ 'Import file' | translate}}</h1>\n<div mat-dialog-content class=\"mapgl-import-body\">\n  <mat-radio-group class=\"mapgl-import-radio-group\" [(ngModel)]=\"importType\" (change)=\"changeType()\">\n    <mat-radio-button *ngFor=\"let type of allowedImportType\" [value]=\"type\" class=\"mapgl-import-radio-button\">\n      {{ type | translate }}\n    </mat-radio-button>\n  </mat-radio-group>\n\n  <input *ngIf=\"importType !== WKT\" type=\"file\" class=\"mapgl-import-upload\" #fileInput accept=\"{{allowedFileExtension}}\" (change)=\"onFileChange($event.target.files)\">\n  <textarea *ngIf=\"importType === WKT\" class=\"mapgl-import-text-area\" [(ngModel)]=\"wktContent\" placeholder=\"{{'Paste your WKT' | translate}}\" (change)=\"onTextChange()\"></textarea>\n\n  <div class=\"mapgl-import-zoom\">\n    <mat-checkbox [(ngModel)]=\"fitResult\">{{ 'Zoom to result' | translate}}</mat-checkbox>\n  </div>\n  <div *ngIf=\"displayError\" class=\"mapgl-import-error\">\n    {{ errorMessage | translate}} <ng-container *ngIf=\"errorThreshold !== ''\"> - ({{'Max:' | translate }} {{errorThreshold}})</ng-container>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-import-actions\">\n  <button mat-button (click)=\"onCancel()\">{{ 'Cancel' | translate}}</button>\n  <button mat-button [disabled]=\"((importType === SHP || importType === KML || importType === GEOJSON) && !currentFile) || isRunning || (importType === WKT && wktContent === '')\" (click)=\"import()\">{{ 'Import' | translate}}</button>\n  <mat-progress-spinner *ngIf=\"isRunning\" [color]=\"'accent'\" [diameter]=\"40\" [mode]=\"'indeterminate'\">\n  </mat-progress-spinner>\n</div>\n", styles: ["@charset \"UTF-8\";::ng-deep .map-import-dialog{--mdc-dialog-subhead-size: 20px;--mdc-dialog-subhead-tracking: 0;--mat-dialog-with-actions-content-padding: 0}::ng-deep .map-import-dialog .mdc-dialog__surface{padding:12px 24px}::ng-deep .map-import-dialog .mat-mdc-dialog-content{padding:0}.mapgl-import-body{min-width:500px;display:flex;flex-direction:column}.mapgl-import-zoom{display:flex;align-content:center;align-items:center;height:60px}.mapgl-import-error{color:#f44336;font-size:75%}.mapgl-import-upload{padding-left:10px;padding-top:10px}.mapgl-import-upload:focus{outline:none}.mapgl-import-radio-button{padding:10px}.mapgl-import-text-area{box-sizing:border-box;width:100%;height:200px;resize:vertical}\n"], dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i4.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "component", type: i5.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "disabledInteractive", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "directive", type: i1.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i1.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "component", type: i6.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "directive", type: i7.MatRadioGroup, selector: "mat-radio-group", inputs: ["color", "name", "labelPosition", "value", "selected", "disabled", "required", "disabledInteractive"], outputs: ["change"], exportAs: ["matRadioGroup"] }, { kind: "component", type: i7.MatRadioButton, selector: "mat-radio-button", inputs: ["id", "name", "aria-label", "aria-labelledby", "aria-describedby", "disableRipple", "tabIndex", "checked", "value", "labelPosition", "disabled", "required", "color", "disabledInteractive"], outputs: ["change"], exportAs: ["matRadioButton"] }, { kind: "pipe", type: i8.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-import-dialog', template: "<h1 mat-dialog-title class=\"mapgl-import-title\">{{ 'Import file' | translate}}</h1>\n<div mat-dialog-content class=\"mapgl-import-body\">\n  <mat-radio-group class=\"mapgl-import-radio-group\" [(ngModel)]=\"importType\" (change)=\"changeType()\">\n    <mat-radio-button *ngFor=\"let type of allowedImportType\" [value]=\"type\" class=\"mapgl-import-radio-button\">\n      {{ type | translate }}\n    </mat-radio-button>\n  </mat-radio-group>\n\n  <input *ngIf=\"importType !== WKT\" type=\"file\" class=\"mapgl-import-upload\" #fileInput accept=\"{{allowedFileExtension}}\" (change)=\"onFileChange($event.target.files)\">\n  <textarea *ngIf=\"importType === WKT\" class=\"mapgl-import-text-area\" [(ngModel)]=\"wktContent\" placeholder=\"{{'Paste your WKT' | translate}}\" (change)=\"onTextChange()\"></textarea>\n\n  <div class=\"mapgl-import-zoom\">\n    <mat-checkbox [(ngModel)]=\"fitResult\">{{ 'Zoom to result' | translate}}</mat-checkbox>\n  </div>\n  <div *ngIf=\"displayError\" class=\"mapgl-import-error\">\n    {{ errorMessage | translate}} <ng-container *ngIf=\"errorThreshold !== ''\"> - ({{'Max:' | translate }} {{errorThreshold}})</ng-container>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-import-actions\">\n  <button mat-button (click)=\"onCancel()\">{{ 'Cancel' | translate}}</button>\n  <button mat-button [disabled]=\"((importType === SHP || importType === KML || importType === GEOJSON) && !currentFile) || isRunning || (importType === WKT && wktContent === '')\" (click)=\"import()\">{{ 'Import' | translate}}</button>\n  <mat-progress-spinner *ngIf=\"isRunning\" [color]=\"'accent'\" [diameter]=\"40\" [mode]=\"'indeterminate'\">\n  </mat-progress-spinner>\n</div>\n", styles: ["@charset \"UTF-8\";::ng-deep .map-import-dialog{--mdc-dialog-subhead-size: 20px;--mdc-dialog-subhead-tracking: 0;--mat-dialog-with-actions-content-padding: 0}::ng-deep .map-import-dialog .mdc-dialog__surface{padding:12px 24px}::ng-deep .map-import-dialog .mat-mdc-dialog-content{padding:0}.mapgl-import-body{min-width:500px;display:flex;flex-direction:column}.mapgl-import-zoom{display:flex;align-content:center;align-items:center;height:60px}.mapgl-import-error{color:#f44336;font-size:75%}.mapgl-import-upload{padding-left:10px;padding-top:10px}.mapgl-import-upload:focus{outline:none}.mapgl-import-radio-button{padding:10px}.mapgl-import-text-area{box-sizing:border-box;width:100%;height:200px;resize:vertical}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialogRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }], propDecorators: { file: [{
                type: Output
            }], importRun: [{
                type: Output
            }], fileInput: [{
                type: ViewChild,
                args: ['fileInput', { static: false }]
            }] } });
const SIMPLE_GEOMETRY_OBJECT = ['Polygon', 'Point', 'LineString'];
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
export class MapImportComponent {
    constructor(dialog, mapService) {
        this.dialog = dialog;
        this.mapService = mapService;
        this.SHP = 'shp';
        this.KML = 'kml';
        this.WKT = 'wkt';
        this.GEOJSON = 'geojson';
        this.SELF_INTERSECT = marker('Geometry is not valid due to self-intersection');
        this.PARSING_ISSUE = marker('Problem parsing input file');
        this.FILE_TOO_LARGE = marker('File is too large');
        this.GEOMETRY_INVALID = marker('Geometry is not valid');
        this.TOO_MANY_VERTICES = marker('Too many vertices in a polygon');
        this.TOO_MANY_FEATURES = marker('Too many features');
        this.TIMEOUT = marker('Timeout');
        this.tooManyVertex = false;
        this.fitResult = false;
        this.SOURCE_NAME_POLYGON_LABEL = 'polygon_label';
        this.emptyData = {
            'type': 'FeatureCollection',
            'features': []
        };
        this.featureIndex = 0;
        this.maxLoadingTime = 20000;
        this.allowedImportType = [this.SHP, this.KML, this.WKT, this.GEOJSON];
        this.allowedGeometryObjectType = ['Polygon'];
        this.imported = new Subject();
        this.error = new Subject();
    }
    promiseTimeout(ms, promise) {
        // Create a promise that rejects in <ms> milliseconds
        const timeout = new Promise((resolve, reject) => {
            const id = setTimeout(() => {
                clearTimeout(id);
                reject(new Error(this.TIMEOUT));
            }, ms);
        });
        // Returns a race between our timeout and the passed in promise
        return Promise.race([
            promise,
            timeout
        ]);
    }
    buildAllowedGeometryForImportType(importType) {
        this._currentAllowedGeom = [];
        this.allowedGeometryObjectType.forEach(allowed => {
            this._currentAllowedGeom = this._currentAllowedGeom.concat(this.getAllowedGeom(allowed));
        });
        if (importType === this.KML) {
            this._currentAllowedGeom.push('GeometryCollection', 'MultiGeometry');
        }
        else if (importType === this.WKT) {
            this._currentAllowedGeom.push('GeometryCollection');
        }
    }
    getAllowedGeom(allowed) {
        if (allowed === 'Polygon') {
            return ['Polygon', 'MultiPolygon'];
        }
        if (allowed === 'Point') {
            return ['Point', 'MultiPoint'];
        }
    }
    openDialog(defaultFitResult) {
        this.dialogRef = this.dialog.open(MapImportDialogComponent, { data: { allowedImportType: this.allowedImportType, defaultFitResult }, panelClass: 'map-import-dialog' });
        this.dialogRef.componentInstance.file.subscribe((file) => {
            this.currentFile = file;
        });
        this.dialogRef.componentInstance.importRun.subscribe(importOptions => {
            this.fitResult = importOptions.fitResult;
            this.buildAllowedGeometryForImportType(importOptions.type);
            this.import(importOptions.type, importOptions.wktContent);
        });
    }
    import(importType, content) {
        this.dialogRef.componentInstance.isRunning = true;
        this.tooManyVertex = false;
        this.jszip = new JSZip();
        let processPromise;
        if (importType === this.SHP) {
            processPromise = this.processAllShape();
        }
        else if (importType === this.KML) {
            processPromise = this.processAllKml();
        }
        else if (importType === this.WKT) {
            processPromise = this.processWKT(content);
        }
        else if (importType === this.GEOJSON) {
            processPromise = this.processJson();
        }
        this.promiseTimeout(this.maxLoadingTime, processPromise).catch(error => {
            if (importType !== this.WKT) {
                this.reader.abort();
            }
            this.throwError(error);
        });
    }
    buildFeature(geom, feature, geometryType, bbox) {
        const f = {
            type: 'Feature',
            geometry: {
                coordinates: geom,
                type: geometryType ?? geom.type
            },
            properties: feature.properties
        };
        if (bbox) {
            f.geometry['bbox'] = feature.geometry.bbox;
        }
        return f;
    }
    handleSimpleGeometry(feature, centroids, importedGeojson) {
        // avoid self intersect control for point
        if (feature.geometry.type === 'Point' || gpsi(feature).geometry.coordinates.length === 0) {
            this.addFeature(feature, centroids, importedGeojson, ++this.featureIndex);
        }
        else {
            throw new Error('Geometry is not valid due to self-intersection');
        }
    }
    handleMultiGeometry(feature, centroids, importedGeojson) {
        // Create a new Polygon feature for each polygon in the MultiPolygon
        // All properties of the MultiPolygon are copied in each feature created
        const geomType = (feature.geometry.type === 'MultiPolygon') ? 'Polygon' : 'Point';
        feature.geometry.coordinates.forEach(geom => {
            const newFeature = this.buildFeature(geom, feature, geomType, true);
            this.handleSimpleGeometry(newFeature, centroids, importedGeojson);
        });
    }
    handleGeometryCollection(feature, centroids, importedGeojson) {
        // Create a new Polygon feature for each polygon in the MultiPolygon
        // All properties of the MultiPolygon are copied in each feature created
        const simpleGeometry = this._currentAllowedGeom.filter(g => SIMPLE_GEOMETRY_OBJECT.includes(g));
        feature.geometry.geometries.filter(geom => simpleGeometry.includes(geom.type)).forEach(geom => {
            const newFeature = this.buildFeature(geom, feature);
            this.handleSimpleGeometry(newFeature, centroids, importedGeojson);
        });
    }
    handleFeatureCollection(feature, centroids, importedGeojson) {
        feature.features.filter(feature => this._currentAllowedGeom.includes(feature.geometry.type))
            .forEach((feature) => {
            const multiGeometry = this._currentAllowedGeom.filter(g => !SIMPLE_GEOMETRY_OBJECT.includes(g));
            if (multiGeometry.includes(feature.geometry.type)) {
                this.handleMultiGeometry(feature, centroids, importedGeojson);
            }
            else {
                this.handleSimpleGeometry(feature, centroids, importedGeojson);
            }
        });
    }
    /** *************/
    /** *** KML *****/
    /** *************/
    readKmlFile() {
        return new Promise((resolve, reject) => {
            this.reader = new FileReader();
            const reader = this.reader;
            reader.onload = () => {
                resolve(reader.result);
            };
            reader.onerror = () => {
                reader.abort();
                reject(new Error(this.PARSING_ISSUE));
            };
            if (this.maxFileSize && this.currentFile.size > this.maxFileSize) {
                reject(new Error(this.FILE_TOO_LARGE));
            }
            else if (this.currentFile.name.split('.').pop().toLowerCase() === this.KML) {
                reader.readAsText(this.currentFile);
            }
            else if (this.currentFile.name.split('.').pop().toLowerCase() === 'kmz') {
                reader.readAsArrayBuffer(this.currentFile);
            }
            else {
                reject(new Error(marker('Only `kml` or `zip` file is allowed')));
            }
        });
    }
    resolveFileFromGzip(result, resolve) {
        this.jszip.loadAsync(result).then(kmzContent => {
            const kmlFile = Object.keys(kmzContent.files).filter(file => file.split('.').pop().toLowerCase() === this.KML)[0];
            this.jszip.file(kmlFile).async('text').then((data) => resolve(data));
        });
    }
    processAllKml() {
        const readKmlFile = this.readKmlFile();
        let readKmzFile = readKmlFile;
        if (this.currentFile.name.split('.').pop().toLowerCase() === 'kmz') {
            readKmzFile = readKmlFile.then(result => new Promise((resolve, reject) => {
                this.resolveFileFromGzip(result, resolve);
            }));
        }
        const parseKml = readKmzFile.then((file) => new Promise((resolve, reject) => {
            const geojson = toGeoJSON.kml((new DOMParser()).parseFromString(file, 'text/xml'));
            resolve(geojson);
        }));
        const geojsonParserPromise = parseKml.then((geojson) => new Promise((resolve, reject) => {
            this.computeGeojson(geojson, reject, resolve);
        }));
        return Promise.all([geojsonParserPromise])
            .then(([importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** * GEOJSON ***/
    /** *************/
    readJsonFile() {
        return new Promise((resolve, reject) => {
            this.reader = new FileReader();
            const reader = this.reader;
            reader.onload = () => {
                resolve(reader.result);
            };
            reader.onerror = () => {
                reader.abort();
                reject(new Error(this.PARSING_ISSUE));
            };
            if (this.maxFileSize && this.currentFile.size > this.maxFileSize) {
                reject(new Error(this.FILE_TOO_LARGE));
            }
            else {
                const extension = this.currentFile.name.split('.').pop().toLowerCase();
                if (extension === 'json' || extension === 'geojson') {
                    reader.readAsText(this.currentFile);
                }
                else {
                    reject(new Error(marker('Only `json` or `geojson` file is allowed')));
                }
            }
        });
    }
    processJson() {
        const readJsonFile = this.readJsonFile();
        const parseJson = readJsonFile.then((fileContent) => new Promise((resolve, reject) => {
            const feature = JSON.parse(fileContent);
            if (valid(feature) && (this._currentAllowedGeom.includes(feature.geometry) || feature.type === 'FeatureCollection')) {
                const centroides = new Array();
                const importedGeojson = {
                    type: 'FeatureCollection',
                    features: []
                };
                try {
                    if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'Point')) {
                        this.handleSimpleGeometry(feature, centroides, importedGeojson);
                    }
                    else if (feature.geometry && (feature.geometry.type === 'MultiPolygon' || feature.geometry.type === 'MultiPoint')) {
                        this.handleMultiGeometry(feature, centroides, importedGeojson);
                    }
                    else if (feature.type && feature.type === 'FeatureCollection') {
                        this.handleFeatureCollection(feature, centroides, importedGeojson);
                    }
                    resolve({ geojson: importedGeojson, centroides: centroides });
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                reject(new Error(this.GEOMETRY_INVALID));
            }
        }));
        return Promise.all([parseJson])
            .then(([importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** ** SHAPE ****/
    /** *************/
    readZipFile() {
        return new Promise((resolve, reject) => {
            this.reader = new FileReader();
            const reader = this.reader;
            reader.onload = () => {
                const resultToArray = new Uint8Array(reader.result);
                if (resultToArray.length === 0) {
                    reader.abort();
                    reject(new Error(marker('File is empty')));
                }
                else {
                    resolve(reader.result);
                }
            };
            reader.onerror = () => {
                reader.abort();
                reject(new Error(this.PARSING_ISSUE));
            };
            if (this.maxFileSize && this.currentFile.size > this.maxFileSize) {
                reject(new Error(this.FILE_TOO_LARGE));
            }
            else if (this.currentFile.name.split('.').pop().toLowerCase() !== 'zip') {
                reject(new Error(marker('Only `zip` file is allowed')));
            }
            else {
                reader.readAsArrayBuffer(this.currentFile);
            }
        });
    }
    areFilesInvalid(zipResult) {
        const testArray = Object.keys(zipResult.files).map(fileName => fileName.split('.').pop().toLowerCase());
        return (testArray.filter(elem => elem === this.SHP || elem === 'shx' || elem === 'dbf').length < 3) &&
            (testArray.filter(elem => elem === 'json').length !== 1);
    }
    processAllShape() {
        const fileReaderPromise = this.readZipFile();
        const zipLoaderPromise = fileReaderPromise.then((buffer) => new Promise((resolve, reject) => {
            this.jszip.loadAsync(buffer).then(zipResult => {
                if (this.areFilesInvalid(zipResult)) {
                    reject(new Error(marker('Zip file must contain at least a `*.shp`, `*.shx` and `*.dbf` or a `*.json`')));
                }
                else {
                    resolve(buffer);
                }
            });
        }));
        const shapeParserPromise = zipLoaderPromise
            .then(buffer => shp(buffer));
        const geojsonParserPromise = shapeParserPromise.then(geojson => new Promise((resolve, reject) => {
            this.computeGeojson(geojson, reject, resolve);
        }));
        return Promise.all([fileReaderPromise, zipLoaderPromise, shapeParserPromise, geojsonParserPromise])
            .then(([a, b, c, importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** **  WKT  ****/
    /** *************/
    processWKT(wkt) {
        const wktParserPromise = new Promise((resolve, reject) => {
            const geojsonWKT = parse(wkt);
            const centroides = new Array();
            const importedGeojson = {
                type: 'FeatureCollection',
                features: []
            };
            if (geojsonWKT && valid(geojsonWKT) && this._currentAllowedGeom.includes(geojsonWKT.type)) {
                const feature = {
                    type: 'Feature',
                    geometry: geojsonWKT,
                    properties: { arlas_id: null }
                };
                this.handleGeom(feature, centroides, importedGeojson, reject);
                resolve({ geojson: importedGeojson, centroides: centroides });
            }
            else {
                reject(new Error(this.GEOMETRY_INVALID));
            }
        });
        return Promise.all([wktParserPromise]).then(([importedResult]) => {
            this.setImportedData(importedResult);
        });
    }
    /** *************/
    /** ** TOOLS ****/
    /** *************/
    clearPolygons() {
        // Clean source of imported polygons
        const labelSource = this.mapService.getSource(this.SOURCE_NAME_POLYGON_LABEL, this.mapComponent.map);
        this.featureIndex = 0;
        this.mapComponent.onAoiChanged.next(this.emptyData);
        if (labelSource !== undefined) {
            this.mapService.setDataToGeojsonSource(labelSource, this.emptyData);
        }
    }
    addFeature(feature, centroides, importedGeojson, index) {
        feature.properties.arlas_id = index;
        const cent = this.calcCentroid(feature);
        centroides.push(cent);
        importedGeojson.features.push(feature);
    }
    setImportedData(importedResult) {
        if (this.tooManyVertex) {
            throw new Error(this.TOO_MANY_VERTICES);
        }
        else if (this.maxFeatures && importedResult.geojson.features.length > this.maxFeatures) {
            throw new Error(this.TOO_MANY_FEATURES);
        }
        else if (importedResult.geojson.features.length > 0) {
            this.dialogRef.componentInstance.isRunning = false;
            if (this.fitResult) {
                this.mapComponent.fitToPaddedBounds(extent(importedResult.geojson));
            }
            if (this.mapComponent.drawData.features.length > 0) {
                this.mapComponent.drawData.features.forEach(df => importedResult.geojson.features.push(df));
            }
            this.mapComponent.drawComponent.draw.changeMode('static');
            this.imported.next(importedResult.geojson.features);
            this.mapComponent.onAoiChanged.next(importedResult.geojson);
            this.dialogRef.close();
        }
        else {
            throw new Error(marker('No polygon to display in this file'));
        }
    }
    calcCentroid(feature) {
        let cent;
        if (feature.type === 'Point') {
            cent = centroid(feature);
        }
        else {
            if (!this.maxVertexByPolygon) {
                this.maxVertexByPolygon = 100;
            }
            if (this.maxVertexByPolygon && feature.geometry.coordinates[0].length - 1 > this.maxVertexByPolygon) {
                this.tooManyVertex = true;
            }
            const poly = polygon(feature.geometry.coordinates);
            cent = centroid(poly);
        }
        cent.properties.arlas_id = feature.properties.arlas_id;
        return cent;
    }
    throwError(error) {
        this.dialogRef.componentInstance.displayError = true;
        this.dialogRef.componentInstance.isRunning = false;
        this.dialogRef.componentInstance.errorMessage = error.message;
        switch (this.dialogRef.componentInstance.errorMessage) {
            case this.TOO_MANY_FEATURES:
                this.dialogRef.componentInstance.errorThreshold = this.maxFeatures.toString();
                break;
            case this.TOO_MANY_VERTICES:
                this.dialogRef.componentInstance.errorThreshold = this.maxVertexByPolygon.toString();
                break;
            case this.FILE_TOO_LARGE:
                this.dialogRef.componentInstance.errorThreshold = this.formatBytes(this.maxFileSize);
                break;
            case this.TIMEOUT:
                this.dialogRef.componentInstance.errorThreshold = this.maxLoadingTime + ' ms';
                break;
            default:
                this.dialogRef.componentInstance.errorThreshold = '';
        }
        if (this.dialogRef.componentInstance.fileInput) {
            this.dialogRef.componentInstance.fileInput.nativeElement.value = '';
        }
        this.dialogRef.componentInstance.currentFile = null;
        this.error.next(error.message);
    }
    formatBytes(bytes, decimals = 2) {
        if (bytes === 0) {
            return '0 Bytes';
        }
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    computeGeojson(geojson, reject, resolve) {
        if (valid(geojson)) {
            const centroides = new Array();
            const importedGeojson = {
                type: 'FeatureCollection',
                features: []
            };
            geojson.features.filter(feature => this._currentAllowedGeom.includes(feature.geometry.type))
                .forEach((feature) => {
                this.handleGeom(feature, centroides, importedGeojson, reject);
            });
            resolve({ geojson: importedGeojson, centroides: centroides });
        }
        else {
            reject(new Error('Geometry is not valid'));
        }
    }
    handleGeom(feature, centroides, importedGeojson, reject) {
        try {
            if (feature.geometry.type === 'GeometryCollection' || feature.geometry.type === 'MultiGeometry') {
                // Create a new Polygon feature for each polygon in the MultiPolygon
                // All properties of the MultiPolygon are copied in each feature created
                this.handleGeometryCollection(feature, centroides, importedGeojson);
            }
            else if (feature.geometry.type === 'MultiPolygon' || feature.geometry.type === 'MultiPoint') {
                this.handleMultiGeometry(feature, centroides, importedGeojson);
            }
            else {
                this.handleSimpleGeometry(feature, centroides, importedGeojson);
            }
        }
        catch (e) {
            reject(new Error('Error during import'));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportComponent, deps: [{ token: i1.MatDialog }, { token: i9.ArlasMapFrameworkService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapImportComponent, selector: "arlas-map-import", inputs: { mapComponent: "mapComponent", maxVertexByPolygon: "maxVertexByPolygon", maxFeatures: "maxFeatures", maxFileSize: "maxFileSize", maxLoadingTime: "maxLoadingTime", allowedImportType: "allowedImportType", allowedGeometryObjectType: "allowedGeometryObjectType" }, outputs: { imported: "imported", error: "error" }, ngImport: i0, template: "\n\n", styles: ["@charset \"UTF-8\";\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapImportComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-import', template: "\n\n", styles: ["@charset \"UTF-8\";\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }, { type: i9.ArlasMapFrameworkService }], propDecorators: { mapComponent: [{
                type: Input
            }], maxVertexByPolygon: [{
                type: Input
            }], maxFeatures: [{
                type: Input
            }], maxFileSize: [{
                type: Input
            }], maxLoadingTime: [{
                type: Input
            }], allowedImportType: [{
                type: Input
            }], allowedGeometryObjectType: [{
                type: Input
            }], imported: [{
                type: Output
            }], error: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLWltcG9ydC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hcmxhcy1tYXAvc3JjL2xpYi9tYXAtaW1wb3J0L21hcC1pbXBvcnQuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYXJsYXMtbWFwL3NyYy9saWIvbWFwLWltcG9ydC9tYXAtaW1wb3J0LWRpYWxvZy5jb21wb25lbnQuaHRtbCIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FybGFzLW1hcC9zcmMvbGliL21hcC1pbXBvcnQvbWFwLWltcG9ydC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFFSCxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEYsT0FBTyxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDcEYsT0FBTyxLQUFLLFNBQVMsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLFFBQVEsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0QyxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxFQUFxQixPQUFPLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEtBQUssSUFBSSxNQUFNLGdCQUFnQixDQUFDO0FBQ3ZDLE9BQU8sS0FBSyxPQUFPLE1BQU0sYUFBYSxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSww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cmNlc0NvbnRlbnQiOlsiLypcbiAqIExpY2Vuc2VkIHRvIEdpc2HDr2EgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UudHh0IGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gR2lzYcOvYSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1BVF9ESUFMT0dfREFUQSwgTWF0RGlhbG9nLCBNYXREaWFsb2dSZWYgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9kaWFsb2cnO1xuaW1wb3J0ICogYXMgdG9HZW9KU09OIGZyb20gJ0B0bWN3L3RvZ2VvanNvbic7XG5pbXBvcnQgY2VudHJvaWQgZnJvbSAnQHR1cmYvY2VudHJvaWQnO1xuaW1wb3J0IEpTWmlwIGZyb20gJ2pzemlwJztcbmltcG9ydCB7IEZlYXR1cmVDb2xsZWN0aW9uLCBwb2x5Z29uIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgKiBhcyBzaHBfIGZyb20gJ3NocGpzL2Rpc3Qvc2hwJztcbmltcG9ydCAqIGFzIGV4dGVudF8gZnJvbSAndHVyZi1leHRlbnQnO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICd3ZWxsa25vd24nO1xuaW1wb3J0IHsgdmFsaWQgfSBmcm9tICdnZW9qc29uLXZhbGlkYXRpb24nO1xuaW1wb3J0IHsgbWFya2VyIH0gZnJvbSAnQGNvbHNlbjE5OTEvbmd4LXRyYW5zbGF0ZS1leHRyYWN0LW1hcmtlcic7XG5pbXBvcnQgKiBhcyBncHNpXyBmcm9tICdnZW9qc29uLXBvbHlnb24tc2VsZi1pbnRlcnNlY3Rpb25zJztcbmltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICdnZW9qc29uJztcbmltcG9ydCB7IEFybGFzTWFwQ29tcG9uZW50IH0gZnJvbSAnLi4vYXJsYXMtbWFwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBcmxhc01hcEZyYW1ld29ya1NlcnZpY2UgfSBmcm9tICcuLi9hcmxhcy1tYXAtZnJhbWV3b3JrLnNlcnZpY2UnO1xuXG5cbmNvbnN0IGdwc2kgPSBncHNpXy5kZWZhdWx0O1xuY29uc3Qgc2hwID0gc2hwXy5kZWZhdWx0O1xuY29uc3QgZXh0ZW50ID0gZXh0ZW50Xy5kZWZhdWx0O1xuXG5cbkBDb21wb25lbnQoe1xuICB0ZW1wbGF0ZVVybDogJy4vbWFwLWltcG9ydC1kaWFsb2cuY29tcG9uZW50Lmh0bWwnLFxuICBzZWxlY3RvcjogJ2FybGFzLW1hcC1pbXBvcnQtZGlhbG9nJyxcbiAgc3R5bGVVcmxzOiBbJy4vbWFwLWltcG9ydC1kaWFsb2cuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBNYXBJbXBvcnREaWFsb2dDb21wb25lbnQge1xuICBwdWJsaWMgZGlzcGxheUVycm9yID0gZmFsc2U7XG4gIHB1YmxpYyBpc1J1bm5pbmcgPSBmYWxzZTtcbiAgcHVibGljIGZpdFJlc3VsdCA9IGZhbHNlO1xuICBwdWJsaWMgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XG4gIHB1YmxpYyBlcnJvclRocmVzaG9sZDogc3RyaW5nO1xuICBwdWJsaWMgY3VycmVudEZpbGU6IEZpbGU7XG5cbiAgcHVibGljIGltcG9ydFR5cGU6IHN0cmluZztcbiAgcHVibGljIGFsbG93ZWRGaWxlRXh0ZW5zaW9uOiBzdHJpbmc7XG4gIHB1YmxpYyBhbGxvd2VkSW1wb3J0VHlwZTogc3RyaW5nW107XG4gIHB1YmxpYyB3a3RDb250ZW50ID0gJyc7XG5cbiAgcHVibGljIFNIUDogc3RyaW5nID0gbWFya2VyKCdzaHAnKTtcbiAgcHVibGljIEtNTDogc3RyaW5nID0gbWFya2VyKCdrbWwnKTtcbiAgcHVibGljIFdLVDogc3RyaW5nID0gbWFya2VyKCd3a3QnKTtcbiAgcHVibGljIEdFT0pTT046IHN0cmluZyA9IG1hcmtlcignZ2VvanNvbicpO1xuXG4gIEBPdXRwdXQoKSBwdWJsaWMgZmlsZSA9IG5ldyBTdWJqZWN0PEZpbGU+KCk7XG4gIEBPdXRwdXQoKSBwdWJsaWMgaW1wb3J0UnVuID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBAVmlld0NoaWxkKCdmaWxlSW5wdXQnLCB7IHN0YXRpYzogZmFsc2UgfSkgcHVibGljIGZpbGVJbnB1dDogRWxlbWVudFJlZjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkaWFsb2dSZWY6IE1hdERpYWxvZ1JlZjxNYXBJbXBvcnREaWFsb2dDb21wb25lbnQ+LFxuICAgIEBJbmplY3QoTUFUX0RJQUxPR19EQVRBKSBwcml2YXRlIGRhdGE6IHsgYWxsb3dlZEltcG9ydFR5cGU6IEFycmF5PHN0cmluZz47IGRlZmF1bHRGaXRSZXN1bHQ/OiBib29sZWFuOyB9XG4gICkge1xuICAgIHRoaXMuZml0UmVzdWx0ID0gZGF0YS5kZWZhdWx0Rml0UmVzdWx0ID8/IGZhbHNlO1xuICAgIHRoaXMuYWxsb3dlZEltcG9ydFR5cGUgPSB0aGlzLmRhdGEuYWxsb3dlZEltcG9ydFR5cGUuZmlsdGVyKHQgPT4gW3RoaXMuU0hQLCB0aGlzLktNTCwgdGhpcy5XS1QsIHRoaXMuR0VPSlNPTl0uaW5jbHVkZXModCkpO1xuXG4gICAgaWYgKHRoaXMuYWxsb3dlZEltcG9ydFR5cGUuaW5kZXhPZih0aGlzLlNIUCkgPiAtMSkge1xuICAgICAgdGhpcy5pbXBvcnRUeXBlID0gdGhpcy5TSFA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFsbG93ZWRJbXBvcnRUeXBlLmluZGV4T2YodGhpcy5LTUwpID4gLTEpIHtcbiAgICAgIHRoaXMuaW1wb3J0VHlwZSA9IHRoaXMuS01MO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hbGxvd2VkSW1wb3J0VHlwZS5pbmRleE9mKHRoaXMuV0tUKSA+IC0xKSB7XG4gICAgICB0aGlzLmltcG9ydFR5cGUgPSB0aGlzLldLVDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbXBvcnRUeXBlID0gdGhpcy5HRU9KU09OO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVR5cGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkZpbGVDaGFuZ2UoZmlsZXM6IEZpbGVMaXN0KSB7XG4gICAgdGhpcy5maWxlLm5leHQoZmlsZXMuaXRlbSgwKSk7XG4gICAgdGhpcy5jdXJyZW50RmlsZSA9IGZpbGVzLml0ZW0oMCk7XG4gICAgdGhpcy5kaXNwbGF5RXJyb3IgPSBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBpbXBvcnQoKSB7XG4gICAgdGhpcy5pbXBvcnRSdW4ubmV4dCh7IHR5cGU6IHRoaXMuaW1wb3J0VHlwZSwgZml0UmVzdWx0OiB0aGlzLmZpdFJlc3VsdCwgd2t0Q29udGVudDogdGhpcy53a3RDb250ZW50IH0pO1xuICB9XG5cbiAgcHVibGljIG9uVGV4dENoYW5nZSgpIHsgfVxuXG4gIHB1YmxpYyBjaGFuZ2VUeXBlKCkge1xuICAgIGlmICh0aGlzLmltcG9ydFR5cGUgPT09IHRoaXMuU0hQKSB7XG4gICAgICB0aGlzLmFsbG93ZWRGaWxlRXh0ZW5zaW9uID0gJy56aXAnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbXBvcnRUeXBlID09PSB0aGlzLktNTCkge1xuICAgICAgdGhpcy5hbGxvd2VkRmlsZUV4dGVuc2lvbiA9ICcua21sLC5rbXonO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbXBvcnRUeXBlID09PSB0aGlzLkdFT0pTT04pIHtcbiAgICAgIHRoaXMuYWxsb3dlZEZpbGVFeHRlbnNpb24gPSAnLmpzb24sLmdlb2pzb24nO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvbkNhbmNlbCgpIHtcbiAgICB0aGlzLmRpYWxvZ1JlZi5jbG9zZSgpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEFsbG93ZWRJbXBvcnRHZW9tZXRyeSA9ICdQb2x5Z29uJyB8ICdQb2ludCc7XG5jb25zdCBTSU1QTEVfR0VPTUVUUllfT0JKRUNUID0gWydQb2x5Z29uJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnXTtcbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2FybGFzLW1hcC1pbXBvcnQnLFxuICB0ZW1wbGF0ZVVybDogJy4vbWFwLWltcG9ydC5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL21hcC1pbXBvcnQuY29tcG9uZW50LnNjc3MnXVxufSlcbi8qKiBMOiBhIGxheWVyIGNsYXNzL2ludGVyZmFjZS5cbiAqICBTOiBhIHNvdXJjZSBjbGFzcy9pbnRlcmZhY2UuXG4gKiAgTTogYSBNYXAgY29uZmlndXJhdGlvbiBjbGFzcy9pbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXBJbXBvcnRDb21wb25lbnQ8TCwgUywgTT4ge1xuXG4gIHB1YmxpYyBTSFAgPSAnc2hwJztcbiAgcHVibGljIEtNTCA9ICdrbWwnO1xuICBwdWJsaWMgV0tUID0gJ3drdCc7XG4gIHB1YmxpYyBHRU9KU09OID0gJ2dlb2pzb24nO1xuXG4gIHB1YmxpYyBTRUxGX0lOVEVSU0VDVCA9IG1hcmtlcignR2VvbWV0cnkgaXMgbm90IHZhbGlkIGR1ZSB0byBzZWxmLWludGVyc2VjdGlvbicpO1xuICBwdWJsaWMgUEFSU0lOR19JU1NVRSA9IG1hcmtlcignUHJvYmxlbSBwYXJzaW5nIGlucHV0IGZpbGUnKTtcbiAgcHVibGljIEZJTEVfVE9PX0xBUkdFID0gbWFya2VyKCdGaWxlIGlzIHRvbyBsYXJnZScpO1xuICBwdWJsaWMgR0VPTUVUUllfSU5WQUxJRCA9IG1hcmtlcignR2VvbWV0cnkgaXMgbm90IHZhbGlkJyk7XG4gIHB1YmxpYyBUT09fTUFOWV9WRVJUSUNFUyA9IG1hcmtlcignVG9vIG1hbnkgdmVydGljZXMgaW4gYSBwb2x5Z29uJyk7XG4gIHB1YmxpYyBUT09fTUFOWV9GRUFUVVJFUyA9IG1hcmtlcignVG9vIG1hbnkgZmVhdHVyZXMnKTtcbiAgcHVibGljIFRJTUVPVVQgPSBtYXJrZXIoJ1RpbWVvdXQnKTtcblxuICBwdWJsaWMgY3VycmVudEZpbGU6IEZpbGU7XG4gIHB1YmxpYyBkaWFsb2dSZWY6IE1hdERpYWxvZ1JlZjxNYXBJbXBvcnREaWFsb2dDb21wb25lbnQ+O1xuICBwdWJsaWMgcmVhZGVyOiBGaWxlUmVhZGVyO1xuXG4gIHByaXZhdGUgdG9vTWFueVZlcnRleCA9IGZhbHNlO1xuICBwcml2YXRlIGZpdFJlc3VsdCA9IGZhbHNlO1xuICBwcml2YXRlIGpzemlwOiBKU1ppcDtcbiAgcHJpdmF0ZSByZWFkb25seSBTT1VSQ0VfTkFNRV9QT0xZR09OX0xBQkVMID0gJ3BvbHlnb25fbGFiZWwnO1xuICBwcml2YXRlIGVtcHR5RGF0YTogRmVhdHVyZUNvbGxlY3Rpb248R2VvSlNPTi5HZW9tZXRyeT4gPSB7XG4gICAgJ3R5cGUnOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICdmZWF0dXJlcyc6IFtdXG4gIH07XG4gIHByaXZhdGUgZmVhdHVyZUluZGV4ID0gMDtcblxuICBASW5wdXQoKSBwdWJsaWMgbWFwQ29tcG9uZW50OiBBcmxhc01hcENvbXBvbmVudDxMLCBTLCBNPjtcbiAgQElucHV0KCkgcHVibGljIG1heFZlcnRleEJ5UG9seWdvbjogbnVtYmVyO1xuICBASW5wdXQoKSBwdWJsaWMgbWF4RmVhdHVyZXM/OiBudW1iZXI7XG4gIEBJbnB1dCgpIHB1YmxpYyBtYXhGaWxlU2l6ZT86IG51bWJlcjtcbiAgQElucHV0KCkgcHVibGljIG1heExvYWRpbmdUaW1lID0gMjAwMDA7XG4gIEBJbnB1dCgpIHB1YmxpYyBhbGxvd2VkSW1wb3J0VHlwZSA9IFt0aGlzLlNIUCwgdGhpcy5LTUwsIHRoaXMuV0tULCB0aGlzLkdFT0pTT05dO1xuICBASW5wdXQoKSBwdWJsaWMgYWxsb3dlZEdlb21ldHJ5T2JqZWN0VHlwZTogQXJyYXk8QWxsb3dlZEltcG9ydEdlb21ldHJ5PiA9IFsnUG9seWdvbiddO1xuICBAT3V0cHV0KCkgcHVibGljIGltcG9ydGVkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBAT3V0cHV0KCkgcHVibGljIGVycm9yID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwcml2YXRlIF9jdXJyZW50QWxsb3dlZEdlb206IHN0cmluZ1tdO1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGRpYWxvZzogTWF0RGlhbG9nLFxuICAgIHB1YmxpYyBtYXBTZXJ2aWNlOiBBcmxhc01hcEZyYW1ld29ya1NlcnZpY2U8TCwgUywgTT5cbiAgKSB7IH1cblxuICBwdWJsaWMgcHJvbWlzZVRpbWVvdXQobXMsIHByb21pc2UpIHtcblxuICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCByZWplY3RzIGluIDxtcz4gbWlsbGlzZWNvbmRzXG4gICAgY29uc3QgdGltZW91dCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IodGhpcy5USU1FT1VUKSk7XG4gICAgICB9LCBtcyk7XG4gICAgfSk7XG5cbiAgICAvLyBSZXR1cm5zIGEgcmFjZSBiZXR3ZWVuIG91ciB0aW1lb3V0IGFuZCB0aGUgcGFzc2VkIGluIHByb21pc2VcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIHByb21pc2UsXG4gICAgICB0aW1lb3V0XG4gICAgXSk7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkQWxsb3dlZEdlb21ldHJ5Rm9ySW1wb3J0VHlwZShpbXBvcnRUeXBlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9jdXJyZW50QWxsb3dlZEdlb20gPSBbXTtcbiAgICB0aGlzLmFsbG93ZWRHZW9tZXRyeU9iamVjdFR5cGUuZm9yRWFjaChhbGxvd2VkID0+IHtcbiAgICAgIHRoaXMuX2N1cnJlbnRBbGxvd2VkR2VvbSA9IHRoaXMuX2N1cnJlbnRBbGxvd2VkR2VvbS5jb25jYXQodGhpcy5nZXRBbGxvd2VkR2VvbShhbGxvd2VkKSk7XG4gICAgfSk7XG4gICAgaWYgKGltcG9ydFR5cGUgPT09IHRoaXMuS01MKSB7XG4gICAgICB0aGlzLl9jdXJyZW50QWxsb3dlZEdlb20ucHVzaCgnR2VvbWV0cnlDb2xsZWN0aW9uJywgJ011bHRpR2VvbWV0cnknKTtcbiAgICB9IGVsc2UgaWYgKGltcG9ydFR5cGUgPT09IHRoaXMuV0tUKSB7XG4gICAgICB0aGlzLl9jdXJyZW50QWxsb3dlZEdlb20ucHVzaCgnR2VvbWV0cnlDb2xsZWN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBbGxvd2VkR2VvbShhbGxvd2VkOiBBbGxvd2VkSW1wb3J0R2VvbWV0cnkpOiBzdHJpbmdbXSB7XG4gICAgaWYgKGFsbG93ZWQgPT09ICdQb2x5Z29uJykge1xuICAgICAgcmV0dXJuIFsnUG9seWdvbicsICdNdWx0aVBvbHlnb24nXTtcbiAgICB9XG4gICAgaWYgKGFsbG93ZWQgPT09ICdQb2ludCcpIHtcbiAgICAgIHJldHVybiBbJ1BvaW50JywgJ011bHRpUG9pbnQnXTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb3BlbkRpYWxvZyhkZWZhdWx0Rml0UmVzdWx0PzogYm9vbGVhbikge1xuICAgIHRoaXMuZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihNYXBJbXBvcnREaWFsb2dDb21wb25lbnQsXG4gICAgICB7IGRhdGE6IHsgYWxsb3dlZEltcG9ydFR5cGU6IHRoaXMuYWxsb3dlZEltcG9ydFR5cGUsIGRlZmF1bHRGaXRSZXN1bHQgfSwgcGFuZWxDbGFzczogJ21hcC1pbXBvcnQtZGlhbG9nJyB9KTtcbiAgICB0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5maWxlLnN1YnNjcmliZSgoZmlsZTogRmlsZSkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50RmlsZSA9IGZpbGU7XG4gICAgfSk7XG4gICAgdGhpcy5kaWFsb2dSZWYuY29tcG9uZW50SW5zdGFuY2UuaW1wb3J0UnVuLnN1YnNjcmliZShpbXBvcnRPcHRpb25zID0+IHtcbiAgICAgIHRoaXMuZml0UmVzdWx0ID0gaW1wb3J0T3B0aW9ucy5maXRSZXN1bHQ7XG4gICAgICB0aGlzLmJ1aWxkQWxsb3dlZEdlb21ldHJ5Rm9ySW1wb3J0VHlwZShpbXBvcnRPcHRpb25zLnR5cGUpO1xuICAgICAgdGhpcy5pbXBvcnQoaW1wb3J0T3B0aW9ucy50eXBlLCBpbXBvcnRPcHRpb25zLndrdENvbnRlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGltcG9ydChpbXBvcnRUeXBlOiBzdHJpbmcsIGNvbnRlbnQ/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5pc1J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMudG9vTWFueVZlcnRleCA9IGZhbHNlO1xuICAgIHRoaXMuanN6aXAgPSBuZXcgSlNaaXAoKTtcbiAgICBsZXQgcHJvY2Vzc1Byb21pc2U6IFByb21pc2U8dm9pZD47XG4gICAgaWYgKGltcG9ydFR5cGUgPT09IHRoaXMuU0hQKSB7XG4gICAgICBwcm9jZXNzUHJvbWlzZSA9IHRoaXMucHJvY2Vzc0FsbFNoYXBlKCk7XG4gICAgfSBlbHNlIGlmIChpbXBvcnRUeXBlID09PSB0aGlzLktNTCkge1xuICAgICAgcHJvY2Vzc1Byb21pc2UgPSB0aGlzLnByb2Nlc3NBbGxLbWwoKTtcbiAgICB9IGVsc2UgaWYgKGltcG9ydFR5cGUgPT09IHRoaXMuV0tUKSB7XG4gICAgICBwcm9jZXNzUHJvbWlzZSA9IHRoaXMucHJvY2Vzc1dLVChjb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKGltcG9ydFR5cGUgPT09IHRoaXMuR0VPSlNPTikge1xuICAgICAgcHJvY2Vzc1Byb21pc2UgPSB0aGlzLnByb2Nlc3NKc29uKCk7XG4gICAgfVxuICAgIHRoaXMucHJvbWlzZVRpbWVvdXQodGhpcy5tYXhMb2FkaW5nVGltZSwgcHJvY2Vzc1Byb21pc2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGlmIChpbXBvcnRUeXBlICE9PSB0aGlzLldLVCkge1xuICAgICAgICB0aGlzLnJlYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50aHJvd0Vycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBidWlsZEZlYXR1cmUoZ2VvbTogYW55LCBmZWF0dXJlOiBGZWF0dXJlIHwgYW55LCBnZW9tZXRyeVR5cGU/OiBzdHJpbmcsIGJib3g/OiBib29sZWFuKSB7XG4gICAgY29uc3QgZiA9IHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIGNvb3JkaW5hdGVzOiBnZW9tLFxuICAgICAgICB0eXBlOiBnZW9tZXRyeVR5cGUgPz8gZ2VvbS50eXBlXG4gICAgICB9LFxuICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzXG4gICAgfTtcblxuICAgIGlmIChiYm94KSB7XG4gICAgICBmLmdlb21ldHJ5WydiYm94J10gPSBmZWF0dXJlLmdlb21ldHJ5LmJib3g7XG4gICAgfVxuICAgIHJldHVybiBmO1xuICB9XG5cbiAgcHVibGljIGhhbmRsZVNpbXBsZUdlb21ldHJ5KGZlYXR1cmUsIGNlbnRyb2lkcywgaW1wb3J0ZWRHZW9qc29uKSB7XG4gICAgLy8gYXZvaWQgc2VsZiBpbnRlcnNlY3QgY29udHJvbCBmb3IgcG9pbnRcbiAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnIHx8IGdwc2koZmVhdHVyZSkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmFkZEZlYXR1cmUoZmVhdHVyZSwgY2VudHJvaWRzLCBpbXBvcnRlZEdlb2pzb24sICsrdGhpcy5mZWF0dXJlSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlb21ldHJ5IGlzIG5vdCB2YWxpZCBkdWUgdG8gc2VsZi1pbnRlcnNlY3Rpb24nKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaGFuZGxlTXVsdGlHZW9tZXRyeShmZWF0dXJlLCBjZW50cm9pZHMsIGltcG9ydGVkR2VvanNvbikge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBQb2x5Z29uIGZlYXR1cmUgZm9yIGVhY2ggcG9seWdvbiBpbiB0aGUgTXVsdGlQb2x5Z29uXG4gICAgLy8gQWxsIHByb3BlcnRpZXMgb2YgdGhlIE11bHRpUG9seWdvbiBhcmUgY29waWVkIGluIGVhY2ggZmVhdHVyZSBjcmVhdGVkXG4gICAgY29uc3QgZ2VvbVR5cGUgPSAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykgPyAnUG9seWdvbicgOiAnUG9pbnQnO1xuICAgIGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChnZW9tID0+IHtcbiAgICAgIGNvbnN0IG5ld0ZlYXR1cmUgPSB0aGlzLmJ1aWxkRmVhdHVyZShnZW9tLCBmZWF0dXJlLCBnZW9tVHlwZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmhhbmRsZVNpbXBsZUdlb21ldHJ5KG5ld0ZlYXR1cmUsIGNlbnRyb2lkcywgaW1wb3J0ZWRHZW9qc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBoYW5kbGVHZW9tZXRyeUNvbGxlY3Rpb24oZmVhdHVyZSwgY2VudHJvaWRzLCBpbXBvcnRlZEdlb2pzb24pIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgUG9seWdvbiBmZWF0dXJlIGZvciBlYWNoIHBvbHlnb24gaW4gdGhlIE11bHRpUG9seWdvblxuICAgIC8vIEFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBNdWx0aVBvbHlnb24gYXJlIGNvcGllZCBpbiBlYWNoIGZlYXR1cmUgY3JlYXRlZFxuICAgIGNvbnN0IHNpbXBsZUdlb21ldHJ5ID0gdGhpcy5fY3VycmVudEFsbG93ZWRHZW9tLmZpbHRlcihnID0+IFNJTVBMRV9HRU9NRVRSWV9PQkpFQ1QuaW5jbHVkZXMoZykpO1xuICAgIGZlYXR1cmUuZ2VvbWV0cnkuZ2VvbWV0cmllcy5maWx0ZXIoZ2VvbSA9PiBzaW1wbGVHZW9tZXRyeS5pbmNsdWRlcyhnZW9tLnR5cGUpKS5mb3JFYWNoKGdlb20gPT4ge1xuICAgICAgY29uc3QgbmV3RmVhdHVyZSA9IHRoaXMuYnVpbGRGZWF0dXJlKGdlb20sIGZlYXR1cmUpO1xuICAgICAgdGhpcy5oYW5kbGVTaW1wbGVHZW9tZXRyeShuZXdGZWF0dXJlLCBjZW50cm9pZHMsIGltcG9ydGVkR2VvanNvbik7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaGFuZGxlRmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZSwgY2VudHJvaWRzLCBpbXBvcnRlZEdlb2pzb24pIHtcbiAgICBmZWF0dXJlLmZlYXR1cmVzLmZpbHRlcihmZWF0dXJlID0+IHRoaXMuX2N1cnJlbnRBbGxvd2VkR2VvbS5pbmNsdWRlcyhmZWF0dXJlLmdlb21ldHJ5LnR5cGUpKVxuICAgICAgLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgY29uc3QgbXVsdGlHZW9tZXRyeSA9IHRoaXMuX2N1cnJlbnRBbGxvd2VkR2VvbS5maWx0ZXIoZyA9PiAhU0lNUExFX0dFT01FVFJZX09CSkVDVC5pbmNsdWRlcyhnKSk7XG4gICAgICAgIGlmIChtdWx0aUdlb21ldHJ5LmluY2x1ZGVzKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSkpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU11bHRpR2VvbWV0cnkoZmVhdHVyZSwgY2VudHJvaWRzLCBpbXBvcnRlZEdlb2pzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGFuZGxlU2ltcGxlR2VvbWV0cnkoZmVhdHVyZSwgY2VudHJvaWRzLCBpbXBvcnRlZEdlb2pzb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqL1xuICAvKiogKioqIEtNTCAqKioqKi9cbiAgLyoqICoqKioqKioqKioqKiovXG4gIHB1YmxpYyByZWFkS21sRmlsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMucmVhZGVyO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgcmVhZGVyLmFib3J0KCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IodGhpcy5QQVJTSU5HX0lTU1VFKSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tYXhGaWxlU2l6ZSAmJiB0aGlzLmN1cnJlbnRGaWxlLnNpemUgPiB0aGlzLm1heEZpbGVTaXplKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IodGhpcy5GSUxFX1RPT19MQVJHRSkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRGaWxlLm5hbWUuc3BsaXQoJy4nKS5wb3AoKS50b0xvd2VyQ2FzZSgpID09PSB0aGlzLktNTCkge1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KHRoaXMuY3VycmVudEZpbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudEZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkgPT09ICdrbXonKSB7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHRoaXMuY3VycmVudEZpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobWFya2VyKCdPbmx5IGBrbWxgIG9yIGB6aXBgIGZpbGUgaXMgYWxsb3dlZCcpKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZUZpbGVGcm9tR3ppcChyZXN1bHQsIHJlc29sdmUpIHtcbiAgICB0aGlzLmpzemlwLmxvYWRBc3luYyhyZXN1bHQpLnRoZW4oa216Q29udGVudCA9PiB7XG4gICAgICBjb25zdCBrbWxGaWxlID0gT2JqZWN0LmtleXMoa216Q29udGVudC5maWxlcykuZmlsdGVyKGZpbGUgPT4gZmlsZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuS01MKVswXTtcbiAgICAgIHRoaXMuanN6aXAuZmlsZShrbWxGaWxlKS5hc3luYygndGV4dCcpLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHByb2Nlc3NBbGxLbWwoKSB7XG4gICAgY29uc3QgcmVhZEttbEZpbGUgPSB0aGlzLnJlYWRLbWxGaWxlKCk7XG5cbiAgICBsZXQgcmVhZEttekZpbGUgPSByZWFkS21sRmlsZTtcbiAgICBpZiAodGhpcy5jdXJyZW50RmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKSA9PT0gJ2tteicpIHtcbiAgICAgIHJlYWRLbXpGaWxlID0gcmVhZEttbEZpbGUudGhlbihyZXN1bHQgPT4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmVGaWxlRnJvbUd6aXAocmVzdWx0LCByZXNvbHZlKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZUttbCA9IHJlYWRLbXpGaWxlLnRoZW4oKGZpbGU6IHN0cmluZykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZ2VvanNvbiA9IHRvR2VvSlNPTi5rbWwoKG5ldyBET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKGZpbGUsICd0ZXh0L3htbCcpKTtcbiAgICAgIHJlc29sdmUoZ2VvanNvbik7XG4gICAgfSkpO1xuICAgIGNvbnN0IGdlb2pzb25QYXJzZXJQcm9taXNlID0gcGFyc2VLbWwudGhlbigoZ2VvanNvbjogYW55KSA9PiBuZXcgUHJvbWlzZTx7IGdlb2pzb246IGFueTsgY2VudHJvaWRlczogYW55OyB9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbXB1dGVHZW9qc29uKGdlb2pzb24sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsPHsgZ2VvanNvbjogYW55OyBjZW50cm9pZGVzOiBhbnk7IH0+KFtnZW9qc29uUGFyc2VyUHJvbWlzZV0pXG4gICAgICAudGhlbigoW2ltcG9ydGVkUmVzdWx0XSkgPT4ge1xuICAgICAgICB0aGlzLnNldEltcG9ydGVkRGF0YShpbXBvcnRlZFJlc3VsdCk7XG4gICAgICB9KTtcbiAgfVxuXG5cbiAgLyoqICoqKioqKioqKioqKiovXG4gIC8qKiAqIEdFT0pTT04gKioqL1xuICAvKiogKioqKioqKioqKioqKi9cbiAgcHVibGljIHJlYWRKc29uRmlsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMucmVhZGVyO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgcmVhZGVyLmFib3J0KCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IodGhpcy5QQVJTSU5HX0lTU1VFKSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tYXhGaWxlU2l6ZSAmJiB0aGlzLmN1cnJlbnRGaWxlLnNpemUgPiB0aGlzLm1heEZpbGVTaXplKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IodGhpcy5GSUxFX1RPT19MQVJHRSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5jdXJyZW50RmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiA9PT0gJ2pzb24nIHx8IGV4dGVuc2lvbiA9PT0gJ2dlb2pzb24nKSB7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQodGhpcy5jdXJyZW50RmlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtYXJrZXIoJ09ubHkgYGpzb25gIG9yIGBnZW9qc29uYCBmaWxlIGlzIGFsbG93ZWQnKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcHJvY2Vzc0pzb24oKSB7XG4gICAgY29uc3QgcmVhZEpzb25GaWxlID0gdGhpcy5yZWFkSnNvbkZpbGUoKTtcbiAgICBjb25zdCBwYXJzZUpzb24gPSByZWFkSnNvbkZpbGUudGhlbigoZmlsZUNvbnRlbnQ6IHN0cmluZykgPT4gbmV3IFByb21pc2U8eyBnZW9qc29uOiBhbnk7IGNlbnRyb2lkZXM6IGFueTsgfT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZmVhdHVyZSA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpO1xuICAgICAgaWYgKHZhbGlkKGZlYXR1cmUpICYmICh0aGlzLl9jdXJyZW50QWxsb3dlZEdlb20uaW5jbHVkZXMoZmVhdHVyZS5nZW9tZXRyeSkgfHwgZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSkge1xuICAgICAgICBjb25zdCBjZW50cm9pZGVzID0gbmV3IEFycmF5PGFueT4oKTtcbiAgICAgICAgY29uc3QgaW1wb3J0ZWRHZW9qc29uID0ge1xuICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgJiYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50JykpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2ltcGxlR2VvbWV0cnkoZmVhdHVyZSwgY2VudHJvaWRlcywgaW1wb3J0ZWRHZW9qc29uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgJiYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicgfHwgZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU11bHRpR2VvbWV0cnkoZmVhdHVyZSwgY2VudHJvaWRlcywgaW1wb3J0ZWRHZW9qc29uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUudHlwZSAmJiBmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZSwgY2VudHJvaWRlcywgaW1wb3J0ZWRHZW9qc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSh7IGdlb2pzb246IGltcG9ydGVkR2VvanNvbiwgY2VudHJvaWRlczogY2VudHJvaWRlcyB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcih0aGlzLkdFT01FVFJZX0lOVkFMSUQpKTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGw8eyBnZW9qc29uOiBhbnk7IGNlbnRyb2lkZXM6IGFueTsgfT4oW3BhcnNlSnNvbl0pXG4gICAgICAudGhlbigoW2ltcG9ydGVkUmVzdWx0XSkgPT4ge1xuICAgICAgICB0aGlzLnNldEltcG9ydGVkRGF0YShpbXBvcnRlZFJlc3VsdCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiAqKioqKioqKioqKioqL1xuICAvKiogKiogU0hBUEUgKioqKi9cbiAgLyoqICoqKioqKioqKioqKiovXG4gIHB1YmxpYyByZWFkWmlwRmlsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXI7XG4gICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHRUb0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoPEFycmF5QnVmZmVyPnJlYWRlci5yZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0VG9BcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZWFkZXIuYWJvcnQoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKG1hcmtlcignRmlsZSBpcyBlbXB0eScpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICByZWFkZXIuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcih0aGlzLlBBUlNJTkdfSVNTVUUpKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1heEZpbGVTaXplICYmIHRoaXMuY3VycmVudEZpbGUuc2l6ZSA+IHRoaXMubWF4RmlsZVNpemUpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcih0aGlzLkZJTEVfVE9PX0xBUkdFKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudEZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpLnRvTG93ZXJDYXNlKCkgIT09ICd6aXAnKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtYXJrZXIoJ09ubHkgYHppcGAgZmlsZSBpcyBhbGxvd2VkJykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIodGhpcy5jdXJyZW50RmlsZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXJlRmlsZXNJbnZhbGlkKHppcFJlc3VsdCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRlc3RBcnJheSA9IE9iamVjdC5rZXlzKHppcFJlc3VsdC5maWxlcykubWFwKGZpbGVOYW1lID0+IGZpbGVOYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKSk7XG4gICAgcmV0dXJuICh0ZXN0QXJyYXkuZmlsdGVyKGVsZW0gPT4gZWxlbSA9PT0gdGhpcy5TSFAgfHwgZWxlbSA9PT0gJ3NoeCcgfHwgZWxlbSA9PT0gJ2RiZicpLmxlbmd0aCA8IDMpICYmXG4gICAgKHRlc3RBcnJheS5maWx0ZXIoZWxlbSA9PiBlbGVtID09PSAnanNvbicpLmxlbmd0aCAhPT0gMSk7XG4gIH1cblxuICBwdWJsaWMgcHJvY2Vzc0FsbFNoYXBlKCkge1xuICAgIGNvbnN0IGZpbGVSZWFkZXJQcm9taXNlID0gdGhpcy5yZWFkWmlwRmlsZSgpO1xuXG4gICAgY29uc3QgemlwTG9hZGVyUHJvbWlzZSA9IGZpbGVSZWFkZXJQcm9taXNlLnRoZW4oKGJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IG5ldyBQcm9taXNlPGFueT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5qc3ppcC5sb2FkQXN5bmMoYnVmZmVyKS50aGVuKHppcFJlc3VsdCA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFyZUZpbGVzSW52YWxpZCh6aXBSZXN1bHQpKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtYXJrZXIoJ1ppcCBmaWxlIG11c3QgY29udGFpbiBhdCBsZWFzdCBhIGAqLnNocGAsIGAqLnNoeGAgYW5kIGAqLmRiZmAgb3IgYSBgKi5qc29uYCcpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSk7XG5cbiAgICBjb25zdCBzaGFwZVBhcnNlclByb21pc2UgPSB6aXBMb2FkZXJQcm9taXNlXG4gICAgICAudGhlbihidWZmZXIgPT4gc2hwKGJ1ZmZlcikpO1xuXG4gICAgY29uc3QgZ2VvanNvblBhcnNlclByb21pc2UgPSBzaGFwZVBhcnNlclByb21pc2UudGhlbihnZW9qc29uID0+IG5ldyBQcm9taXNlPHsgZ2VvanNvbjogYW55OyBjZW50cm9pZGVzOiBhbnk7IH0+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29tcHV0ZUdlb2pzb24oZ2VvanNvbiwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2ZpbGVSZWFkZXJQcm9taXNlLCB6aXBMb2FkZXJQcm9taXNlLCBzaGFwZVBhcnNlclByb21pc2UsIGdlb2pzb25QYXJzZXJQcm9taXNlXSlcbiAgICAgIC50aGVuKChbYSwgYiwgYywgaW1wb3J0ZWRSZXN1bHRdKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0SW1wb3J0ZWREYXRhKGltcG9ydGVkUmVzdWx0KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqICoqKioqKioqKioqKiovXG4gIC8qKiAqKiAgV0tUICAqKioqL1xuICAvKiogKioqKioqKioqKioqKi9cbiAgcHVibGljIHByb2Nlc3NXS1Qod2t0OiBzdHJpbmcpIHtcbiAgICBjb25zdCB3a3RQYXJzZXJQcm9taXNlID0gbmV3IFByb21pc2U8eyBnZW9qc29uOiBhbnk7IGNlbnRyb2lkZXM6IGFueTsgfT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZ2VvanNvbldLVCA9IHBhcnNlKHdrdCk7XG5cbiAgICAgIGNvbnN0IGNlbnRyb2lkZXMgPSBuZXcgQXJyYXk8YW55PigpO1xuICAgICAgY29uc3QgaW1wb3J0ZWRHZW9qc29uID0ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBmZWF0dXJlczogW11cbiAgICAgIH07XG4gICAgICBpZiAoZ2VvanNvbldLVCAmJiB2YWxpZChnZW9qc29uV0tUKSAmJiB0aGlzLl9jdXJyZW50QWxsb3dlZEdlb20uaW5jbHVkZXMoZ2VvanNvbldLVC50eXBlKSkge1xuICAgICAgICBjb25zdCBmZWF0dXJlID0ge1xuICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICBnZW9tZXRyeTogZ2VvanNvbldLVCxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7IGFybGFzX2lkOiBudWxsIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVHZW9tKGZlYXR1cmUsIGNlbnRyb2lkZXMsIGltcG9ydGVkR2VvanNvbiwgcmVqZWN0KTtcbiAgICAgICAgcmVzb2x2ZSh7IGdlb2pzb246IGltcG9ydGVkR2VvanNvbiwgY2VudHJvaWRlczogY2VudHJvaWRlcyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IodGhpcy5HRU9NRVRSWV9JTlZBTElEKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3drdFBhcnNlclByb21pc2VdKS50aGVuKChbaW1wb3J0ZWRSZXN1bHRdKSA9PiB7XG4gICAgICB0aGlzLnNldEltcG9ydGVkRGF0YShpbXBvcnRlZFJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogKioqKioqKioqKioqKi9cbiAgLyoqICoqIFRPT0xTICoqKiovXG4gIC8qKiAqKioqKioqKioqKioqL1xuICBwdWJsaWMgY2xlYXJQb2x5Z29ucygpIHtcbiAgICAvLyBDbGVhbiBzb3VyY2Ugb2YgaW1wb3J0ZWQgcG9seWdvbnNcbiAgICBjb25zdCBsYWJlbFNvdXJjZSA9IHRoaXMubWFwU2VydmljZS5nZXRTb3VyY2UodGhpcy5TT1VSQ0VfTkFNRV9QT0xZR09OX0xBQkVMLCB0aGlzLm1hcENvbXBvbmVudC5tYXApO1xuICAgIHRoaXMuZmVhdHVyZUluZGV4ID0gMDtcbiAgICB0aGlzLm1hcENvbXBvbmVudC5vbkFvaUNoYW5nZWQubmV4dCh0aGlzLmVtcHR5RGF0YSk7XG4gICAgaWYgKGxhYmVsU291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWFwU2VydmljZS5zZXREYXRhVG9HZW9qc29uU291cmNlKGxhYmVsU291cmNlLCB0aGlzLmVtcHR5RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFkZEZlYXR1cmUoZmVhdHVyZTogYW55LCBjZW50cm9pZGVzOiBBcnJheTxhbnk+LFxuICAgIGltcG9ydGVkR2VvanNvbjogeyB0eXBlOiBzdHJpbmc7IGZlYXR1cmVzOiBBcnJheTxhbnk+OyB9LCBpbmRleDogbnVtYmVyKSB7XG4gICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmFybGFzX2lkID0gaW5kZXg7XG4gICAgY29uc3QgY2VudCA9IHRoaXMuY2FsY0NlbnRyb2lkKGZlYXR1cmUpO1xuICAgIGNlbnRyb2lkZXMucHVzaChjZW50KTtcbiAgICBpbXBvcnRlZEdlb2pzb24uZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJbXBvcnRlZERhdGEoaW1wb3J0ZWRSZXN1bHQpIHtcbiAgICBpZiAodGhpcy50b29NYW55VmVydGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5UT09fTUFOWV9WRVJUSUNFUyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heEZlYXR1cmVzICYmIGltcG9ydGVkUmVzdWx0Lmdlb2pzb24uZmVhdHVyZXMubGVuZ3RoID4gdGhpcy5tYXhGZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuVE9PX01BTllfRkVBVFVSRVMpO1xuICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWRSZXN1bHQuZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmZpdFJlc3VsdCkge1xuICAgICAgICB0aGlzLm1hcENvbXBvbmVudC5maXRUb1BhZGRlZEJvdW5kcyhleHRlbnQoaW1wb3J0ZWRSZXN1bHQuZ2VvanNvbikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWFwQ29tcG9uZW50LmRyYXdEYXRhLmZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5tYXBDb21wb25lbnQuZHJhd0RhdGEuZmVhdHVyZXMuZm9yRWFjaChkZiA9PiBpbXBvcnRlZFJlc3VsdC5nZW9qc29uLmZlYXR1cmVzLnB1c2goZGYpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwQ29tcG9uZW50LmRyYXdDb21wb25lbnQuZHJhdy5jaGFuZ2VNb2RlKCdzdGF0aWMnKTtcbiAgICAgIHRoaXMuaW1wb3J0ZWQubmV4dChpbXBvcnRlZFJlc3VsdC5nZW9qc29uLmZlYXR1cmVzKTtcbiAgICAgIHRoaXMubWFwQ29tcG9uZW50Lm9uQW9pQ2hhbmdlZC5uZXh0KGltcG9ydGVkUmVzdWx0Lmdlb2pzb24pO1xuICAgICAgdGhpcy5kaWFsb2dSZWYuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1hcmtlcignTm8gcG9seWdvbiB0byBkaXNwbGF5IGluIHRoaXMgZmlsZScpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2FsY0NlbnRyb2lkKGZlYXR1cmUpIHtcbiAgICBsZXQgY2VudDtcbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICBjZW50ID0gY2VudHJvaWQoZmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5tYXhWZXJ0ZXhCeVBvbHlnb24pIHtcbiAgICAgICAgdGhpcy5tYXhWZXJ0ZXhCeVBvbHlnb24gPSAxMDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tYXhWZXJ0ZXhCeVBvbHlnb24gJiYgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5sZW5ndGggLSAxID4gdGhpcy5tYXhWZXJ0ZXhCeVBvbHlnb24pIHtcbiAgICAgICAgdGhpcy50b29NYW55VmVydGV4ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvbHkgPSBwb2x5Z29uKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgY2VudCA9IGNlbnRyb2lkKHBvbHkpO1xuICAgIH1cblxuICAgIGNlbnQucHJvcGVydGllcy5hcmxhc19pZCA9IGZlYXR1cmUucHJvcGVydGllcy5hcmxhc19pZDtcbiAgICByZXR1cm4gY2VudDtcbiAgfVxuXG4gIHByaXZhdGUgdGhyb3dFcnJvcihlcnJvcjogRXJyb3IpIHtcbiAgICB0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5kaXNwbGF5RXJyb3IgPSB0cnVlO1xuICAgIHRoaXMuZGlhbG9nUmVmLmNvbXBvbmVudEluc3RhbmNlLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGlhbG9nUmVmLmNvbXBvbmVudEluc3RhbmNlLmVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgc3dpdGNoICh0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5lcnJvck1lc3NhZ2UpIHtcbiAgICAgIGNhc2UgdGhpcy5UT09fTUFOWV9GRUFUVVJFUzpcbiAgICAgICAgdGhpcy5kaWFsb2dSZWYuY29tcG9uZW50SW5zdGFuY2UuZXJyb3JUaHJlc2hvbGQgPSB0aGlzLm1heEZlYXR1cmVzLnRvU3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0aGlzLlRPT19NQU5ZX1ZFUlRJQ0VTOlxuICAgICAgICB0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5lcnJvclRocmVzaG9sZCA9IHRoaXMubWF4VmVydGV4QnlQb2x5Z29uLnRvU3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0aGlzLkZJTEVfVE9PX0xBUkdFOlxuICAgICAgICB0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5lcnJvclRocmVzaG9sZCA9IHRoaXMuZm9ybWF0Qnl0ZXModGhpcy5tYXhGaWxlU2l6ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0aGlzLlRJTUVPVVQ6XG4gICAgICAgIHRoaXMuZGlhbG9nUmVmLmNvbXBvbmVudEluc3RhbmNlLmVycm9yVGhyZXNob2xkID0gdGhpcy5tYXhMb2FkaW5nVGltZSArICcgbXMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGlhbG9nUmVmLmNvbXBvbmVudEluc3RhbmNlLmVycm9yVGhyZXNob2xkID0gJyc7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5maWxlSW5wdXQpIHtcbiAgICAgIHRoaXMuZGlhbG9nUmVmLmNvbXBvbmVudEluc3RhbmNlLmZpbGVJbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgfVxuICAgIHRoaXMuZGlhbG9nUmVmLmNvbXBvbmVudEluc3RhbmNlLmN1cnJlbnRGaWxlID0gbnVsbDtcbiAgICB0aGlzLmVycm9yLm5leHQoZXJyb3IubWVzc2FnZSk7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdEJ5dGVzKGJ5dGVzLCBkZWNpbWFscyA9IDIpIHtcbiAgICBpZiAoYnl0ZXMgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCBCeXRlcyc7XG4gICAgfVxuXG4gICAgY29uc3QgayA9IDEwMjQ7XG4gICAgY29uc3QgZG0gPSBkZWNpbWFscyA8IDAgPyAwIDogZGVjaW1hbHM7XG4gICAgY29uc3Qgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ107XG4gICAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2coaykpO1xuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoZG0pKSArICcgJyArIHNpemVzW2ldO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlR2VvanNvbihnZW9qc29uOiBhbnksIHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZCxcbiAgICByZXNvbHZlOiAodmFsdWU6IHsgZ2VvanNvbjogYW55OyBjZW50cm9pZGVzOiBhbnk7IH0gfCBQcm9taXNlTGlrZTx7IGdlb2pzb246IGFueTsgY2VudHJvaWRlczogYW55OyB9PikgPT4gdm9pZCkge1xuICAgIGlmICh2YWxpZChnZW9qc29uKSkge1xuICAgICAgY29uc3QgY2VudHJvaWRlcyA9IG5ldyBBcnJheTxhbnk+KCk7XG4gICAgICBjb25zdCBpbXBvcnRlZEdlb2pzb24gPSB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgfTtcbiAgICAgIGdlb2pzb24uZmVhdHVyZXMuZmlsdGVyKGZlYXR1cmUgPT4gdGhpcy5fY3VycmVudEFsbG93ZWRHZW9tLmluY2x1ZGVzKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSkpXG4gICAgICAgIC5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVHZW9tKGZlYXR1cmUsIGNlbnRyb2lkZXMsIGltcG9ydGVkR2VvanNvbiwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICByZXNvbHZlKHsgZ2VvanNvbjogaW1wb3J0ZWRHZW9qc29uLCBjZW50cm9pZGVzOiBjZW50cm9pZGVzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdHZW9tZXRyeSBpcyBub3QgdmFsaWQnKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVHZW9tKGZlYXR1cmU6IGFueSwgY2VudHJvaWRlczogYW55W10sIGltcG9ydGVkR2VvanNvbjogeyB0eXBlOiBzdHJpbmc7IGZlYXR1cmVzOiBhbnlbXTsgfSwgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nIHx8IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpR2VvbWV0cnknKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBQb2x5Z29uIGZlYXR1cmUgZm9yIGVhY2ggcG9seWdvbiBpbiB0aGUgTXVsdGlQb2x5Z29uXG4gICAgICAgIC8vIEFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBNdWx0aVBvbHlnb24gYXJlIGNvcGllZCBpbiBlYWNoIGZlYXR1cmUgY3JlYXRlZFxuICAgICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q29sbGVjdGlvbihmZWF0dXJlLCBjZW50cm9pZGVzLCBpbXBvcnRlZEdlb2pzb24pO1xuICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nIHx8IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTXVsdGlHZW9tZXRyeShmZWF0dXJlLCBjZW50cm9pZGVzLCBpbXBvcnRlZEdlb2pzb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaW1wbGVHZW9tZXRyeShmZWF0dXJlLCBjZW50cm9pZGVzLCBpbXBvcnRlZEdlb2pzb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIGR1cmluZyBpbXBvcnQnKSk7XG4gICAgfVxuICB9XG59XG4iLCI8aDEgbWF0LWRpYWxvZy10aXRsZSBjbGFzcz1cIm1hcGdsLWltcG9ydC10aXRsZVwiPnt7ICdJbXBvcnQgZmlsZScgfCB0cmFuc2xhdGV9fTwvaDE+XG48ZGl2IG1hdC1kaWFsb2ctY29udGVudCBjbGFzcz1cIm1hcGdsLWltcG9ydC1ib2R5XCI+XG4gIDxtYXQtcmFkaW8tZ3JvdXAgY2xhc3M9XCJtYXBnbC1pbXBvcnQtcmFkaW8tZ3JvdXBcIiBbKG5nTW9kZWwpXT1cImltcG9ydFR5cGVcIiAoY2hhbmdlKT1cImNoYW5nZVR5cGUoKVwiPlxuICAgIDxtYXQtcmFkaW8tYnV0dG9uICpuZ0Zvcj1cImxldCB0eXBlIG9mIGFsbG93ZWRJbXBvcnRUeXBlXCIgW3ZhbHVlXT1cInR5cGVcIiBjbGFzcz1cIm1hcGdsLWltcG9ydC1yYWRpby1idXR0b25cIj5cbiAgICAgIHt7IHR5cGUgfCB0cmFuc2xhdGUgfX1cbiAgICA8L21hdC1yYWRpby1idXR0b24+XG4gIDwvbWF0LXJhZGlvLWdyb3VwPlxuXG4gIDxpbnB1dCAqbmdJZj1cImltcG9ydFR5cGUgIT09IFdLVFwiIHR5cGU9XCJmaWxlXCIgY2xhc3M9XCJtYXBnbC1pbXBvcnQtdXBsb2FkXCIgI2ZpbGVJbnB1dCBhY2NlcHQ9XCJ7e2FsbG93ZWRGaWxlRXh0ZW5zaW9ufX1cIiAoY2hhbmdlKT1cIm9uRmlsZUNoYW5nZSgkZXZlbnQudGFyZ2V0LmZpbGVzKVwiPlxuICA8dGV4dGFyZWEgKm5nSWY9XCJpbXBvcnRUeXBlID09PSBXS1RcIiBjbGFzcz1cIm1hcGdsLWltcG9ydC10ZXh0LWFyZWFcIiBbKG5nTW9kZWwpXT1cIndrdENvbnRlbnRcIiBwbGFjZWhvbGRlcj1cInt7J1Bhc3RlIHlvdXIgV0tUJyB8IHRyYW5zbGF0ZX19XCIgKGNoYW5nZSk9XCJvblRleHRDaGFuZ2UoKVwiPjwvdGV4dGFyZWE+XG5cbiAgPGRpdiBjbGFzcz1cIm1hcGdsLWltcG9ydC16b29tXCI+XG4gICAgPG1hdC1jaGVja2JveCBbKG5nTW9kZWwpXT1cImZpdFJlc3VsdFwiPnt7ICdab29tIHRvIHJlc3VsdCcgfCB0cmFuc2xhdGV9fTwvbWF0LWNoZWNrYm94PlxuICA8L2Rpdj5cbiAgPGRpdiAqbmdJZj1cImRpc3BsYXlFcnJvclwiIGNsYXNzPVwibWFwZ2wtaW1wb3J0LWVycm9yXCI+XG4gICAge3sgZXJyb3JNZXNzYWdlIHwgdHJhbnNsYXRlfX0gPG5nLWNvbnRhaW5lciAqbmdJZj1cImVycm9yVGhyZXNob2xkICE9PSAnJ1wiPiAtICh7eydNYXg6JyB8IHRyYW5zbGF0ZSB9fSB7e2Vycm9yVGhyZXNob2xkfX0pPC9uZy1jb250YWluZXI+XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgbWF0LWRpYWxvZy1hY3Rpb25zIGNsYXNzPVwibWFwZ2wtaW1wb3J0LWFjdGlvbnNcIj5cbiAgPGJ1dHRvbiBtYXQtYnV0dG9uIChjbGljayk9XCJvbkNhbmNlbCgpXCI+e3sgJ0NhbmNlbCcgfCB0cmFuc2xhdGV9fTwvYnV0dG9uPlxuICA8YnV0dG9uIG1hdC1idXR0b24gW2Rpc2FibGVkXT1cIigoaW1wb3J0VHlwZSA9PT0gU0hQIHx8IGltcG9ydFR5cGUgPT09IEtNTCB8fCBpbXBvcnRUeXBlID09PSBHRU9KU09OKSAmJiAhY3VycmVudEZpbGUpIHx8IGlzUnVubmluZyB8fCAoaW1wb3J0VHlwZSA9PT0gV0tUICYmIHdrdENvbnRlbnQgPT09ICcnKVwiIChjbGljayk9XCJpbXBvcnQoKVwiPnt7ICdJbXBvcnQnIHwgdHJhbnNsYXRlfX08L2J1dHRvbj5cbiAgPG1hdC1wcm9ncmVzcy1zcGlubmVyICpuZ0lmPVwiaXNSdW5uaW5nXCIgW2NvbG9yXT1cIidhY2NlbnQnXCIgW2RpYW1ldGVyXT1cIjQwXCIgW21vZGVdPVwiJ2luZGV0ZXJtaW5hdGUnXCI+XG4gIDwvbWF0LXByb2dyZXNzLXNwaW5uZXI+XG48L2Rpdj5cbiIsIlxuXG4iXX0=