/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { Component, Output } from '@angular/core';
import { UntypedFormControl, UntypedFormGroup, Validators } from '@angular/forms';
import { MatDialog, MatDialogRef } from '@angular/material/dialog';
import { marker } from '@colsen1991/ngx-translate-extract-marker';
import { Subject, takeUntil } from 'rxjs';
import { ArlasColorService } from 'arlas-web-components';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/dialog";
import * as i2 from "arlas-web-components";
import * as i3 from "@angular/common";
import * as i4 from "@angular/forms";
import * as i5 from "@angular/material/form-field";
import * as i6 from "@angular/material/select";
import * as i7 from "@angular/material/core";
import * as i8 from "@angular/material/button";
import * as i9 from "@ngx-translate/core";
export var GeoQueryOperator;
(function (GeoQueryOperator) {
    GeoQueryOperator["WITHIN"] = "within";
    GeoQueryOperator["NOT_WITHIN"] = "notwithin";
    GeoQueryOperator["INTERSECTS"] = "intersects";
    GeoQueryOperator["NOT_INTERSECTS"] = "notintersects";
})(GeoQueryOperator || (GeoQueryOperator = {}));
export class SelectFormControl extends UntypedFormControl {
    constructor(formState, label, options) {
        super(formState, Validators.required);
        this.syncOptions = [];
        this.setValue(formState);
        this.setSyncOptions(options);
    }
    setSyncOptions(newOptions) {
        this.syncOptions = newOptions;
        this.filteredOptions = newOptions;
    }
}
export class MapSettingsDialogComponent {
    constructor(dialogRef, colorGeneratorLoader) {
        this.dialogRef = dialogRef;
        this.colorGeneratorLoader = colorGeneratorLoader;
        /**
         * @Output : Angular
         * Emits the geo-query to apply. A geo-query is defined by
         * - the operation ("within", "intersects", "notwithin", "notintersects")
         * - the geometry field to query
         */
        this.geoQueryEmitter = new Subject();
        this.emittedGeoQueries = new Map();
        /** Constants */
        this.GEO_QUERIES_DESCRIPTION = marker('Draw a bbox or a polygon that');
        this.geoQueriesFormGroups = new Array();
        this.collectionsColors = new Array();
        this.selectionsSnapshot = new Map();
        this._onDestroy$ = new Subject();
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    /** Emits the geo-query to apply */
    emitGeoFilter() {
        this.geoQueryEmitter.next(this.emittedGeoQueries);
    }
    /** Closes the dialog */
    onClose() {
        this.dialogRef.close();
    }
    createGeoQueryForm(collectionName, displayCollectionName, filterGeometries, operationsSelectModel) {
        /** geometry */
        const geometryPaths = filterGeometries.map(fg => fg.path);
        const selectedGeometry = filterGeometries.find(fg => fg.selected);
        const selectedGeometryPath = !!selectedGeometry ? selectedGeometry.path : '';
        /** operation */
        const operations = operationsSelectModel.map(osm => osm.operation);
        const selectedOperationSelectModel = operationsSelectModel.find(osm => osm.selected);
        const selectedOperation = !!selectedOperationSelectModel ? selectedOperationSelectModel.operation : GeoQueryOperator.INTERSECTS;
        const geoQueryControls = {
            a_operation: new SelectFormControl(selectedOperation, '', operations),
            b_geometryPath: new SelectFormControl(selectedGeometryPath, '', geometryPaths),
            c_collection: new UntypedFormControl(collectionName),
            d_displayCollectionName: new UntypedFormControl(displayCollectionName),
        };
        const geoQueryForm = new UntypedFormGroup(geoQueryControls);
        /** snapshot defaultselections */
        this.emittedGeoQueries.clear();
        this.selectionsSnapshot.clear();
        this.selectionsSnapshot.set(collectionName, selectedGeometry + selectedOperation);
        geoQueryForm.valueChanges
            .pipe(takeUntil(this._onDestroy$))
            .subscribe(vc => {
            const selectionSnapShot = vc.b_geometryPath + vc.a_operation;
            /** ignore selection changes if the user go back to initial state of a control */
            const ignoreChange = selectionSnapShot === this.selectionsSnapshot.get(vc.c_collection);
            if (ignoreChange) {
                this.emittedGeoQueries.delete(vc.c_collection);
            }
            else {
                this.emittedGeoQueries.set(vc.c_collection, {
                    geometry_path: vc.b_geometryPath,
                    operation: vc.a_operation
                });
            }
        });
        this.collectionsColors.push((this.colorGeneratorLoader.getColor(collectionName)));
        this.geoQueriesFormGroups.push(geoQueryForm);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsDialogComponent, deps: [{ token: i1.MatDialogRef }, { token: i2.ArlasColorService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapSettingsDialogComponent, selector: "arlas-map-settings-dialog", outputs: { geoQueryEmitter: "geoQueryEmitter" }, ngImport: i0, template: "<h1 mat-dialog-title class=\"mapgl-settings__title\">\n  {{ 'Geo-queries' | translate }}\n</h1>\n\n<div mat-dialog-content class=\"mapgl-settings\">\n  <div class=\"mapgl-settings__description\">\n    {{ GEO_QUERIES_DESCRIPTION | translate }}\n  </div>\n  <div class=\"mapgl-settings__form\" *ngFor=\"let formGroup of geoQueriesFormGroups; let i = index\"\n      [formGroup]=\"formGroup\" [style.borderLeftColor]=\"collectionsColors[i]\">\n    <div class=\"mapgl-settings__form__steps\">\n      <div *ngFor=\"let control of formGroup.controls | keyvalue\" class=\"mapgl-settings__form__steps__item\">\n        <div *ngIf=\"control.key === 'd_displayCollectionName'\">\n          {{ 'of_collection' | translate: { collection: (control.value.value | getCollectionDisplayName | translate) } }}\n        </div>\n        <mat-form-field *ngIf=\"control.key !== 'c_collection' && control.key !== 'color' && control.key !== 'd_displayCollectionName'\">\n          <mat-label>{{ control.key | translate }}</mat-label>\n          <mat-select [formControl]=\"control.value\">\n            <mat-option *ngFor=\"let option of control.value.syncOptions\" [value]=\"option\">\n              {{option | translate}}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-settings__actions\">\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter()\">{{ 'Apply geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter();onClose()\">{{ 'Set geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--cancel\"\n    (click)=\"onClose()\">{{ 'Cancel' | translate}}</button>\n</div>\n\n\n", styles: ["@charset \"UTF-8\";::ng-deep .map-settings-dialog .mdc-dialog__surface{padding:0 15px}.mapgl-settings__title{margin:0 0 20px!important}.mapgl-settings{position:relative;overflow:hidden}.mapgl-settings__description{padding-right:20px;padding-bottom:.65em}.mapgl-settings__form{display:flex;margin-bottom:15px;flex-direction:column;padding:5px 15px 0;justify-content:flex-start;box-shadow:0 2px 1px -1px #0003,0 1px 1px #00000024,0 1px 3px #0000001f;border-left:3px solid}.mapgl-settings__form__steps{display:flex;justify-content:left;align-items:center}.mapgl-settings__form__steps__item{padding-right:20px;display:flex;justify-content:left;align-items:center;--mdc-filled-text-field-container-color: transparent;--mat-form-field-focus-state-layer-opacity: 0}.mapgl-settings__actions{--mat-dialog-actions-alignment: end}.mapgl-settings__actions--apply{--mdc-text-button-label-text-color: #ff4081;font-weight:bolder;outline:none}.mapgl-settings__actions--cancel{color:#000;margin:2px;outline:none}\n"], dependencies: [{ kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i1.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i1.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "component", type: i5.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i5.MatLabel, selector: "mat-label" }, { kind: "component", type: i6.MatSelect, selector: "mat-select", inputs: ["aria-describedby", "panelClass", "disabled", "disableRipple", "tabIndex", "hideSingleSelectionIndicator", "placeholder", "required", "multiple", "disableOptionCentering", "compareWith", "value", "aria-label", "aria-labelledby", "errorStateMatcher", "typeaheadDebounceInterval", "sortComparator", "id", "panelWidth"], outputs: ["openedChange", "opened", "closed", "selectionChange", "valueChange"], exportAs: ["matSelect"] }, { kind: "component", type: i7.MatOption, selector: "mat-option", inputs: ["value", "id", "disabled"], outputs: ["onSelectionChange"], exportAs: ["matOption"] }, { kind: "component", type: i8.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "pipe", type: i3.KeyValuePipe, name: "keyvalue" }, { kind: "pipe", type: i9.TranslatePipe, name: "translate" }, { kind: "pipe", type: i2.GetCollectionDisplayNamePipe, name: "getCollectionDisplayName" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-settings-dialog', template: "<h1 mat-dialog-title class=\"mapgl-settings__title\">\n  {{ 'Geo-queries' | translate }}\n</h1>\n\n<div mat-dialog-content class=\"mapgl-settings\">\n  <div class=\"mapgl-settings__description\">\n    {{ GEO_QUERIES_DESCRIPTION | translate }}\n  </div>\n  <div class=\"mapgl-settings__form\" *ngFor=\"let formGroup of geoQueriesFormGroups; let i = index\"\n      [formGroup]=\"formGroup\" [style.borderLeftColor]=\"collectionsColors[i]\">\n    <div class=\"mapgl-settings__form__steps\">\n      <div *ngFor=\"let control of formGroup.controls | keyvalue\" class=\"mapgl-settings__form__steps__item\">\n        <div *ngIf=\"control.key === 'd_displayCollectionName'\">\n          {{ 'of_collection' | translate: { collection: (control.value.value | getCollectionDisplayName | translate) } }}\n        </div>\n        <mat-form-field *ngIf=\"control.key !== 'c_collection' && control.key !== 'color' && control.key !== 'd_displayCollectionName'\">\n          <mat-label>{{ control.key | translate }}</mat-label>\n          <mat-select [formControl]=\"control.value\">\n            <mat-option *ngFor=\"let option of control.value.syncOptions\" [value]=\"option\">\n              {{option | translate}}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div mat-dialog-actions class=\"mapgl-settings__actions\">\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter()\">{{ 'Apply geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--apply\"\n    (click)=\"emitGeoFilter();onClose()\">{{ 'Set geo-queries' | translate }}</button>\n  <button mat-button class=\"mapgl-settings__actions--cancel\"\n    (click)=\"onClose()\">{{ 'Cancel' | translate}}</button>\n</div>\n\n\n", styles: ["@charset \"UTF-8\";::ng-deep .map-settings-dialog .mdc-dialog__surface{padding:0 15px}.mapgl-settings__title{margin:0 0 20px!important}.mapgl-settings{position:relative;overflow:hidden}.mapgl-settings__description{padding-right:20px;padding-bottom:.65em}.mapgl-settings__form{display:flex;margin-bottom:15px;flex-direction:column;padding:5px 15px 0;justify-content:flex-start;box-shadow:0 2px 1px -1px #0003,0 1px 1px #00000024,0 1px 3px #0000001f;border-left:3px solid}.mapgl-settings__form__steps{display:flex;justify-content:left;align-items:center}.mapgl-settings__form__steps__item{padding-right:20px;display:flex;justify-content:left;align-items:center;--mdc-filled-text-field-container-color: transparent;--mat-form-field-focus-state-layer-opacity: 0}.mapgl-settings__actions{--mat-dialog-actions-alignment: end}.mapgl-settings__actions--apply{--mdc-text-button-label-text-color: #ff4081;font-weight:bolder;outline:none}.mapgl-settings__actions--cancel{color:#000;margin:2px;outline:none}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialogRef }, { type: i2.ArlasColorService }], propDecorators: { geoQueryEmitter: [{
                type: Output
            }] } });
export class MapSettingsComponent {
    constructor(dialog) {
        this.dialog = dialog;
        /**
         * @Output : Angular
         * Emits the geo-query to apply. A geo-query is defined by
         * - the operation ("within", "intersects", "notwithin", "notintersects")
         * - the geometry field to query
         */
        this.geoQueryEmitter = new Subject();
    }
    openDialog(mapSettingsService) {
        this.dialogRef = this.dialog.open(MapSettingsDialogComponent, { data: null, panelClass: 'map-settings-dialog' });
        const mapGeoQueries = mapSettingsService.getGeoQueries();
        if (!!mapGeoQueries) {
            mapGeoQueries.forEach((geoQueries, collection) => {
                this.dialogRef.componentInstance.createGeoQueryForm(collection, geoQueries[2], geoQueries[0], geoQueries[1]);
            });
        }
        this.dialogRef.componentInstance.geoQueryEmitter = this.geoQueryEmitter;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsComponent, deps: [{ token: i1.MatDialog }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MapSettingsComponent, selector: "arlas-map-settings", outputs: { geoQueryEmitter: "geoQueryEmitter" }, ngImport: i0, template: "\n", styles: ["@charset \"UTF-8\";\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MapSettingsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-map-settings', template: "\n", styles: ["@charset \"UTF-8\";\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialog }], propDecorators: { geoQueryEmitter: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLXNldHRpbmdzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FybGFzLW1hcC9zcmMvbGliL21hcC1zZXR0aW5ncy9tYXAtc2V0dGluZ3MuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYXJsYXMtbWFwL3NyYy9saWIvbWFwLXNldHRpbmdzL21hcC1zZXR0aW5ncy1kaWFsb2cuY29tcG9uZW50Lmh0bWwiLCIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hcmxhcy1tYXAvc3JjL2xpYi9tYXAtc2V0dGluZ3MvbWFwLXNldHRpbmdzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRixPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ25FLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUNsRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMxQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7Ozs7Ozs7Ozs7QUFlekQsTUFBTSxDQUFOLElBQVksZ0JBS1g7QUFMRCxXQUFZLGdCQUFnQjtJQUMxQixxQ0FBaUIsQ0FBQTtJQUNqQiw0Q0FBd0IsQ0FBQTtJQUN4Qiw2Q0FBeUIsQ0FBQTtJQUN6QixvREFBZ0MsQ0FBQTtBQUNsQyxDQUFDLEVBTFcsZ0JBQWdCLEtBQWhCLGdCQUFnQixRQUszQjtBQUVELE1BQU0sT0FBTyxpQkFBa0IsU0FBUSxrQkFBa0I7SUFN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QUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzFFLENBQUM7K0dBdkJVLG9CQUFvQjttR0FBcEIsb0JBQW9CLDJHRWpLakMsSUFDQTs7NEZGZ0thLG9CQUFvQjtrQkFMaEMsU0FBUzsrQkFDRSxvQkFBb0I7OEVBWWIsZUFBZTtzQkFBL0IsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBMaWNlbnNlZCB0byBHaXNhw69hIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFLnR4dCBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEdpc2HDr2EgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVW50eXBlZEZvcm1Db250cm9sLCBVbnR5cGVkRm9ybUdyb3VwLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTWF0RGlhbG9nLCBNYXREaWFsb2dSZWYgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9kaWFsb2cnO1xuaW1wb3J0IHsgbWFya2VyIH0gZnJvbSAnQGNvbHNlbjE5OTEvbmd4LXRyYW5zbGF0ZS1leHRyYWN0LW1hcmtlcic7XG5pbXBvcnQgeyBTdWJqZWN0LCB0YWtlVW50aWwgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFybGFzQ29sb3JTZXJ2aWNlIH0gZnJvbSAnYXJsYXMtd2ViLWNvbXBvbmVudHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdlb21ldHJ5U2VsZWN0TW9kZWwge1xuICBwYXRoOiBzdHJpbmc7XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0aW9uU2VsZWN0TW9kZWwge1xuICBvcGVyYXRpb246IEdlb1F1ZXJ5T3BlcmF0b3I7XG4gIHNlbGVjdGVkPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgR2VvUXVlcnkge1xuICBvcGVyYXRpb246IHN0cmluZztcbiAgZ2VvbWV0cnlfcGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgZW51bSBHZW9RdWVyeU9wZXJhdG9yIHtcbiAgV0lUSElOID0gJ3dpdGhpbicsXG4gIE5PVF9XSVRISU4gPSAnbm90d2l0aGluJyxcbiAgSU5URVJTRUNUUyA9ICdpbnRlcnNlY3RzJyxcbiAgTk9UX0lOVEVSU0VDVFMgPSAnbm90aW50ZXJzZWN0cydcbn1cblxuZXhwb3J0IGNsYXNzIFNlbGVjdEZvcm1Db250cm9sIGV4dGVuZHMgVW50eXBlZEZvcm1Db250cm9sIHtcblxuICAvLyB1c2VkIG9ubHkgZm9yIGF1dG9jb21wbGV0ZTogbGlzdCBvZiBmaWx0ZXJlZCBvcHRpb25zXG4gIHB1YmxpYyBmaWx0ZXJlZE9wdGlvbnM6IEFycmF5PHN0cmluZz47XG4gIHB1YmxpYyBzeW5jT3B0aW9uczogQXJyYXk8c3RyaW5nPiA9IFtdO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBmb3JtU3RhdGU6IGFueSxcbiAgICBsYWJlbDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IEFycmF5PHN0cmluZz4pIHtcblxuICAgIHN1cGVyKGZvcm1TdGF0ZSwgVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgdGhpcy5zZXRWYWx1ZShmb3JtU3RhdGUpO1xuICAgIHRoaXMuc2V0U3luY09wdGlvbnMob3B0aW9ucyk7XG5cbiAgfVxuXG4gIHB1YmxpYyBzZXRTeW5jT3B0aW9ucyhuZXdPcHRpb25zOiBBcnJheTxzdHJpbmc+KSB7XG4gICAgdGhpcy5zeW5jT3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgdGhpcy5maWx0ZXJlZE9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFwU2V0dGluZ3NTZXJ2aWNlIHtcbiAgZ2V0R2VvUXVlcmllcygpOiBNYXA8c3RyaW5nLCBbQXJyYXk8R2VvbWV0cnlTZWxlY3RNb2RlbD4sIEFycmF5PE9wZXJhdGlvblNlbGVjdE1vZGVsPiwgc3RyaW5nXT47XG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2FybGFzLW1hcC1zZXR0aW5ncy1kaWFsb2cnLFxuICB0ZW1wbGF0ZVVybDogJy4vbWFwLXNldHRpbmdzLWRpYWxvZy5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL21hcC1zZXR0aW5ncy1kaWFsb2cuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBNYXBTZXR0aW5nc0RpYWxvZ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAT3V0cHV0IDogQW5ndWxhclxuICAgKiBFbWl0cyB0aGUgZ2VvLXF1ZXJ5IHRvIGFwcGx5LiBBIGdlby1xdWVyeSBpcyBkZWZpbmVkIGJ5XG4gICAqIC0gdGhlIG9wZXJhdGlvbiAoXCJ3aXRoaW5cIiwgXCJpbnRlcnNlY3RzXCIsIFwibm90d2l0aGluXCIsIFwibm90aW50ZXJzZWN0c1wiKVxuICAgKiAtIHRoZSBnZW9tZXRyeSBmaWVsZCB0byBxdWVyeVxuICAgKi9cbiAgQE91dHB1dCgpIHB1YmxpYyBnZW9RdWVyeUVtaXR0ZXI6IFN1YmplY3Q8TWFwPHN0cmluZywgR2VvUXVlcnk+PiA9IG5ldyBTdWJqZWN0PE1hcDxzdHJpbmcsIEdlb1F1ZXJ5Pj4oKTtcbiAgcHVibGljIGVtaXR0ZWRHZW9RdWVyaWVzOiBNYXA8c3RyaW5nLCBHZW9RdWVyeT4gPSBuZXcgTWFwKCk7XG4gIC8qKiBDb25zdGFudHMgKi9cbiAgcHVibGljIEdFT19RVUVSSUVTX0RFU0NSSVBUSU9OID0gbWFya2VyKCdEcmF3IGEgYmJveCBvciBhIHBvbHlnb24gdGhhdCcpO1xuXG4gIHB1YmxpYyBnZW9RdWVyaWVzRm9ybUdyb3VwcyA9IG5ldyBBcnJheTxVbnR5cGVkRm9ybUdyb3VwPigpO1xuICBwdWJsaWMgY29sbGVjdGlvbnNDb2xvcnMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICBwdWJsaWMgc2VsZWN0aW9uc1NuYXBzaG90ID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9vbkRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBkaWFsb2dSZWY6IE1hdERpYWxvZ1JlZjxNYXBTZXR0aW5nc0NvbXBvbmVudD4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb2xvckdlbmVyYXRvckxvYWRlcjogQXJsYXNDb2xvclNlcnZpY2UpIHsgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9vbkRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgdGhpcy5fb25EZXN0cm95JC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqIEVtaXRzIHRoZSBnZW8tcXVlcnkgdG8gYXBwbHkgKi9cbiAgcHVibGljIGVtaXRHZW9GaWx0ZXIoKSB7XG4gICAgdGhpcy5nZW9RdWVyeUVtaXR0ZXIubmV4dCh0aGlzLmVtaXR0ZWRHZW9RdWVyaWVzKTtcbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIGRpYWxvZyAqL1xuICBwdWJsaWMgb25DbG9zZSgpIHtcbiAgICB0aGlzLmRpYWxvZ1JlZi5jbG9zZSgpO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZUdlb1F1ZXJ5Rm9ybShjb2xsZWN0aW9uTmFtZTogc3RyaW5nLCBkaXNwbGF5Q29sbGVjdGlvbk5hbWU6IHN0cmluZyxcbiAgICAgIGZpbHRlckdlb21ldHJpZXM6IEFycmF5PEdlb21ldHJ5U2VsZWN0TW9kZWw+LCBvcGVyYXRpb25zU2VsZWN0TW9kZWw6IEFycmF5PE9wZXJhdGlvblNlbGVjdE1vZGVsPik6IHZvaWQge1xuICAgIC8qKiBnZW9tZXRyeSAqL1xuICAgIGNvbnN0IGdlb21ldHJ5UGF0aHMgPSBmaWx0ZXJHZW9tZXRyaWVzLm1hcChmZyA9PiBmZy5wYXRoKTtcbiAgICBjb25zdCBzZWxlY3RlZEdlb21ldHJ5ID0gZmlsdGVyR2VvbWV0cmllcy5maW5kKGZnID0+IGZnLnNlbGVjdGVkKTtcbiAgICBjb25zdCBzZWxlY3RlZEdlb21ldHJ5UGF0aCA9ICEhc2VsZWN0ZWRHZW9tZXRyeSA/IHNlbGVjdGVkR2VvbWV0cnkucGF0aCA6ICcnO1xuICAgIC8qKiBvcGVyYXRpb24gKi9cbiAgICBjb25zdCBvcGVyYXRpb25zID0gb3BlcmF0aW9uc1NlbGVjdE1vZGVsLm1hcChvc20gPT4gb3NtLm9wZXJhdGlvbik7XG4gICAgY29uc3Qgc2VsZWN0ZWRPcGVyYXRpb25TZWxlY3RNb2RlbCA9IG9wZXJhdGlvbnNTZWxlY3RNb2RlbC5maW5kKG9zbSA9PiBvc20uc2VsZWN0ZWQpO1xuICAgIGNvbnN0IHNlbGVjdGVkT3BlcmF0aW9uID0gISFzZWxlY3RlZE9wZXJhdGlvblNlbGVjdE1vZGVsID8gIHNlbGVjdGVkT3BlcmF0aW9uU2VsZWN0TW9kZWwub3BlcmF0aW9uIDogR2VvUXVlcnlPcGVyYXRvci5JTlRFUlNFQ1RTO1xuICAgIGNvbnN0IGdlb1F1ZXJ5Q29udHJvbHMgPSB7XG4gICAgICBhX29wZXJhdGlvbjogbmV3IFNlbGVjdEZvcm1Db250cm9sKHNlbGVjdGVkT3BlcmF0aW9uLCAnJywgb3BlcmF0aW9ucyksXG4gICAgICBiX2dlb21ldHJ5UGF0aDogbmV3IFNlbGVjdEZvcm1Db250cm9sKHNlbGVjdGVkR2VvbWV0cnlQYXRoLCAnJywgZ2VvbWV0cnlQYXRocyksXG4gICAgICBjX2NvbGxlY3Rpb246IG5ldyBVbnR5cGVkRm9ybUNvbnRyb2woY29sbGVjdGlvbk5hbWUpLFxuICAgICAgZF9kaXNwbGF5Q29sbGVjdGlvbk5hbWU6IG5ldyBVbnR5cGVkRm9ybUNvbnRyb2woZGlzcGxheUNvbGxlY3Rpb25OYW1lKSxcbiAgICB9O1xuICAgIGNvbnN0IGdlb1F1ZXJ5Rm9ybSA9IG5ldyBVbnR5cGVkRm9ybUdyb3VwKGdlb1F1ZXJ5Q29udHJvbHMpO1xuICAgIC8qKiBzbmFwc2hvdCBkZWZhdWx0c2VsZWN0aW9ucyAqL1xuICAgIHRoaXMuZW1pdHRlZEdlb1F1ZXJpZXMuY2xlYXIoKTtcbiAgICB0aGlzLnNlbGVjdGlvbnNTbmFwc2hvdC5jbGVhcigpO1xuICAgIHRoaXMuc2VsZWN0aW9uc1NuYXBzaG90LnNldChjb2xsZWN0aW9uTmFtZSwgc2VsZWN0ZWRHZW9tZXRyeSArIHNlbGVjdGVkT3BlcmF0aW9uKTtcbiAgICBnZW9RdWVyeUZvcm0udmFsdWVDaGFuZ2VzXG4gICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95JCkpXG4gICAgICAuc3Vic2NyaWJlKHZjID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvblNuYXBTaG90ID0gdmMuYl9nZW9tZXRyeVBhdGggKyB2Yy5hX29wZXJhdGlvbjtcbiAgICAgIC8qKiBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgaWYgdGhlIHVzZXIgZ28gYmFjayB0byBpbml0aWFsIHN0YXRlIG9mIGEgY29udHJvbCAqL1xuICAgICAgY29uc3QgaWdub3JlQ2hhbmdlID0gc2VsZWN0aW9uU25hcFNob3QgPT09IHRoaXMuc2VsZWN0aW9uc1NuYXBzaG90LmdldCh2Yy5jX2NvbGxlY3Rpb24pO1xuICAgICAgaWYgKGlnbm9yZUNoYW5nZSkge1xuICAgICAgICB0aGlzLmVtaXR0ZWRHZW9RdWVyaWVzLmRlbGV0ZSh2Yy5jX2NvbGxlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0dGVkR2VvUXVlcmllcy5zZXQodmMuY19jb2xsZWN0aW9uLCB7XG4gICAgICAgICAgZ2VvbWV0cnlfcGF0aDogdmMuYl9nZW9tZXRyeVBhdGgsXG4gICAgICAgICAgb3BlcmF0aW9uOiB2Yy5hX29wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNvbGxlY3Rpb25zQ29sb3JzLnB1c2goKHRoaXMuY29sb3JHZW5lcmF0b3JMb2FkZXIuZ2V0Q29sb3IoY29sbGVjdGlvbk5hbWUpKSk7XG4gICAgdGhpcy5nZW9RdWVyaWVzRm9ybUdyb3Vwcy5wdXNoKGdlb1F1ZXJ5Rm9ybSk7XG4gIH1cbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYXJsYXMtbWFwLXNldHRpbmdzJyxcbiAgdGVtcGxhdGVVcmw6ICcuL21hcC1zZXR0aW5ncy5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL21hcC1zZXR0aW5ncy5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE1hcFNldHRpbmdzQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogQE91dHB1dCA6IEFuZ3VsYXJcbiAgICogRW1pdHMgdGhlIGdlby1xdWVyeSB0byBhcHBseS4gQSBnZW8tcXVlcnkgaXMgZGVmaW5lZCBieVxuICAgKiAtIHRoZSBvcGVyYXRpb24gKFwid2l0aGluXCIsIFwiaW50ZXJzZWN0c1wiLCBcIm5vdHdpdGhpblwiLCBcIm5vdGludGVyc2VjdHNcIilcbiAgICogLSB0aGUgZ2VvbWV0cnkgZmllbGQgdG8gcXVlcnlcbiAgICovXG4gIEBPdXRwdXQoKSBwdWJsaWMgZ2VvUXVlcnlFbWl0dGVyID0gbmV3IFN1YmplY3Q8TWFwPHN0cmluZywgR2VvUXVlcnk+PigpO1xuXG4gIHB1YmxpYyBkaWFsb2dSZWY6IE1hdERpYWxvZ1JlZjxNYXBTZXR0aW5nc0RpYWxvZ0NvbXBvbmVudD47XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBkaWFsb2c6IE1hdERpYWxvZykgeyB9XG5cbiAgcHVibGljIG9wZW5EaWFsb2cobWFwU2V0dGluZ3NTZXJ2aWNlOiBNYXBTZXR0aW5nc1NlcnZpY2UpIHtcbiAgICB0aGlzLmRpYWxvZ1JlZiA9IHRoaXMuZGlhbG9nLm9wZW4oTWFwU2V0dGluZ3NEaWFsb2dDb21wb25lbnQsIHsgZGF0YTogbnVsbCwgcGFuZWxDbGFzczogJ21hcC1zZXR0aW5ncy1kaWFsb2cnIH0pO1xuICAgIGNvbnN0IG1hcEdlb1F1ZXJpZXMgPSBtYXBTZXR0aW5nc1NlcnZpY2UuZ2V0R2VvUXVlcmllcygpO1xuICAgIGlmICghIW1hcEdlb1F1ZXJpZXMpIHtcbiAgICAgIG1hcEdlb1F1ZXJpZXMuZm9yRWFjaCgoZ2VvUXVlcmllcywgY29sbGVjdGlvbikgPT4ge1xuICAgICAgICB0aGlzLmRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZS5jcmVhdGVHZW9RdWVyeUZvcm0oY29sbGVjdGlvbiwgZ2VvUXVlcmllc1syXSwgZ2VvUXVlcmllc1swXSwgZ2VvUXVlcmllc1sxXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5kaWFsb2dSZWYuY29tcG9uZW50SW5zdGFuY2UuZ2VvUXVlcnlFbWl0dGVyID0gdGhpcy5nZW9RdWVyeUVtaXR0ZXI7XG4gIH1cbn1cbiIsIjxoMSBtYXQtZGlhbG9nLXRpdGxlIGNsYXNzPVwibWFwZ2wtc2V0dGluZ3NfX3RpdGxlXCI+XG4gIHt7ICdHZW8tcXVlcmllcycgfCB0cmFuc2xhdGUgfX1cbjwvaDE+XG5cbjxkaXYgbWF0LWRpYWxvZy1jb250ZW50IGNsYXNzPVwibWFwZ2wtc2V0dGluZ3NcIj5cbiAgPGRpdiBjbGFzcz1cIm1hcGdsLXNldHRpbmdzX19kZXNjcmlwdGlvblwiPlxuICAgIHt7IEdFT19RVUVSSUVTX0RFU0NSSVBUSU9OIHwgdHJhbnNsYXRlIH19XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwibWFwZ2wtc2V0dGluZ3NfX2Zvcm1cIiAqbmdGb3I9XCJsZXQgZm9ybUdyb3VwIG9mIGdlb1F1ZXJpZXNGb3JtR3JvdXBzOyBsZXQgaSA9IGluZGV4XCJcbiAgICAgIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgW3N0eWxlLmJvcmRlckxlZnRDb2xvcl09XCJjb2xsZWN0aW9uc0NvbG9yc1tpXVwiPlxuICAgIDxkaXYgY2xhc3M9XCJtYXBnbC1zZXR0aW5nc19fZm9ybV9fc3RlcHNcIj5cbiAgICAgIDxkaXYgKm5nRm9yPVwibGV0IGNvbnRyb2wgb2YgZm9ybUdyb3VwLmNvbnRyb2xzIHwga2V5dmFsdWVcIiBjbGFzcz1cIm1hcGdsLXNldHRpbmdzX19mb3JtX19zdGVwc19faXRlbVwiPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwiY29udHJvbC5rZXkgPT09ICdkX2Rpc3BsYXlDb2xsZWN0aW9uTmFtZSdcIj5cbiAgICAgICAgICB7eyAnb2ZfY29sbGVjdGlvbicgfCB0cmFuc2xhdGU6IHsgY29sbGVjdGlvbjogKGNvbnRyb2wudmFsdWUudmFsdWUgfCBnZXRDb2xsZWN0aW9uRGlzcGxheU5hbWUgfCB0cmFuc2xhdGUpIH0gfX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxtYXQtZm9ybS1maWVsZCAqbmdJZj1cImNvbnRyb2wua2V5ICE9PSAnY19jb2xsZWN0aW9uJyAmJiBjb250cm9sLmtleSAhPT0gJ2NvbG9yJyAmJiBjb250cm9sLmtleSAhPT0gJ2RfZGlzcGxheUNvbGxlY3Rpb25OYW1lJ1wiPlxuICAgICAgICAgIDxtYXQtbGFiZWw+e3sgY29udHJvbC5rZXkgfCB0cmFuc2xhdGUgfX08L21hdC1sYWJlbD5cbiAgICAgICAgICA8bWF0LXNlbGVjdCBbZm9ybUNvbnRyb2xdPVwiY29udHJvbC52YWx1ZVwiPlxuICAgICAgICAgICAgPG1hdC1vcHRpb24gKm5nRm9yPVwibGV0IG9wdGlvbiBvZiBjb250cm9sLnZhbHVlLnN5bmNPcHRpb25zXCIgW3ZhbHVlXT1cIm9wdGlvblwiPlxuICAgICAgICAgICAgICB7e29wdGlvbiB8IHRyYW5zbGF0ZX19XG4gICAgICAgICAgICA8L21hdC1vcHRpb24+XG4gICAgICAgICAgPC9tYXQtc2VsZWN0PlxuICAgICAgICA8L21hdC1mb3JtLWZpZWxkPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgbWF0LWRpYWxvZy1hY3Rpb25zIGNsYXNzPVwibWFwZ2wtc2V0dGluZ3NfX2FjdGlvbnNcIj5cbiAgPGJ1dHRvbiBtYXQtYnV0dG9uIGNsYXNzPVwibWFwZ2wtc2V0dGluZ3NfX2FjdGlvbnMtLWFwcGx5XCJcbiAgICAoY2xpY2spPVwiZW1pdEdlb0ZpbHRlcigpXCI+e3sgJ0FwcGx5IGdlby1xdWVyaWVzJyB8IHRyYW5zbGF0ZSB9fTwvYnV0dG9uPlxuICA8YnV0dG9uIG1hdC1idXR0b24gY2xhc3M9XCJtYXBnbC1zZXR0aW5nc19fYWN0aW9ucy0tYXBwbHlcIlxuICAgIChjbGljayk9XCJlbWl0R2VvRmlsdGVyKCk7b25DbG9zZSgpXCI+e3sgJ1NldCBnZW8tcXVlcmllcycgfCB0cmFuc2xhdGUgfX08L2J1dHRvbj5cbiAgPGJ1dHRvbiBtYXQtYnV0dG9uIGNsYXNzPVwibWFwZ2wtc2V0dGluZ3NfX2FjdGlvbnMtLWNhbmNlbFwiXG4gICAgKGNsaWNrKT1cIm9uQ2xvc2UoKVwiPnt7ICdDYW5jZWwnIHwgdHJhbnNsYXRlfX08L2J1dHRvbj5cbjwvZGl2PlxuXG5cbiIsIlxuIl19