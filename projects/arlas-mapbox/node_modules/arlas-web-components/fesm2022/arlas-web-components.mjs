import { MultiSelectionDonut, OneSelectionDonut, DonutParams, HistogramUtils, DataType, SelectionType, ChartType, Position, SwimlaneMode, ChartArea, SwimlaneCircles, SwimlaneBars, ChartOneDimension, ChartBars, ChartCurve, HistogramParams, Margins, Dimensions, Timeline } from 'arlas-d3';
export { ChartType, DataType, Position, SwimlaneMode } from 'arlas-d3';
import * as i9 from '@angular/forms';
import { UntypedFormControl, Validators, FormsModule, UntypedFormGroup, ReactiveFormsModule } from '@angular/forms';
import { Subject, fromEvent, takeUntil as takeUntil$1, filter, take, debounceTime as debounceTime$1 } from 'rxjs';
import * as tinycolor from 'tinycolor2';
import tinycolor__default from 'tinycolor2';
import * as i0 from '@angular/core';
import { Injectable, Component, ViewEncapsulation, Input, Output, NgModule, Pipe, ElementRef, ViewChild, Directive, HostListener, EventEmitter } from '@angular/core';
import { debounceTime, takeUntil, timeout, retry } from 'rxjs/operators';
import * as i2 from '@ngx-translate/core';
import { TranslateModule } from '@ngx-translate/core';
import * as i2$1 from '@angular/common';
import { CommonModule, NgClass, UpperCasePipe, NgIf, NgForOf, AsyncPipe, KeyValuePipe } from '@angular/common';
import { SwimlaneRepresentation } from 'arlas-d3/histograms/utils/HistogramUtils';
import * as i5 from '@angular/material/tooltip';
import { MatTooltipModule } from '@angular/material/tooltip';
import * as i15 from 'ngx-loading-reloaded';
import { ngxLoadingAnimationTypes, NgxLoadingModule } from 'ngx-loading-reloaded';
import { marker } from '@colsen1991/ngx-translate-extract-marker';
import * as i3 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i6$1 from '@angular/material/button-toggle';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import * as i7 from '@angular/material/grid-list';
import { MatGridListModule } from '@angular/material/grid-list';
import * as i8 from '@angular/material/checkbox';
import { MatCheckboxModule } from '@angular/material/checkbox';
import * as i9$1 from '@angular/material/menu';
import { MatMenuModule } from '@angular/material/menu';
import * as i10 from '@angular/material/select';
import { MatSelectModule } from '@angular/material/select';
import * as i4$3 from '@angular/material/core';
import { MatNativeDateModule } from '@angular/material/core';
import * as i12 from '@angular/material/slide-toggle';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import * as i4$1 from 'ng-lazyload-image';
import { LazyLoadImageModule } from 'ng-lazyload-image';
import * as i4 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import { FullScreenViewer, ImageViewer } from 'iv-viewer';
import * as i2$2 from '@angular/common/http';
import * as i6 from '@angular/material/progress-spinner';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import * as i4$2 from '@angular/material/form-field';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatChipsModule } from '@angular/material/chips';
import { MatRadioModule } from '@angular/material/radio';
import * as i3$1 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import * as i11 from '@angular/material/card';
import { MatCardModule } from '@angular/material/card';
import * as i8$1 from '@angular/material/datepicker';
import { MatDatepickerModule } from '@angular/material/datepicker';
import * as i1 from '@angular/material/dialog';
import { MatDialogModule } from '@angular/material/dialog';
import * as i12$1 from '@angular/material/list';
import { MatListModule } from '@angular/material/list';
import moment from 'moment';

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function formatNumber(x, formatChar = ' ') {
    if (formatChar === NUMBER_FORMAT_CHAR) {
        formatChar = ' ';
    }
    if (+x + '' !== 'NaN' && typeof +x === 'number') {
        const num = +x;
        const trunc = Math.trunc(num);
        const decimal = (num + '').split('.');
        const spacedNumber = Math.abs(trunc).toString().replace(/\B(?=(\d{3})+(?!\d))/g, formatChar);
        const spacedNumberString = trunc < 0 ? '-' + spacedNumber : spacedNumber;
        if (num < 0.09 && num > -0.09 && num !== 0) {
            return Number.parseFloat(x).toExponential(3);
        }
        return decimal.length === 2 ? spacedNumberString + '.' + decimal[1] : spacedNumberString;
    }
    return x;
}
const NUMBER_FORMAT_CHAR = 'NUMBER_FORMAT_CHAR';
function numberToShortValue(number, p) {
    if (Math.abs(number) < 1000) {
        if (Math.round(number) === number) {
            return number.toFixed(0);
        }
        return number.toFixed(p);
    }
    // what tier? (determines SI symbol)
    const suffixes = ['', 'k', 'M', 'b', 't'];
    const suffixNum = Math.log10(Math.abs(number)) / 3 | 0;
    if (suffixNum === 0) {
        return number.toString();
    }
    // get suffix and determine scale
    const suffix = suffixes[suffixNum];
    const scale = Math.pow(10, suffixNum * 3);
    // scale the number
    const scaled = number / scale;
    // format number and add suffix
    return scaled.toFixed(p) + ' ' + suffix;
}
const DEFAULT_SHORTENING_PRECISION = 2;
function getKeys(map) {
    return Array.from(map.keys());
}
function getValues(map) {
    return Array.from(map.values());
}
class ColorGeneratorLoader {
}
class AwcColorGeneratorLoader extends ColorGeneratorLoader {
    constructor() {
        super(...arguments);
        this.changekeysToColors$ = new Subject().asObservable();
        this.colorsSaturationWeight = 0.5;
    }
    /**
     * This method generates a determistic color from the given key, a list of [key, color] and a saturation weight.
     * - First the method checks if the [key,color] is defined in externalkeysToColors and returns the correspondant color.
     *
     * - If externalkeysToColors parameter is undefined, then the method checks if the [key,color] is defined in
     * keysToColors attribute of the loader
     *
     * - If neither `externalkeysToColors` parameter nor `keysToColors` attribute are defined, then the color is generated using a determist
     * method.
     * - For this determinist method, the generated colors saturation scale can be tightened using `externalColorsSaturationWeight` parameter
     * - If the parameter `externalColorsSaturationWeight` is undefined, the attribute `colorsSaturationWeight` is used instead.
     * @param key The text from which the color is generated
     * @param externalkeysToColors List of [key, color] couples that associates a hex color to each key.
     * @param colorsSaturationWeight Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a factor (between 0 and 1) that
     * tightens this scale to [(1-colorsSaturationWeight), 1]. Therefore all generated colors saturation will be within this scale.
     */
    getColor(key, externalKeysToColors, externalColorsSaturationWeight) {
        let colorHex = null;
        const keysToColors = externalKeysToColors ? externalKeysToColors : this.keysToColors;
        const saturationWeight = (externalColorsSaturationWeight !== undefined && externalColorsSaturationWeight !== null) ?
            externalColorsSaturationWeight : this.colorsSaturationWeight;
        if (keysToColors) {
            for (let i = 0; i < keysToColors.length; i++) {
                const keyToColor = keysToColors[i];
                if (keyToColor[0] === key) {
                    colorHex = keyToColor[1];
                    break;
                }
            }
            if (!colorHex) {
                colorHex = this.getHexColor(key, saturationWeight);
            }
        }
        else {
            colorHex = this.getHexColor(key, saturationWeight);
        }
        return colorHex;
    }
    getTextColor(color) {
        return '#000000';
    }
    getHexColor(key, saturationWeight) {
        const text = key + ':' + key;
        // string to int
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
            hash = text.charCodeAt(i) + ((hash << 5) - hash);
        }
        // int to rgb
        let hex = (hash & 0x00FFFFFF).toString(16).toUpperCase();
        hex = '00000'.substring(0, 6 - hex.length) + hex;
        const color = tinycolor__default.mix(hex, hex);
        color.saturate(color.toHsv().s * saturationWeight + ((1 - saturationWeight) * 100));
        return color.toHexString();
    }
}
class SelectFormControl extends UntypedFormControl {
    constructor(formState, label, options) {
        super(formState, Validators.required);
        this.syncOptions = [];
        this.setValue(formState);
        this.setSyncOptions(options);
    }
    setSyncOptions(newOptions) {
        this.syncOptions = newOptions;
        this.filteredOptions = newOptions;
    }
}
const ARLAS_ID = 'arlas_id:';
/** FROM V15.0.0 layer ids look like 'arlas_id:NAME:timestamp
   * This pipe extracts the 'NAME' in that id
   */
function getLayerName(id) {
    if (!!id && id.startsWith(ARLAS_ID)) {
        const datedName = id.split(ARLAS_ID)[1];
        const undatedName = datedName.split(':')[0];
        return undatedName;
    }
    return id;
}

var $schema$5 = "http://json-schema.org/draft-06/schema#";
var title$5 = "Donut input configuration";
var description$5 = "The Configuration input of donut";
var type$5 = "object";
var $id$5 = "donut.schema.json";
var properties$5 = {
	id: {
		description: "Identifier of the donut",
		type: "string"
	},
	customizedCssClass: {
		description: "Css class name to use to customize a specific donut's style.",
		type: "string"
	},
	opacity: {
		description: "Opacity of unselected/unhovered arcs",
		type: "number"
	},
	multiselectable: {
		description: "Whether the donut is multi-selectable",
		type: "boolean"
	},
	keysToColors: {
		description: "List of [key, color] couples that associates a hex color to each key",
		type: "array",
		items: {
			type: "array",
			minItems: 2,
			maxItems: 2,
			items: [
				{
					description: "Key to which a color is associated",
					type: "string"
				},
				{
					description: "Hex color associated to the key",
					type: "string"
				}
			]
		}
	},
	colorsSaturationWeight: {
		description: "Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a factor (between 0 and 1) that tightens this scale to [(1-colorsSaturationWeight), 1]. Therefore all generated colors saturation will be within this scale.",
		type: "number"
	},
	diameter: {
		description: "Diameter of the donut. If it's not set, the donut take the Max(width,height) of the div containing the svg.",
		type: "number"
	},
	unit: {
		description: "Unit of a node in the donut",
		type: "string"
	}
};
var required$2 = [
	"id"
];
var donut_schema = {
	$schema: $schema$5,
	title: title$5,
	description: description$5,
	type: type$5,
	$id: $id$5,
	properties: properties$5,
	required: required$2
};

var donutJsonSchema = /*#__PURE__*/Object.freeze({
   __proto__: null,
   $id: $id$5,
   $schema: $schema$5,
   default: donut_schema,
   description: description$5,
   properties: properties$5,
   required: required$2,
   title: title$5,
   type: type$5
});

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ArlasColorService {
    constructor(colorGenerator) {
        this.colorGenerator = colorGenerator;
        this.changekeysToColors = new Subject();
        this.changekeysToColors$ = this.changekeysToColors.asObservable();
        this.colorGenerator.changekeysToColors$.subscribe(() => this.changekeysToColors.next());
    }
    getColor(key, keysToColors, colorsSaturationWeight) {
        return this.colorGenerator.getColor(key, keysToColors, colorsSaturationWeight);
    }
    getTextColor(color) {
        return this.colorGenerator.getTextColor(color);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasColorService, deps: [{ token: ColorGeneratorLoader }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasColorService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ArlasColorService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: ColorGeneratorLoader }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class DonutComponent {
    constructor(el, colorService, translate) {
        this.el = el;
        this.colorService = colorService;
        this.translate = translate;
        /**
         * @Input : Angular
         * @description Sets the opacity of non-hovered or non-selected nodes.
         */
        this.opacity = 0.4;
        /**
         * @Input : Angular
         * @description List of selected nodes.
         */
        this.selectedArcsList = new Array();
        /**
         * @Input : Angular
         * @description Whether the donut is multi-selectable.
         */
        this.multiselectable = true;
        /**
         * @Input : Angular
         * @description Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a
         * factor (between 0 and 1) that tightens this scale to [(1-colorsSaturationWeight), 1].
         * Therefore colors saturation of donuts arcs will be within this tightened scale..
         */
        this.colorsSaturationWeight = 1 / 2;
        /**
         * @Input : Angular
         * @description Unit that a node of the donut represents
         */
        this.unit = '';
        /**
         * @Output : Angular
         * @description Emits the list of selected nodes and the paths to their ultimate parent
         */
        this.selectedNodesEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the hovered node and the path to it's parents.
         * The key of the map is the node's name and the value is its color on the donut
         */
        this.hoveredNodesEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the information about the hovered node and its parents.
         */
        this.hoveredNodeTooltipEvent = new Subject();
        this._onDestroy$ = new Subject();
        fromEvent(window, 'resize')
            .pipe(debounceTime(500), takeUntil(this._onDestroy$))
            .subscribe((event) => {
            this.donut.resize(this.el.nativeElement.childNodes[0]);
        });
        this.colorService.changekeysToColors$
            .pipe(takeUntil(this._onDestroy$))
            .subscribe(() => {
            this.donut.donutParams.keysToColors = this.colorService.colorGenerator.keysToColors;
            this.donut.donutParams.donutNodeColorizer = this.colorService;
            this.donut.resize(this.el.nativeElement.childNodes[0]);
        });
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    ngOnChanges(changes) {
        if (this.donut === undefined) {
            if (this.multiselectable) {
                this.donut = new MultiSelectionDonut();
            }
            else {
                this.donut = new OneSelectionDonut();
            }
            this.setDonutParameters();
        }
        if (changes.donutData && this.donutData !== undefined && this.donutData !== null && this.donut !== undefined
            && this.donut.donutParams !== undefined) {
            this.donut.dataChange(this.donutData);
        }
        if (changes.selectedArcsList && this.selectedArcsList !== undefined && this.selectedArcsList !== null && this.donut !== undefined
            && this.donut.donutParams !== undefined && this.donut.donutParams.donutNodes !== undefined) {
            this.donut.onSelectionChange(this.selectedArcsList);
        }
    }
    /**
     * @returns Json schema of the donut component for configuration
     */
    static getDonutJsonSchema() {
        return donutJsonSchema;
    }
    setDonutParameters() {
        if (!this.unit) {
            this.unit = '';
        }
        this.donut.donutParams = new DonutParams();
        this.donut.donutParams.id = this.id;
        this.donut.donutParams.customizedCssClass = this.customizedCssClass;
        this.donut.donutParams.donutData = this.donutData;
        this.donut.donutParams.hoveredNodesEvent = this.hoveredNodesEvent;
        this.donut.donutParams.tooltipEvent = this.hoveredNodeTooltipEvent;
        this.donut.donutParams.multiselectable = this.multiselectable;
        this.donut.donutParams.opacity = this.opacity;
        this.donut.donutParams.selectedArcsList = this.selectedArcsList;
        this.donut.donutParams.selectedNodesEvent = this.selectedNodesEvent;
        this.donut.donutParams.donutContainer = this.el.nativeElement.childNodes[0];
        this.donut.donutParams.svgElement = this.el.nativeElement.childNodes[0].childNodes[0];
        this.donut.donutParams.keysToColors = this.keysToColors;
        this.donut.donutParams.colorsSaturationWeight = this.colorsSaturationWeight;
        this.donut.donutParams.donutNodeColorizer = this.colorService;
        this.donut.donutParams.numberFormatChar = this.translate.instant(NUMBER_FORMAT_CHAR);
        this.donut.donutParams.diameter = this.diameter;
        this.donut.donutParams.containerWidth = this.containerWidth;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: DonutComponent, deps: [{ token: i0.ElementRef }, { token: ArlasColorService }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: DonutComponent, selector: "arlas-donut", inputs: { donutData: "donutData", opacity: "opacity", customizedCssClass: "customizedCssClass", selectedArcsList: "selectedArcsList", multiselectable: "multiselectable", id: "id", keysToColors: "keysToColors", colorsSaturationWeight: "colorsSaturationWeight", diameter: "diameter", containerWidth: "containerWidth", unit: "unit" }, outputs: { selectedNodesEvent: "selectedNodesEvent", hoveredNodesEvent: "hoveredNodesEvent", hoveredNodeTooltipEvent: "hoveredNodeTooltipEvent" }, usesOnChanges: true, ngImport: i0, template: "<div id=\"{{id}}\" class=\"donut__container\" [ngClass]=\"customizedCssClass\">\n  <svg id=\"svgix\"></svg>\n</div>\n", styles: ["@charset \"UTF-8\";.donut__container{width:100%;height:100%;position:relative;display:flex;justify-content:center}.donut__tooltip{position:absolute;font-size:.8em;color:#f85e5e;background-color:#fff;border-radius:2px;padding:0 5px;z-index:1000}.donut__arc{fill-rule:evenodd;stroke:#fff;stroke-width:.4px}.donut__arc:hover{cursor:pointer}\n"], dependencies: [{ kind: "directive", type: i2$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: DonutComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-donut', encapsulation: ViewEncapsulation.None, template: "<div id=\"{{id}}\" class=\"donut__container\" [ngClass]=\"customizedCssClass\">\n  <svg id=\"svgix\"></svg>\n</div>\n", styles: ["@charset \"UTF-8\";.donut__container{width:100%;height:100%;position:relative;display:flex;justify-content:center}.donut__tooltip{position:absolute;font-size:.8em;color:#f85e5e;background-color:#fff;border-radius:2px;padding:0 5px;z-index:1000}.donut__arc{fill-rule:evenodd;stroke:#fff;stroke-width:.4px}.donut__arc:hover{cursor:pointer}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ArlasColorService }, { type: i2.TranslateService }], propDecorators: { donutData: [{
                type: Input
            }], opacity: [{
                type: Input
            }], customizedCssClass: [{
                type: Input
            }], selectedArcsList: [{
                type: Input
            }], multiselectable: [{
                type: Input
            }], id: [{
                type: Input
            }], keysToColors: [{
                type: Input
            }], colorsSaturationWeight: [{
                type: Input
            }], diameter: [{
                type: Input
            }], containerWidth: [{
                type: Input
            }], unit: [{
                type: Input
            }], selectedNodesEvent: [{
                type: Output
            }], hoveredNodesEvent: [{
                type: Output
            }], hoveredNodeTooltipEvent: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class DonutModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: DonutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: DonutModule, declarations: [DonutComponent], imports: [CommonModule], exports: [DonutComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: DonutModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: DonutModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [DonutComponent],
                    exports: [DonutComponent],
                    imports: [
                        CommonModule
                    ]
                }]
        }] });

var $schema$4 = "http://json-schema.org/draft-06/schema#";
var title$4 = "Histogram input configuration";
var description$4 = "The Configuration input of an histogram";
var type$4 = "object";
var $id$4 = "histogram.schema.json";
var properties$4 = {
	id: {
		description: "Identifier of the histogram",
		type: "string"
	},
	dataType: {
		description: "Type of data in histogram",
		"enum": [
			"numeric",
			"time"
		]
	},
	dataUnit: {
		description: "Unit of represented data on the histogram. Deprecated. If xUnit is specified, dataUnit is not taken into account.",
		type: "string"
	},
	xUnit: {
		description: "Unit of x axis values.",
		type: "string"
	},
	yUnit: {
		description: "Unit of x axis values.",
		type: "string"
	},
	chartXLabel: {
		description: "Chart's label for the x axis (Visible when there is one bucket on the histogram).",
		type: "string"
	},
	isHistogramSelectable: {
		description: "If you can select a period on histogram",
		type: "boolean"
	},
	multiselectable: {
		description: "If you can select several period on histogram",
		type: "boolean"
	},
	displayOnlyIntervalsWithData: {
		description: "If you can select several period on histogram",
		type: "boolean"
	},
	applyOffsetOnAreaChart: {
		description: "Translates area chart by half data interval",
		type: "boolean"
	},
	topOffsetRemoveInterval: {
		description: "Top position of the remove-selection-button",
		type: "number"
	},
	leftOffsetRemoveInterval: {
		description: "Left offset position of the remove-selection-button",
		type: "number"
	},
	brushHandlesHeightWeight: {
		description: " A 0 to 1 weight of the brush height. It controls the brush handles height.",
		type: "number"
	},
	chartType: {
		description: "Chart's representation type.",
		"enum": [
			"bars",
			"area",
			"oneDimension",
			"curve"
		]
	},
	chartTitle: {
		description: "Chart's title",
		type: "string"
	},
	chartWidth: {
		description: "Chart's width. If set to null, the chart takes the component's container width.",
		oneOf: [
			{
				type: "number"
			},
			{
				type: "null"
			}
		]
	},
	chartHeight: {
		description: "Chart's height. If set to null, the chart takes the component's container height",
		oneOf: [
			{
				type: "number"
			},
			{
				type: "null"
			}
		]
	},
	customizedCssClass: {
		description: "Css class name to use to customize a specific `arlas-histogram` component.",
		type: "string"
	},
	yAxisStartsFromZero: {
		description: "Whether the histogram values start from zero or from the minimum of data.",
		type: "boolean"
	},
	showStripes: {
		description: "Whether to add stripes in the histogram when yAxis starts from minimum of data.",
		type: "boolean"
	},
	xAxisPosition: {
		description: "The xAxis positon : above or below the chart.",
		"enum": [
			"top",
			"bottom"
		]
	},
	descriptionPosition: {
		description: "The start/end values positon : above or below the chart.",
		"enum": [
			"top",
			"bottom"
		]
	},
	xTicks: {
		description: "Number of ticks in the X axis.",
		type: "integer"
	},
	yTicks: {
		description: "Number of ticks in the Y axis.",
		type: "integer"
	},
	xLabels: {
		description: "Number of labels in the X axis.",
		type: "integer"
	},
	shortYLabels: {
		description: "Display short labels on y axis.",
		type: "boolean"
	},
	yLabels: {
		description: "Number of labels in the Y axis.",
		type: "integer"
	},
	showXTicks: {
		description: "Whether showing the X axis ticks.m",
		type: "boolean"
	},
	showYTicks: {
		description: "Whether showing the Y axis ticks.",
		type: "boolean"
	},
	showXLabels: {
		description: "Whether showing the X axis labels.",
		type: "boolean"
	},
	showYLabels: {
		description: "Whether showing the Y axis labels.",
		type: "boolean"
	},
	showHorizontalLines: {
		description: "Whether showing the horizontal dashed lines.",
		type: "boolean"
	},
	paletteColors: {
		description: "Either a hex string color or a color name (in English) or a saturation interval [0, 100].",
		type: [
			"array",
			"string"
		]
	},
	ticksDateFormat: {
		description: "The date format of ticks.* Please refer to this [list of specifiers](https://github.com/d3/d3-time-format/blob/master/README.md#locale_format).",
		type: "string"
	},
	isSmoothedCurve: {
		description: " Whether the curve of an `area` chart is smoothed.",
		type: "boolean"
	},
	barWeight: {
		description: "Weight applied to bars width. ]0,1].",
		type: "number"
	}
};
var required$1 = [
	"id"
];
var histogram_schema = {
	$schema: $schema$4,
	title: title$4,
	description: description$4,
	type: type$4,
	$id: $id$4,
	properties: properties$4,
	required: required$1
};

var histogramJsonSchema = /*#__PURE__*/Object.freeze({
   __proto__: null,
   $id: $id$4,
   $schema: $schema$4,
   default: histogram_schema,
   description: description$4,
   properties: properties$4,
   required: required$1,
   title: title$4,
   type: type$4
});

var $schema$3 = "http://json-schema.org/draft-06/schema#";
var title$3 = "Swimlane input configuration";
var description$3 = "The Configuration input of a swimlane";
var type$3 = "object";
var $id$3 = "swimlane.schema.json";
var allOf = [
	{
		$ref: "histogram.schema.json#"
	}
];
var properties$3 = {
	swimLaneLabelsWidth: {
		description: "The width of swimlane labels space.",
		type: "number"
	},
	swimlaneBorderRadius: {
		description: "The radius of swimlane bars borders",
		type: "number"
	},
	swimlaneHeight: {
		description: " The height of a single lane. If not specified, a lane height is the chartHeight devided by the number of lanes.",
		type: "number"
	},
	swimlaneMode: {
		description: "The swimlane mode. Variable or fixed Height. Or circles",
		"enum": [
			"variableHeight",
			"fixedHeight",
			"circles"
		]
	},
	swimlane_representation: {
		description: "The swimlane representation. `column` representation focuses on terms of the same column; each term is compared to the sum of all terms of the column. `global` representation compares all the buckets to the maximum value in the swimlane.",
		"enum": [
			"column",
			"global"
		]
	},
	swimlane_options: {
		description: "Graphical options to configure for the swimlane",
		type: "object",
		properties: {
			nan_color: {
				description: "Hex color attributted to buckets whose values are NaN",
				type: "string"
			},
			zeros_color: {
				description: "Hex color attributted to buckets whose values are 0",
				type: "string"
			},
			level_tick: {
				description: "Graphical options to configure the level tick. The level tick being a tick plotted on each swimlane bucket that indicates how high/low the bucket value is",
				type: "object",
				properties: {
					color: {
						description: "Hex color of the tick",
						type: "string"
					},
					width: {
						description: "Width of the tick in pixels",
						type: "number"
					},
					opacity: {
						description: "Opacity of the tick",
						type: "number"
					}
				}
			}
		}
	}
};
var swimlane_schema = {
	$schema: $schema$3,
	title: title$3,
	description: description$3,
	type: type$3,
	$id: $id$3,
	allOf: allOf,
	properties: properties$3
};

var swimlaneJsonSchema = /*#__PURE__*/Object.freeze({
   __proto__: null,
   $id: $id$3,
   $schema: $schema$3,
   allOf: allOf,
   default: swimlane_schema,
   description: description$3,
   properties: properties$3,
   title: title$3,
   type: type$3
});

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class BaseCollectionService {
}
class AwcCollectionService extends BaseCollectionService {
    getAllUnits() {
        return [];
    }
    _initUnits() { }
    _initDisplayNames() { }
    getDisplayName(collectionName) {
        return collectionName;
    }
    getDisplayFieldName(fieldName) {
        return fieldName;
    }
    getUnit(collectionName) {
        return collectionName;
    }
}
class CollectionService {
    constructor(baseCollectionService) {
        this.baseCollectionService = baseCollectionService;
    }
    getDisplayName(collectionName) {
        return this.baseCollectionService.getDisplayName(collectionName);
    }
    ;
    getDisplayFieldName(fieldName) {
        return this.baseCollectionService.getDisplayFieldName(fieldName);
    }
    ;
    getUnit(collectionName) {
        return this.baseCollectionService.getUnit(collectionName);
    }
    ;
    getAllUnits() {
        return this.baseCollectionService.getAllUnits();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CollectionService, deps: [{ token: BaseCollectionService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CollectionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CollectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: BaseCollectionService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetCollectionUnitPipe {
    constructor(arlasCollectionService) {
        this.arlasCollectionService = arlasCollectionService;
    }
    transform(value) {
        if (!value) {
            return '';
        }
        return this.arlasCollectionService.getUnit(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionUnitPipe, deps: [{ token: CollectionService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionUnitPipe, name: "getCollectionUnit" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionUnitPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'getCollectionUnit'
                }]
        }], ctorParameters: () => [{ type: CollectionService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class HistogramKeyPipe {
    transform(key, ...args) {
        return HistogramUtils.toString(key, args[0]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: HistogramKeyPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: HistogramKeyPipe, name: "histogramKey" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: HistogramKeyPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'histogramKey'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * The Histogram web component allows you to display your numeric and temporal data in charts or swimlanes.
 * Charts can be represented as bars or areas.
 * Swimlanes can be represented as bars or circles.
 * For both modes, data can be multi-selected using a selection brush.
 */
class HistogramComponent {
    constructor(colorService, el, translate) {
        this.colorService = colorService;
        this.el = el;
        this.translate = translate;
        /**
         * @Input
         * @description To be set to `time` when x axis represents dates and to `numeric` otherwise.
         */
        this.dataType = DataType.numeric;
        /**
         * @description Unit of data to add in the end of tooltip values.
         * @deprecated If xUnit is specified, dataUnit is not taken into account.
         */
        this.dataUnit = '';
        /**
         * @description Unit of x axis values.
         */
        this.xUnit = '';
        /**
         * @description Unit of y axis values.
         */
        this.yUnit = '';
        /**
         * @Input : Angular
         * @description The date format of the start/end values.
         *  Please refer to this [list of specifiers](https://github.com/d3/d3-time-format/blob/master/README.md#locale_format).
         */
        this.valuesDateFormat = null;
        /**
         * @Input : Angular
         * @description Whether the chart is selectable.
         */
        this.isHistogramSelectable = true;
        /**
         * @Input : Angular
         * @description Whether the selection is multiple.
         */
        this.multiselectable = false;
        /**
         * @Input : Angular
         * @description Top position of the remove-selection-button.
         */
        this.topOffsetRemoveInterval = 40;
        /**
         * @Input : Angular
         * @description leftOffsetRemoveInterval.
         */
        this.leftOffsetRemoveInterval = 18;
        /**
         * @Input : Angular
         * @description A 0 to 1 weight of the brush handles height.
         * This input will be taken into account when selectionType is 'rectangle'.
         * (This input will be renamed handlesHeightWeight in the v25.0.0 release.)
         */
        this.brushHandlesHeightWeight = 1;
        /**
         * @Input : Angular
         * @description Radius of handles in pixels. This input will be taken into account when selectionType is 'slider'.
         */
        this.handlesRadius = 4;
        /**
         * @Input : Angular
         * @description Radius of handles in pixels. This input will be taken into account when selectionType is 'slider'.
         */
        this.selectionType = SelectionType.slider;
        /**
         * @Input : Angular
         * @description Chart's representation type.
         */
        this.chartType = ChartType.area;
        /**
         * @Input : Angular
         * @description Chart's title.
         */
        this.chartTitle = '';
        /**
         * @Input : Angular
         * @description Chart's label for the x axis (Visible when there is one bucket on the histogram).
         */
        this.chartXLabel = '';
        /**
         * @Input : Angular
         * @description Chart's label for the y axis (Visible when there is one bucket on the histogram).
         */
        this.chartYLabel = '';
        /**
         * @Input : Angular
         * @description Chart's width. If not specified, the chart takes the component's container width.
         */
        this.chartWidth = null;
        /**
         * @Input : Angular
         * @description Chart's height. If not specified, the chart takes the component's container height.
         */
        this.chartHeight = null;
        /**
         * @Input : Angular
         * @description Css class name to use to customize a specific `arlas-histogram` component.
         */
        this.customizedCssClass = '';
        /**
         * @Input : Angular
         * @description Whether the histogram values start from zero or from the minimum of data
         */
        this.yAxisStartsFromZero = true;
        /**
         * @Input : Angular
         * @description Whether to add stripes in the histograms when yAxis starts from minimum of data
         */
        this.showStripes = true;
        /**
         * @Input : Angular
         * @description The xAxis positon : above or below the chart.
         */
        this.xAxisPosition = Position.bottom;
        /**
         * @Input : Angular
         * @description The start/end values positon : above or below the chart.
         */
        this.descriptionPosition = Position.bottom;
        /**
         * @Input : Angular
         * @description Number of ticks in the X axis.
         */
        this.xTicks = 5;
        /**
         * @Input : Angular
         * @description Number of ticks in the Y axis.
         */
        this.yTicks = 5;
        /**
         * @Input : Angular
         * @description Number of labels in the X axis.
         */
        this.xLabels = 5;
        /**
         * @Input : Angular
         * @description Number of labels in the Y axis.
         */
        this.yLabels = 5;
        /**
         * @Input : Angular
         * @description Display short labels on y axis.
         */
        this.shortYLabels = false;
        /**
         * @Input : Angular
         * @description Whether showing the X axis ticks.
         */
        this.showXTicks = true;
        /**
         * @Input : Angular
         * @description Whether showing the Y axis ticks.
         */
        this.showYTicks = true;
        /**
         * @Input : Angular
         * @description Whether showing the X axis labels.
         */
        this.showXLabels = true;
        /**
         * @Input : Angular
         * @description Whether showing the Y axis labels.
         */
        this.showYLabels = true;
        /**
         * @Input : Angular
         * @description Whether showing the horizontal dashed lines.
         */
        this.showHorizontalLines = true;
        /**
         * @Input : Angular
         * @description The date format of ticks.
         * Please refer to this [list of specifiers](https://github.com/d3/d3-time-format/blob/master/README.md#locale_format).
         */
        this.ticksDateFormat = null;
        /**
         * @Input : Angular
         * @description Whether the curve of an `area` chart is smoothed.
         */
        this.isSmoothedCurve = true;
        /**
         * @Input : Angular
         * @description Weight applied to bars width. ]0,1].
         */
        this.barWeight = 0.6;
        /**
         * @Input : Angular
         * @description Either a hex string color or a color name (in English) or a saturation interval.
         */
        this.paletteColors = null;
        /**
        * @Input : Angular
        * @description Allows to include only selections that contain data in the histogram/swimlane
        */
        this.displayOnlyIntervalsWithData = false;
        /**
         * @Input : Angular
         * @description Translates area chart by half data interval
         */
        this.applyOffsetOnAreaChart = true;
        /**
         * @Input : Angular
         * @description The swimlane mode.
         * - `variableHeight` buckets height varies with the bucket's value
         * - `fixedHeight` all the buckets have the same height. A level tick is plotted on the bucket to indicate
         * the value level compared to other values.
         * - `circles` buckets are represented with circles whose radius varies the bucket's value.
         */
        this.swimlaneMode = SwimlaneMode.variableHeight;
        /**
         * @Input : Angular
         * @description The swimlane representation.
         * - `column` representation focuses on terms of the same column; each term is compared to the sum of all terms values in the column.
         * - `global` representation compares all the buckets values to the maximum value in the swimlane.
         */
        this.swimlaneRepresentation = SwimlaneRepresentation.global;
        /**
         * @Input : Angular
         * @description The width of swimlane labels space.
         */
        this.swimLaneLabelsWidth = null;
        /**
         * @Input : Angular
         * @description The radius of swimlane bars borders.
         */
        this.swimlaneBorderRadius = 3;
        /**
         * @Input : Angular
         * @description The height of a single lane. If not specified, a lane height is the chartHeight devided by the number of lanes.
         */
        this.swimlaneHeight = null;
        /**
         * @Input : Angular
         * @description Term's list of powerbars to select
         */
        this.selectedSwimlanes = new Set();
        /**
       * @Input : Angular
       * @description Wether use UTC to display date on the app
       */
        this.useUtc = true;
        /**
         * @Output : Angular
         * @description Emits the list of selected powerbars terms
         */
        this.selectedSwimlanesEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the list of selected intervals.
         */
        this.valuesListChangedEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the hovered bucket key (key as in HistogramData).
         */
        this.hoveredBucketEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits an event informing that the chart finished plotting.
         */
        this.dataPlottedEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the hovered bucket information that can be exploited to display a tooltip
         */
        this.tooltipEvent = new Subject();
        this.ChartType = ChartType;
        this.Position = Position;
        this._onDestroy$ = new Subject();
        fromEvent(window, 'resize')
            .pipe(debounceTime(500), takeUntil(this._onDestroy$))
            .subscribe((event) => {
            this.resizeHistogram();
        });
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    static getHistogramJsonSchema() {
        return histogramJsonSchema;
    }
    static getSwimlaneJsonSchema() {
        return swimlaneJsonSchema;
    }
    ngOnChanges(changes) {
        if (this.histogram === undefined) {
            switch (this.chartType) {
                case ChartType.area: {
                    this.histogram = new ChartArea();
                    this.chart = this.histogram;
                    break;
                }
                case ChartType.curve: {
                    this.histogram = new ChartCurve();
                    this.chart = this.histogram;
                    break;
                }
                case ChartType.bars: {
                    this.histogram = new ChartBars();
                    this.chart = this.histogram;
                    break;
                }
                case ChartType.oneDimension: {
                    this.histogram = new ChartOneDimension();
                    this.chart = this.histogram;
                    break;
                }
                case ChartType.swimlane: {
                    if (this.swimlaneMode === SwimlaneMode.circles) {
                        this.histogram = new SwimlaneCircles();
                    }
                    else {
                        this.histogram = new SwimlaneBars();
                    }
                    break;
                }
                default: {
                    this.histogram = new ChartArea();
                    break;
                }
            }
            this.setHistogramParameters();
        }
        if (changes.data && this.data !== undefined && this.histogram !== undefined) {
            if (Array.isArray(this.data)) {
                this.histogram.histogramParams.histogramData = this.data;
            }
            else {
                this.histogram.histogramParams.swimlaneData = this.data;
            }
            this.histogram.histogramParams.hasDataChanged = true;
            this.plotHistogram(this.data);
            this.histogram.histogramParams.hasDataChanged = false;
            this.dataPlottedEvent.next('DATA_PLOTTED');
        }
        if (changes.intervalSelection && this.intervalSelection !== undefined && this.histogram !== undefined && this.isHistogramSelectable) {
            this.histogram.histogramParams.intervalSelection = this.intervalSelection;
            if (this.histogram.histogramParams.dataLength > 0) {
                this.histogram.setSelectedInterval(this.intervalSelection);
            }
        }
        if (changes.intervalListSelection && this.isHistogramSelectable && this.histogram !== undefined) {
            if (changes.intervalListSelection.currentValue) {
                this.histogram.histogramParams.intervalListSelection = this.intervalListSelection;
                this.histogram.redrawSelectedIntervals();
            }
        }
        if (changes.selectedSwimlanes && this.histogram !== undefined && this.chartType === ChartType.swimlane) {
            this.histogram.histogramParams.selectedSwimlanes = this.selectedSwimlanes;
            this.histogram.applyStyleOnSwimlanes();
        }
    }
    ngOnInit() {
    }
    ngAfterViewChecked() {
        if (this.chartType === ChartType.swimlane) {
            this.histogram.truncateLabels();
        }
        if (this.rt !== undefined && this.lt !== undefined) {
            this.histogram.setHTMLElementsOfBrushCornerTooltips(this.rt.nativeElement, this.lt.nativeElement);
        }
    }
    /**
     * @description Plots the histogram
     */
    plotHistogram(inputData) {
        this.histogram.plot(inputData);
    }
    /**
     * @description Resizes the histogram on windows resize event
     */
    resizeHistogram() {
        if (this.histogram) {
            this.histogram.resize(this.el.nativeElement.childNodes[0]);
        }
    }
    /**
     * @description Removes the selected interval
     */
    removeSelectInterval(id) {
        this.histogram.removeSelectInterval(id);
    }
    setHistogramParameters() {
        if (!this.chartXLabel) {
            this.chartXLabel = '';
        }
        if (!this.chartYLabel) {
            this.chartYLabel = '';
        }
        if (!this.xUnit && this.dataUnit) {
            this.xUnit = this.dataUnit;
        }
        else if (!this.xUnit) {
            this.xUnit = '';
        }
        if (!this.dataUnit) {
            this.dataUnit = '';
        }
        if (!this.yUnit) {
            this.yUnit = '';
        }
        if (!this.selectionType) {
            this.selectionType = SelectionType.slider;
        }
        this.histogram.histogramParams = new HistogramParams();
        this.histogram.histogramParams.useUtc = this.useUtc;
        this.histogram.histogramParams.selectionType = this.selectionType;
        this.histogram.histogramParams.handlesRadius = this.handlesRadius;
        if (this.histogram.histogramParams.useUtc === undefined) {
            this.histogram.histogramParams.useUtc = true;
        }
        this.histogram.histogramParams.barWeight = this.barWeight;
        this.histogram.histogramParams.numberFormatChar = this.translate.instant(NUMBER_FORMAT_CHAR);
        this.histogram.histogramParams.handlesHeightWeight = this.brushHandlesHeightWeight;
        this.histogram.histogramParams.chartHeight = this.chartHeight;
        this.histogram.histogramParams.chartTitle = this.chartTitle;
        this.histogram.histogramParams.chartType = this.chartType;
        this.histogram.histogramParams.chartWidth = this.chartWidth;
        if (Array.isArray(this.data)) {
            this.histogram.histogramParams.histogramData = this.data;
        }
        else {
            this.histogram.histogramParams.swimlaneData = this.data;
        }
        this.histogram.histogramParams.dataType = this.dataType;
        this.histogram.histogramParams.dataUnit = this.dataUnit;
        this.histogram.histogramParams.hoveredBucketEvent = this.hoveredBucketEvent;
        this.histogram.histogramParams.intervalListSelection = this.intervalListSelection;
        this.histogram.histogramParams.intervalSelection = this.intervalSelection;
        this.histogram.histogramParams.isHistogramSelectable = this.isHistogramSelectable;
        this.histogram.histogramParams.isSmoothedCurve = this.isSmoothedCurve;
        this.histogram.histogramParams.multiselectable = this.multiselectable;
        this.histogram.histogramParams.paletteColors = this.paletteColors;
        this.histogram.histogramParams.showHorizontalLines = this.showHorizontalLines;
        this.histogram.histogramParams.showXLabels = this.showXLabels;
        this.histogram.histogramParams.showXTicks = this.showXTicks;
        this.histogram.histogramParams.showYLabels = this.showYLabels;
        this.histogram.histogramParams.showYTicks = this.showYTicks;
        this.histogram.histogramParams.ticksDateFormat = this.ticksDateFormat;
        this.histogram.histogramParams.topOffsetRemoveInterval = this.topOffsetRemoveInterval;
        this.histogram.histogramParams.valuesDateFormat = this.valuesDateFormat;
        this.histogram.histogramParams.valuesListChangedEvent = this.valuesListChangedEvent;
        this.histogram.histogramParams.xAxisPosition = this.xAxisPosition;
        this.histogram.histogramParams.xLabels = this.xLabels;
        this.histogram.histogramParams.xTicks = this.xTicks;
        this.histogram.histogramParams.yLabels = this.yLabels;
        this.histogram.histogramParams.yTicks = this.yTicks;
        this.histogram.histogramParams.shortYLabels = this.shortYLabels;
        this.histogram.histogramParams.swimLaneLabelsWidth = this.swimLaneLabelsWidth;
        this.histogram.histogramParams.swimlaneHeight = this.swimlaneHeight;
        this.histogram.histogramParams.swimlaneBorderRadius = this.swimlaneBorderRadius;
        this.histogram.histogramParams.swimlaneMode = this.swimlaneMode;
        this.histogram.histogramParams.swimlaneOptions = this.swimlaneOptions;
        this.histogram.histogramParams.swimlaneRepresentation = this.swimlaneRepresentation !== undefined ?
            this.swimlaneRepresentation : SwimlaneRepresentation.global;
        this.histogram.histogramParams.uid = HistogramUtils.generateUID();
        this.histogram.histogramParams.id = this.id;
        this.histogram.histogramParams.histogramContainer = this.el.nativeElement.childNodes[0];
        this.histogram.histogramParams.svgNode = this.el.nativeElement.childNodes[0].querySelector('svg');
        this.histogram.histogramParams.displayOnlyIntervalsWithData = this.displayOnlyIntervalsWithData;
        this.histogram.histogramParams.yAxisFromZero = this.yAxisStartsFromZero;
        this.histogram.histogramParams.showStripes = this.showStripes;
        this.histogram.histogramParams.moveDataByHalfInterval = this.applyOffsetOnAreaChart;
        this.histogram.histogramParams.selectedSwimlanes = this.selectedSwimlanes;
        this.histogram.histogramParams.selectedSwimlanesEvent = this.selectedSwimlanesEvent;
        this.histogram.histogramParams.colorGenerator = this.colorService;
        this.histogram.histogramParams.mainChartId = this.mainChartId;
        this.histogram.histogramParams.tooltipEvent
            .pipe(takeUntil(this._onDestroy$))
            .subscribe(t => {
            t.title = this.chartTitle;
            t.xLabel = this.chartXLabel;
            t.yLabel = this.chartYLabel;
            t.xUnit = this.xUnit;
            t.yUnit = this.yUnit;
            this.tooltipEvent.next(t);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: HistogramComponent, deps: [{ token: ArlasColorService }, { token: i0.ElementRef }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: HistogramComponent, selector: "arlas-histogram", inputs: { data: "data", mainChartId: "mainChartId", dataType: "dataType", dataUnit: "dataUnit", xUnit: "xUnit", yUnit: "yUnit", valuesDateFormat: "valuesDateFormat", isHistogramSelectable: "isHistogramSelectable", multiselectable: "multiselectable", intervalSelection: "intervalSelection", intervalListSelection: "intervalListSelection", topOffsetRemoveInterval: "topOffsetRemoveInterval", leftOffsetRemoveInterval: "leftOffsetRemoveInterval", brushHandlesHeightWeight: "brushHandlesHeightWeight", handlesRadius: "handlesRadius", selectionType: "selectionType", chartType: "chartType", chartTitle: "chartTitle", chartXLabel: "chartXLabel", chartYLabel: "chartYLabel", chartWidth: "chartWidth", chartHeight: "chartHeight", customizedCssClass: "customizedCssClass", yAxisStartsFromZero: "yAxisStartsFromZero", showStripes: "showStripes", xAxisPosition: "xAxisPosition", descriptionPosition: "descriptionPosition", xTicks: "xTicks", yTicks: "yTicks", xLabels: "xLabels", yLabels: "yLabels", shortYLabels: "shortYLabels", showXTicks: "showXTicks", showYTicks: "showYTicks", showXLabels: "showXLabels", showYLabels: "showYLabels", showHorizontalLines: "showHorizontalLines", ticksDateFormat: "ticksDateFormat", isSmoothedCurve: "isSmoothedCurve", barWeight: "barWeight", paletteColors: "paletteColors", displayOnlyIntervalsWithData: "displayOnlyIntervalsWithData", applyOffsetOnAreaChart: "applyOffsetOnAreaChart", swimlaneMode: "swimlaneMode", swimlaneRepresentation: "swimlaneRepresentation", swimlaneOptions: "swimlaneOptions", swimLaneLabelsWidth: "swimLaneLabelsWidth", swimlaneBorderRadius: "swimlaneBorderRadius", swimlaneHeight: "swimlaneHeight", id: "id", selectedSwimlanes: "selectedSwimlanes", useUtc: "useUtc" }, outputs: { selectedSwimlanesEvent: "selectedSwimlanesEvent", valuesListChangedEvent: "valuesListChangedEvent", hoveredBucketEvent: "hoveredBucketEvent", dataPlottedEvent: "dataPlottedEvent", tooltipEvent: "tooltipEvent" }, viewQueries: [{ propertyName: "lt", first: true, predicate: ["left"], descendants: true, read: ElementRef }, { propertyName: "rt", first: true, predicate: ["right"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: "<div id=\"{{id}}\" class=\"histogram\" [ngClass]=\"customizedCssClass\">\n  <div *ngIf=\"descriptionPosition === Position.top\" class=\"histogram__description\" [style.width.px]=\"histogram?.histogramParams.chartWidth-histogram?.histogramParams.margin.left-histogram?.histogramParams.margin.right\"\n    [style.margin-left.px]=\"histogram?.histogramParams.margin.left\" [style.margin-right.px]=\"histogram?.histogramParams.margin.right\">\n    <div class=\"histogram__description--display\">\n      <div class=\"histogram__description__startvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__startvalue--background\">{{histogram?.histogramParams.startValue}}</span>\n      </div>\n      <div class=\"histogram__description__title\">\n        <span *ngIf=\"histogram?.histogramParams.showTitle\">{{histogram?.histogramParams.chartTitle}}</span>\n      </div>\n      <div class=\"histogram__description__endvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__endvalue--background\">{{histogram?.histogramParams.endValue}}</span>\n      </div>\n    </div>\n  </div>\n  <div [style.display]=\"histogram?.histogramParams.displaySvg\" style=\"position:relative\">\n    <svg id=\"svgix\" class=\"histogram__chart\" [style.width.px]=\"histogram?.histogramParams.chartWidth\" [style.height.px]=\"histogram?.histogramParams.chartHeight\"></svg>\n    <div *ngIf=\"chart?.brush?.isBrushing\">\n      <div #left [style.visibility]=\"histogram?.brushCornerTooltips.horizontalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__horizontal--left\"\n        [style.left.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.yPosition\">\n        {{histogram?.brushCornerTooltips.leftCornerTooltip.content}}\n      </div>\n      <div #right [style.visibility]=\"histogram?.brushCornerTooltips.horizontalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__horizontal--right\"\n        [style.right.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.yPosition\">\n        {{histogram?.brushCornerTooltips.rightCornerTooltip.content}}\n      </div>\n\n      <div #leftvertical [style.visibility]=\"histogram?.brushCornerTooltips.verticalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__vertical--left__rotation histogram__brush-tooltip__vertical--left\"\n        [style.left.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.yPosition\" [style.width.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.width\">\n        {{histogram?.brushCornerTooltips.leftCornerTooltip.content}}\n      </div>\n      <div #rightvertical [style.visibility]=\"histogram?.brushCornerTooltips.verticalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__vertical--right__rotation histogram__brush-tooltip__vertical--right\"\n        [style.left.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.yPosition\" [style.width.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.width\">\n        {{histogram?.brushCornerTooltips.rightCornerTooltip.content}}\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"histogram?.histogramParams.dataLength === 1\" class=\"histogram__no-chart\" [style.width.px]=\"histogram?.histogramParams.chartWidth\" [style.height.px]=\"histogram?.histogramParams.chartHeight\">\n    <span class=\"histogram__no-chart__key\">{{chartXLabel | translate}} {{data[0].key | histogramKey : histogram?.histogramParams }} {{xUnit | translate}}</span>\n    <div *ngFor=\"let d of data\">\n      <span class=\"histogram__no-chart__value\">{{histogram?.histogramParams.chartTitle | translate}} {{d.value}}  {{ ((yUnit && yUnit.length > 0) ? yUnit : d.chartId | getCollectionUnit) | translate }}</span>\n    </div>\n  </div>\n  <div *ngIf=\"descriptionPosition === Position.bottom\" class=\"histogram__description\" [style.width.px]=\"histogram?.histogramParams.chartWidth-histogram?.histogramParams.margin.left-histogram?.histogramParams.margin.right\"\n    [style.margin-left.px]=\"histogram?.histogramParams.margin.left\" [style.margin-right.px]=\"histogram?.histogramParams.margin.right\">\n    <div class=\"histogram__description--display\">\n      <div class=\"histogram__description__startvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__startvalue--background\">{{histogram?.histogramParams.startValue}}</span>\n      </div>\n      <div class=\"histogram__description__title\">\n        <span *ngIf=\"histogram?.histogramParams.showTitle\">{{histogram?.histogramParams.chartTitle}}</span>\n      </div>\n      <div class=\"histogram__description__endvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__endvalue--background\">{{histogram?.histogramParams.endValue}}</span>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"chartType === ChartType.swimlane\">\n    <div class=\"histogram__tooltip\" *ngIf=\"histogram?.histogramParams.swimlaneXTooltip.isShown && !histogram?.histogramParams.swimlaneXTooltip.isRightSide\"\n      [style.left.px]=\"histogram?.histogramParams.swimlaneXTooltip.xPosition\"   [style.bottom.px]=\"30\">\n      <span class=\"histogram__swimlane--tooltip-xcontent\">{{histogram?.histogramParams.swimlaneXTooltip.xContent}}</span>\n    </div>\n    <div class=\"histogram__tooltip\" *ngIf=\"histogram?.histogramParams.swimlaneXTooltip.isShown && histogram?.histogramParams.swimlaneXTooltip.isRightSide\"\n      [style.right.px]=\"histogram?.histogramParams.swimlaneXTooltip.xPosition\"   [style.bottom.px]=\"30\">\n      <span class=\"histogram__swimlane--tooltip-xcontent\">{{histogram?.histogramParams.swimlaneXTooltip.xContent}}</span>\n    </div>\n    <div *ngFor=\"let tooltip of histogram?.histogramParams.swimlaneTooltipsMap | keyvalue\">\n      <div class=\"histogram__tooltip\" *ngIf=\"tooltip.value.isShown && !tooltip.value.isRightSide && tooltip.value.yContent\"\n        [style.left.px]=\"tooltip.value.xPosition\" [style.top.px]=\"tooltip.value.yPosition\">\n        <span class=\"histogram__swimlane--tooltip-content\">{{tooltip.value.yContent}}</span>\n        <span class=\"histogram__swimlane--tooltip-additional_info\">{{tooltip.value.yAdditonalInfo}}</span>\n      </div>\n      <div class=\"histogram__tooltip\" *ngIf=\"tooltip.value.isShown && tooltip.value.isRightSide && tooltip.value.yContent\"\n        [style.right.px]=\"tooltip.value.xPosition\"  [style.top.px]=\"tooltip.value.yPosition\">\n        <span class=\"histogram__swimlane--tooltip-content\">{{tooltip.value.yContent}}</span>\n        <span class=\"histogram__swimlane--tooltip-additional_info\">{{tooltip.value.yAdditonalInfo}}</span>\n      </div>\n    </div>\n  </div>\n\n  <div *ngFor=\"let id of histogram?.histogramParams.selectionListIntervalId\" class=\"histogram__remove\" (click)=\"removeSelectInterval(id)\" [style.top.px]=\"histogram?.histogramParams.topOffsetRemoveInterval\"\n    [style.left.px]=\"histogram?.histogramParams.intervalSelectedMap.get(id)?.x_position\" matTooltip=\"{{'Remove this selection' | translate}}\" matTooltipPosition=\"above\">\n    <svg fill=\"#fff\" height=\"24\" viewBox=\"0 0 24 24\"\n      width=\"24\" xmlns=\"http://www.w3.org/2000/svg\" transform=\"rotate(45)\">\n      <path  d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z\" />\n      <path fill=\"#555\" d=\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n    </svg>\n  </div>\n  <div *ngIf=\"chartType === ChartType.swimlane\">\n    <div>\n      <div class=\"swimlane_legend\">\n        <div [style.width.px]=\"histogram?.histogramParams.chartWidth * 0.3 / 10\" class=\"swimlane_legend_color\" *ngFor=\"let b of histogram?.histogramParams.legend\" [style.background-color]=\"b.color\"></div>\n      </div>\n      <div class=\"swimlane_legend\">\n        <div [style.width.px]=\"histogram?.histogramParams.chartWidth * 0.3 / 10\" class=\"swimlane_legend_value\" *ngFor=\"let b of histogram?.histogramParams.legend; index as i\" >{{b.key}}</div>\n      </div>\n    </div>\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.histogram{background:#00f0;width:100%;height:100%;position:relative}.histogram text{font-size:.8em;fill-opacity:1}.histogram__description{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.9em;line-height:1.3;color:#555;opacity:1;z-index:10000}.histogram__description--display{display:flex}.histogram__description__title{font-family:Roboto,Helvetica Neue,sans-serif;font-size:1em;flex:1 1 100%;max-width:40%;color:#555;opacity:1;text-align:center;z-index:8000}.histogram__description__startvalue{flex:1 1 100%;max-width:30%}.histogram__description__endvalue{flex:1 1 100%;max-width:30%;text-align:right}.histogram__ticks,.histogram__axis{stroke:#757575;stroke-width:1px}.tick text{fill:#757575;font-size:.9em}.histogram__no-chart__key,.histogram__no-chart__value{display:block;text-align:center;padding:1px}.histogram__tooltip{position:absolute;text-align:left;padding:4px;font:12px sans-serif;background:#fff;border:0px;border-radius:1px;pointer-events:none;color:#555;z-index:20000;min-width:100px;box-shadow:0 2px 2px -1px #0003,0 2px 2px #00000024,0 1px 3px #0000001f}.selected_bars_zone{fill:#b7b7b7;fill-opacity:.1}.histogram__brush-tooltip{font:.7em sans-serif;text-align:center;position:absolute;padding:2px;background:#fff;pointer-events:none;color:#000;z-index:20000}.histogram__brush-tooltip__horizontal--left,.histogram__brush-tooltip__horizontal--right,.histogram__brush-tooltip__vertical--left,.histogram__brush-tooltip__vertical--right{background-color:#fff;border-radius:2px}.histogram__brush-tooltip__vertical--left__rotation{transform:rotate(-90deg) translateY(-100%);transform-origin:top right}.histogram__brush-tooltip__vertical--right__rotation{transform:rotate(90deg) translateY(-100%);transform-origin:top left}.histogram__remove{position:absolute;text-align:left;padding:2px;font:12px sans-serif;border:0px;border-radius:2px;color:#043b53;z-index:20000;cursor:pointer}.histogram__tooltip-xcontent-wrapper{display:flex;flex-direction:row;justify-content:space-between;border-bottom:.4px solid #b7b7b7;padding-bottom:5px;color:#222}.histogram__tooltip-ycontent-wrapper{display:flex;flex-direction:row;justify-content:space-between;padding-top:5px;color:#555}.histogram__tooltip-content{display:block}.histogram__tooltip-xcontent{font-size:1.1em}.histogram__tooltip-xlabel{font-size:1.1em;font-weight:700;padding-right:5px}.histogram__tooltip-ylabel{font-weight:700;padding-right:5px}.histogram__ticks-axis text{display:none}.histogram__horizontal-axis__text{display:none}.histogram__horizontal-axis__line{stroke-opacity:.5;stroke-width:.3px;stroke-dasharray:5}.histogram__horizontal-axis{stroke-opacity:0}.histogram__only-axis text{display:none}.histogram__ticks-axis line{stroke:#b3b1b1}.histogram__line-separator text{display:none}.histogram__line-separator .domain{stroke:#b3b1b1}.histogram__ticks-axis__hidden{display:none}.histogram__labels-axis .domain{stroke-opacity:0}.histogram__labels-axis__hidden{display:none}.histogram__only-axis .line,.histogram__only-axis-right .line{stroke:#bdbdbd;stroke-width:1px}.brush .selection{opacity:.1}.slider-brush .selection{opacity:0}.histogram__brush--handles{stroke:#868686;fill:#868686;opacity:1;z-index:30000}.histogram__area_circle{fill:#7fa5a1;stroke:#7fa5a1}.histogram__tooltip_cursor_rect{fill:#bbb;stroke:#bbb;opacity:.5}.histogram__tooltip_cursor_line{fill:#bbb;stroke:#bbb}.swimlane_legend_color,.swimlane_legend_value{display:inline-block;font-size:.7em}.swimlane_legend_color{height:8px}.swimlane_legend{display:flex;justify-content:center}.histogram__chart--fixed-selected--area,.histogram__chart--current-selected--area{fill:#88c9c3;fill-opacity:1}.histogram__chart--unselected--area{fill:#b7b7b7;fill-opacity:.7}.histogram__chart--fixed-selected--curve{fill:none;stroke:#88c9c3}.histogram__chart--fixed-selected--curve--without_color{fill:none}.histogram__chart--current-selected--curve{fill:none;stroke:#88c9c3}.histogram__chart--current-selected--curve--without_color{fill:none}.histogram__chart--unselected--curve{fill:none;stroke:#a5a5a5;stroke-width:.8px}.histogram__ticks-axis-right text{display:none}.stroke_canceller{stroke:unset}.histogram__chart--bar__fullyselected,.histogram__chart--bar__currentselection,.histogram__chart--bar__partlyselected{fill:#fff;stroke:#a5a5a5;stroke-width:.4px}.histogram__chart--bar{fill:#fff;stroke:#b7b7b7;stroke-width:.4px}.histogram__swimlane--vertical-tooltip-line{stroke-width:1px;stroke:#252525;fill:none}.headband_currentselection{fill:#88c9c3!important;stroke:#88c9c3!important;stroke-width:.4px!important;height:1.5px!important}.headband_currentselection_min,.headband_currentselection_max{fill:#e62938!important;stroke:#e62938!important;stroke-width:.4px!important;height:1.5px!important}.headband_partlyselected,.headband_fullyselected{fill:#88c9c3!important;stroke:#88c9c3!important;stroke-width:.4px!important;height:1.5px!important}.headband_notselected{fill:#fff!important;stroke:#b7b7b7!important;stroke-width:0!important;height:0!important}.swimlane-label-unselected{fill:gray}.swimlane-label-selected{fill:#ff4081}.swimlane-label-neutral{fill:#000}.swimlane-label-container-hovered{fill:#efefef}.selection{opacity:.6}\n"], dependencies: [{ kind: "directive", type: i2$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "pipe", type: i2$1.KeyValuePipe, name: "keyvalue" }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }, { kind: "pipe", type: GetCollectionUnitPipe, name: "getCollectionUnit" }, { kind: "pipe", type: HistogramKeyPipe, name: "histogramKey" }], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: HistogramComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-histogram', encapsulation: ViewEncapsulation.None, template: "<div id=\"{{id}}\" class=\"histogram\" [ngClass]=\"customizedCssClass\">\n  <div *ngIf=\"descriptionPosition === Position.top\" class=\"histogram__description\" [style.width.px]=\"histogram?.histogramParams.chartWidth-histogram?.histogramParams.margin.left-histogram?.histogramParams.margin.right\"\n    [style.margin-left.px]=\"histogram?.histogramParams.margin.left\" [style.margin-right.px]=\"histogram?.histogramParams.margin.right\">\n    <div class=\"histogram__description--display\">\n      <div class=\"histogram__description__startvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__startvalue--background\">{{histogram?.histogramParams.startValue}}</span>\n      </div>\n      <div class=\"histogram__description__title\">\n        <span *ngIf=\"histogram?.histogramParams.showTitle\">{{histogram?.histogramParams.chartTitle}}</span>\n      </div>\n      <div class=\"histogram__description__endvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__endvalue--background\">{{histogram?.histogramParams.endValue}}</span>\n      </div>\n    </div>\n  </div>\n  <div [style.display]=\"histogram?.histogramParams.displaySvg\" style=\"position:relative\">\n    <svg id=\"svgix\" class=\"histogram__chart\" [style.width.px]=\"histogram?.histogramParams.chartWidth\" [style.height.px]=\"histogram?.histogramParams.chartHeight\"></svg>\n    <div *ngIf=\"chart?.brush?.isBrushing\">\n      <div #left [style.visibility]=\"histogram?.brushCornerTooltips.horizontalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__horizontal--left\"\n        [style.left.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.yPosition\">\n        {{histogram?.brushCornerTooltips.leftCornerTooltip.content}}\n      </div>\n      <div #right [style.visibility]=\"histogram?.brushCornerTooltips.horizontalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__horizontal--right\"\n        [style.right.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.yPosition\">\n        {{histogram?.brushCornerTooltips.rightCornerTooltip.content}}\n      </div>\n\n      <div #leftvertical [style.visibility]=\"histogram?.brushCornerTooltips.verticalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__vertical--left__rotation histogram__brush-tooltip__vertical--left\"\n        [style.left.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.yPosition\" [style.width.px]=\"histogram?.brushCornerTooltips.leftCornerTooltip.width\">\n        {{histogram?.brushCornerTooltips.leftCornerTooltip.content}}\n      </div>\n      <div #rightvertical [style.visibility]=\"histogram?.brushCornerTooltips.verticalCssVisibility\" class=\"histogram__brush-tooltip histogram__brush-tooltip__vertical--right__rotation histogram__brush-tooltip__vertical--right\"\n        [style.left.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.xPosition\"   [style.top.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.yPosition\" [style.width.px]=\"histogram?.brushCornerTooltips.rightCornerTooltip.width\">\n        {{histogram?.brushCornerTooltips.rightCornerTooltip.content}}\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"histogram?.histogramParams.dataLength === 1\" class=\"histogram__no-chart\" [style.width.px]=\"histogram?.histogramParams.chartWidth\" [style.height.px]=\"histogram?.histogramParams.chartHeight\">\n    <span class=\"histogram__no-chart__key\">{{chartXLabel | translate}} {{data[0].key | histogramKey : histogram?.histogramParams }} {{xUnit | translate}}</span>\n    <div *ngFor=\"let d of data\">\n      <span class=\"histogram__no-chart__value\">{{histogram?.histogramParams.chartTitle | translate}} {{d.value}}  {{ ((yUnit && yUnit.length > 0) ? yUnit : d.chartId | getCollectionUnit) | translate }}</span>\n    </div>\n  </div>\n  <div *ngIf=\"descriptionPosition === Position.bottom\" class=\"histogram__description\" [style.width.px]=\"histogram?.histogramParams.chartWidth-histogram?.histogramParams.margin.left-histogram?.histogramParams.margin.right\"\n    [style.margin-left.px]=\"histogram?.histogramParams.margin.left\" [style.margin-right.px]=\"histogram?.histogramParams.margin.right\">\n    <div class=\"histogram__description--display\">\n      <div class=\"histogram__description__startvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__startvalue--background\">{{histogram?.histogramParams.startValue}}</span>\n      </div>\n      <div class=\"histogram__description__title\">\n        <span *ngIf=\"histogram?.histogramParams.showTitle\">{{histogram?.histogramParams.chartTitle}}</span>\n      </div>\n      <div class=\"histogram__description__endvalue\">\n        <span *ngIf=\"histogram?.histogramParams.dataLength > 1\" class=\"histogram__description__endvalue--background\">{{histogram?.histogramParams.endValue}}</span>\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"chartType === ChartType.swimlane\">\n    <div class=\"histogram__tooltip\" *ngIf=\"histogram?.histogramParams.swimlaneXTooltip.isShown && !histogram?.histogramParams.swimlaneXTooltip.isRightSide\"\n      [style.left.px]=\"histogram?.histogramParams.swimlaneXTooltip.xPosition\"   [style.bottom.px]=\"30\">\n      <span class=\"histogram__swimlane--tooltip-xcontent\">{{histogram?.histogramParams.swimlaneXTooltip.xContent}}</span>\n    </div>\n    <div class=\"histogram__tooltip\" *ngIf=\"histogram?.histogramParams.swimlaneXTooltip.isShown && histogram?.histogramParams.swimlaneXTooltip.isRightSide\"\n      [style.right.px]=\"histogram?.histogramParams.swimlaneXTooltip.xPosition\"   [style.bottom.px]=\"30\">\n      <span class=\"histogram__swimlane--tooltip-xcontent\">{{histogram?.histogramParams.swimlaneXTooltip.xContent}}</span>\n    </div>\n    <div *ngFor=\"let tooltip of histogram?.histogramParams.swimlaneTooltipsMap | keyvalue\">\n      <div class=\"histogram__tooltip\" *ngIf=\"tooltip.value.isShown && !tooltip.value.isRightSide && tooltip.value.yContent\"\n        [style.left.px]=\"tooltip.value.xPosition\" [style.top.px]=\"tooltip.value.yPosition\">\n        <span class=\"histogram__swimlane--tooltip-content\">{{tooltip.value.yContent}}</span>\n        <span class=\"histogram__swimlane--tooltip-additional_info\">{{tooltip.value.yAdditonalInfo}}</span>\n      </div>\n      <div class=\"histogram__tooltip\" *ngIf=\"tooltip.value.isShown && tooltip.value.isRightSide && tooltip.value.yContent\"\n        [style.right.px]=\"tooltip.value.xPosition\"  [style.top.px]=\"tooltip.value.yPosition\">\n        <span class=\"histogram__swimlane--tooltip-content\">{{tooltip.value.yContent}}</span>\n        <span class=\"histogram__swimlane--tooltip-additional_info\">{{tooltip.value.yAdditonalInfo}}</span>\n      </div>\n    </div>\n  </div>\n\n  <div *ngFor=\"let id of histogram?.histogramParams.selectionListIntervalId\" class=\"histogram__remove\" (click)=\"removeSelectInterval(id)\" [style.top.px]=\"histogram?.histogramParams.topOffsetRemoveInterval\"\n    [style.left.px]=\"histogram?.histogramParams.intervalSelectedMap.get(id)?.x_position\" matTooltip=\"{{'Remove this selection' | translate}}\" matTooltipPosition=\"above\">\n    <svg fill=\"#fff\" height=\"24\" viewBox=\"0 0 24 24\"\n      width=\"24\" xmlns=\"http://www.w3.org/2000/svg\" transform=\"rotate(45)\">\n      <path  d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z\" />\n      <path fill=\"#555\" d=\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n    </svg>\n  </div>\n  <div *ngIf=\"chartType === ChartType.swimlane\">\n    <div>\n      <div class=\"swimlane_legend\">\n        <div [style.width.px]=\"histogram?.histogramParams.chartWidth * 0.3 / 10\" class=\"swimlane_legend_color\" *ngFor=\"let b of histogram?.histogramParams.legend\" [style.background-color]=\"b.color\"></div>\n      </div>\n      <div class=\"swimlane_legend\">\n        <div [style.width.px]=\"histogram?.histogramParams.chartWidth * 0.3 / 10\" class=\"swimlane_legend_value\" *ngFor=\"let b of histogram?.histogramParams.legend; index as i\" >{{b.key}}</div>\n      </div>\n    </div>\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.histogram{background:#00f0;width:100%;height:100%;position:relative}.histogram text{font-size:.8em;fill-opacity:1}.histogram__description{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.9em;line-height:1.3;color:#555;opacity:1;z-index:10000}.histogram__description--display{display:flex}.histogram__description__title{font-family:Roboto,Helvetica Neue,sans-serif;font-size:1em;flex:1 1 100%;max-width:40%;color:#555;opacity:1;text-align:center;z-index:8000}.histogram__description__startvalue{flex:1 1 100%;max-width:30%}.histogram__description__endvalue{flex:1 1 100%;max-width:30%;text-align:right}.histogram__ticks,.histogram__axis{stroke:#757575;stroke-width:1px}.tick text{fill:#757575;font-size:.9em}.histogram__no-chart__key,.histogram__no-chart__value{display:block;text-align:center;padding:1px}.histogram__tooltip{position:absolute;text-align:left;padding:4px;font:12px sans-serif;background:#fff;border:0px;border-radius:1px;pointer-events:none;color:#555;z-index:20000;min-width:100px;box-shadow:0 2px 2px -1px #0003,0 2px 2px #00000024,0 1px 3px #0000001f}.selected_bars_zone{fill:#b7b7b7;fill-opacity:.1}.histogram__brush-tooltip{font:.7em sans-serif;text-align:center;position:absolute;padding:2px;background:#fff;pointer-events:none;color:#000;z-index:20000}.histogram__brush-tooltip__horizontal--left,.histogram__brush-tooltip__horizontal--right,.histogram__brush-tooltip__vertical--left,.histogram__brush-tooltip__vertical--right{background-color:#fff;border-radius:2px}.histogram__brush-tooltip__vertical--left__rotation{transform:rotate(-90deg) translateY(-100%);transform-origin:top right}.histogram__brush-tooltip__vertical--right__rotation{transform:rotate(90deg) translateY(-100%);transform-origin:top left}.histogram__remove{position:absolute;text-align:left;padding:2px;font:12px sans-serif;border:0px;border-radius:2px;color:#043b53;z-index:20000;cursor:pointer}.histogram__tooltip-xcontent-wrapper{display:flex;flex-direction:row;justify-content:space-between;border-bottom:.4px solid #b7b7b7;padding-bottom:5px;color:#222}.histogram__tooltip-ycontent-wrapper{display:flex;flex-direction:row;justify-content:space-between;padding-top:5px;color:#555}.histogram__tooltip-content{display:block}.histogram__tooltip-xcontent{font-size:1.1em}.histogram__tooltip-xlabel{font-size:1.1em;font-weight:700;padding-right:5px}.histogram__tooltip-ylabel{font-weight:700;padding-right:5px}.histogram__ticks-axis text{display:none}.histogram__horizontal-axis__text{display:none}.histogram__horizontal-axis__line{stroke-opacity:.5;stroke-width:.3px;stroke-dasharray:5}.histogram__horizontal-axis{stroke-opacity:0}.histogram__only-axis text{display:none}.histogram__ticks-axis line{stroke:#b3b1b1}.histogram__line-separator text{display:none}.histogram__line-separator .domain{stroke:#b3b1b1}.histogram__ticks-axis__hidden{display:none}.histogram__labels-axis .domain{stroke-opacity:0}.histogram__labels-axis__hidden{display:none}.histogram__only-axis .line,.histogram__only-axis-right .line{stroke:#bdbdbd;stroke-width:1px}.brush .selection{opacity:.1}.slider-brush .selection{opacity:0}.histogram__brush--handles{stroke:#868686;fill:#868686;opacity:1;z-index:30000}.histogram__area_circle{fill:#7fa5a1;stroke:#7fa5a1}.histogram__tooltip_cursor_rect{fill:#bbb;stroke:#bbb;opacity:.5}.histogram__tooltip_cursor_line{fill:#bbb;stroke:#bbb}.swimlane_legend_color,.swimlane_legend_value{display:inline-block;font-size:.7em}.swimlane_legend_color{height:8px}.swimlane_legend{display:flex;justify-content:center}.histogram__chart--fixed-selected--area,.histogram__chart--current-selected--area{fill:#88c9c3;fill-opacity:1}.histogram__chart--unselected--area{fill:#b7b7b7;fill-opacity:.7}.histogram__chart--fixed-selected--curve{fill:none;stroke:#88c9c3}.histogram__chart--fixed-selected--curve--without_color{fill:none}.histogram__chart--current-selected--curve{fill:none;stroke:#88c9c3}.histogram__chart--current-selected--curve--without_color{fill:none}.histogram__chart--unselected--curve{fill:none;stroke:#a5a5a5;stroke-width:.8px}.histogram__ticks-axis-right text{display:none}.stroke_canceller{stroke:unset}.histogram__chart--bar__fullyselected,.histogram__chart--bar__currentselection,.histogram__chart--bar__partlyselected{fill:#fff;stroke:#a5a5a5;stroke-width:.4px}.histogram__chart--bar{fill:#fff;stroke:#b7b7b7;stroke-width:.4px}.histogram__swimlane--vertical-tooltip-line{stroke-width:1px;stroke:#252525;fill:none}.headband_currentselection{fill:#88c9c3!important;stroke:#88c9c3!important;stroke-width:.4px!important;height:1.5px!important}.headband_currentselection_min,.headband_currentselection_max{fill:#e62938!important;stroke:#e62938!important;stroke-width:.4px!important;height:1.5px!important}.headband_partlyselected,.headband_fullyselected{fill:#88c9c3!important;stroke:#88c9c3!important;stroke-width:.4px!important;height:1.5px!important}.headband_notselected{fill:#fff!important;stroke:#b7b7b7!important;stroke-width:0!important;height:0!important}.swimlane-label-unselected{fill:gray}.swimlane-label-selected{fill:#ff4081}.swimlane-label-neutral{fill:#000}.swimlane-label-container-hovered{fill:#efefef}.selection{opacity:.6}\n"] }]
        }], ctorParameters: () => [{ type: ArlasColorService }, { type: i0.ElementRef }, { type: i2.TranslateService }], propDecorators: { lt: [{
                type: ViewChild,
                args: ['left', { read: ElementRef, static: false }]
            }], rt: [{
                type: ViewChild,
                args: ['right', { read: ElementRef, static: false }]
            }], data: [{
                type: Input
            }], mainChartId: [{
                type: Input
            }], dataType: [{
                type: Input
            }], dataUnit: [{
                type: Input
            }], xUnit: [{
                type: Input
            }], yUnit: [{
                type: Input
            }], valuesDateFormat: [{
                type: Input
            }], isHistogramSelectable: [{
                type: Input
            }], multiselectable: [{
                type: Input
            }], intervalSelection: [{
                type: Input
            }], intervalListSelection: [{
                type: Input
            }], topOffsetRemoveInterval: [{
                type: Input
            }], leftOffsetRemoveInterval: [{
                type: Input
            }], brushHandlesHeightWeight: [{
                type: Input
            }], handlesRadius: [{
                type: Input
            }], selectionType: [{
                type: Input
            }], chartType: [{
                type: Input
            }], chartTitle: [{
                type: Input
            }], chartXLabel: [{
                type: Input
            }], chartYLabel: [{
                type: Input
            }], chartWidth: [{
                type: Input
            }], chartHeight: [{
                type: Input
            }], customizedCssClass: [{
                type: Input
            }], yAxisStartsFromZero: [{
                type: Input
            }], showStripes: [{
                type: Input
            }], xAxisPosition: [{
                type: Input
            }], descriptionPosition: [{
                type: Input
            }], xTicks: [{
                type: Input
            }], yTicks: [{
                type: Input
            }], xLabels: [{
                type: Input
            }], yLabels: [{
                type: Input
            }], shortYLabels: [{
                type: Input
            }], showXTicks: [{
                type: Input
            }], showYTicks: [{
                type: Input
            }], showXLabels: [{
                type: Input
            }], showYLabels: [{
                type: Input
            }], showHorizontalLines: [{
                type: Input
            }], ticksDateFormat: [{
                type: Input
            }], isSmoothedCurve: [{
                type: Input
            }], barWeight: [{
                type: Input
            }], paletteColors: [{
                type: Input
            }], displayOnlyIntervalsWithData: [{
                type: Input
            }], applyOffsetOnAreaChart: [{
                type: Input
            }], swimlaneMode: [{
                type: Input
            }], swimlaneRepresentation: [{
                type: Input
            }], swimlaneOptions: [{
                type: Input
            }], swimLaneLabelsWidth: [{
                type: Input
            }], swimlaneBorderRadius: [{
                type: Input
            }], swimlaneHeight: [{
                type: Input
            }], id: [{
                type: Input
            }], selectedSwimlanes: [{
                type: Input
            }], useUtc: [{
                type: Input
            }], selectedSwimlanesEvent: [{
                type: Output
            }], valuesListChangedEvent: [{
                type: Output
            }], hoveredBucketEvent: [{
                type: Output
            }], dataPlottedEvent: [{
                type: Output
            }], tooltipEvent: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetCollectionUnitModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionUnitModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionUnitModule, declarations: [GetCollectionUnitPipe], exports: [GetCollectionUnitPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionUnitModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionUnitModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [
                        GetCollectionUnitPipe
                    ],
                    exports: [
                        GetCollectionUnitPipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class HistogramModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: HistogramModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: HistogramModule, declarations: [HistogramComponent, HistogramKeyPipe], imports: [CommonModule,
            TranslateModule,
            MatTooltipModule,
            GetCollectionUnitModule], exports: [HistogramComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: HistogramModule, imports: [CommonModule,
            TranslateModule,
            MatTooltipModule,
            GetCollectionUnitModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: HistogramModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        TranslateModule,
                        MatTooltipModule,
                        GetCollectionUnitModule
                    ],
                    declarations: [HistogramComponent, HistogramKeyPipe],
                    exports: [HistogramComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class PowerBar {
    constructor(term, parentTerm, count) {
        /**
         * @description Whether the powerbar is selected.
         */
        this.isSelected = false;
        /**
         * @description class name to apply to the powerbar : `neutral-state`, `selected-bar` or `unselected-bar`.
         */
        this.classSuffix = 'neutral-state';
        this.term = term;
        this.parentTerm = parentTerm;
        this.count = count;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var PageEnum;
(function (PageEnum) {
    PageEnum["next"] = "next";
    PageEnum["previous"] = "previous";
})(PageEnum || (PageEnum = {}));

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var ThumbnailFitEnum;
(function (ThumbnailFitEnum) {
    ThumbnailFitEnum["height"] = "height";
    ThumbnailFitEnum["width"] = "width";
    ThumbnailFitEnum["contain"] = "contain";
})(ThumbnailFitEnum || (ThumbnailFitEnum = {}));

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var CellBackgroundStyleEnum;
(function (CellBackgroundStyleEnum) {
    CellBackgroundStyleEnum["filled"] = "filled";
    CellBackgroundStyleEnum["outlined"] = "outlined";
})(CellBackgroundStyleEnum || (CellBackgroundStyleEnum = {}));

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * Enables customize the resultlist options/behaviours
 */
class ResultListOptions {
    constructor() {
        this.showActionsOnhover = false;
        this.showDetailIconName = 'add_circle_outline';
        this.hideDetailIconName = 'remove_circle_outline';
        this.defautlImgUrl = './assets/no-view.png';
    }
}
/** A utility class to handle the action's states  */
class ActionHandler {
    /** An action is reversible simply when a reverse action is declared. */
    static isReversible(a) {
        return !!a && !!a.reverseAction;
    }
    static activate(a) {
        a.activated = true;
    }
    static reverse(a) {
        a.activated = false;
    }
}
const PROTECTED_IMAGE_HEADER = 'Protected-Image-Header';
/**
 * @param data A dictionnary of data to retrieve information
 * @param template The template of the desired string. Contains variable keys between brackets
 * @returns A string with the regex replaced by the data
 */
function matchAndReplace(data, template) {
    let replaced = template;
    template.match(/{(.+?)}/g)?.forEach(t => {
        const key = t.replace('{', '').replace('}', '');
        if (!!data.get(key)) {
            replaced = replaced.replace(t, data.get(key).toString());
        }
    });
    return replaced;
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
;
class Item {
    constructor(columns, itemData) {
        /**
         * @description More data organized in groups.
         */
        this.itemDetailedData = new Array();
        /**
         * @description Whether to display the detailed data.
         */
        this.isDetailToggled = false;
        /**
         * @description Whether the item is checked.
         */
        this.isChecked = false;
        /**
         * @description Whether the item state is indeterminated.
         */
        this.isindeterminated = false;
        /**
         * @description Whether to highlight the item.
         */
        this.ishighLight = undefined;
        this.columns = columns;
        this.itemData = itemData;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var SortEnum;
(function (SortEnum) {
    SortEnum[SortEnum["asc"] = 0] = "asc";
    SortEnum[SortEnum["desc"] = 1] = "desc";
    SortEnum[SortEnum["none"] = 2] = "none";
})(SortEnum || (SortEnum = {}));

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class Column {
    constructor(columnName, fieldName, dataType) {
        /**
         * @description Sort direction to apply to th column : ascending, descending or none
         */
        this.sortDirection = SortEnum.none;
        /**
         * @description Whether this column represents an id field.
         */
        this.isIdField = false;
        /**
         * @description Whether the cells of this column contains a toggle button.
         */
        this.isToggleField = false;
        /**
         * @description Whether the filter search column has a dropdown.
         */
        this.dropdown = false;
        /**
         * @description Size of the dropdown list.
         */
        this.dropdownsize = 10;
        /**
         * @description Whether to allow colorizing cells that are within this column
         */
        this.useColorService = false;
        this.columnName = columnName;
        this.fieldName = fieldName;
        this.dataType = dataType;
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var ModeEnum;
(function (ModeEnum) {
    ModeEnum[ModeEnum["list"] = 0] = "list";
    ModeEnum[ModeEnum["grid"] = 1] = "grid";
})(ModeEnum || (ModeEnum = {}));

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultlistNotifierService {
    constructor() {
        this.itemHoveredSource = new Subject();
        this.itemHovered$ = this.itemHoveredSource.asObservable();
    }
    notifyItemHover(item) {
        this.itemHoveredSource.next(item);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultlistNotifierService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultlistNotifierService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultlistNotifierService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ItemComponent {
    setSelectedItem(isChecked, identifier, selectedItems) {
        isChecked = !isChecked;
        if (isChecked) {
            if (!selectedItems.has(identifier)) {
                selectedItems.add(identifier);
            }
        }
        else {
            if (selectedItems.has(identifier)) {
                selectedItems.delete(identifier);
            }
        }
    }
    retrieveAdditionalInfo(detailedDataRetriever, item) {
        if (detailedDataRetriever !== null && item.itemDetailedData.length === 0) {
            this.retrievedDataEvent = detailedDataRetriever.getData(((String)(item.identifier)));
            this.retrievedDataEvent.subscribe(additionalInfo => {
                item.actions = new Array();
                additionalInfo.actions.forEach(action => {
                    item.actions.push({
                        id: action.id,
                        label: action.label,
                        actionBus: action.actionBus,
                        cssClass: action.cssClass,
                        tooltip: action.tooltip,
                        reverseAction: action.reverseAction,
                        icon: action.icon,
                        fields: action.fields,
                        show: action.show
                    });
                });
                additionalInfo.details.forEach((v, k) => {
                    const details = new Array();
                    v.forEach((value, key) => details.push({ key: key, value: value }));
                    item.itemDetailedData.push({ group: k, details: details });
                });
                if (additionalInfo.attachments) {
                    item.attachments = new Array();
                    additionalInfo.attachments.forEach(attachment => {
                        item.attachments.push({
                            label: attachment.label,
                            url: attachment.url,
                            type: attachment.type,
                            description: attachment.description,
                            icon: attachment.icon
                        });
                    });
                }
            });
        }
    }
}

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ActionDisplayerPipe {
    /**
     * @param a Action
     * @param displayElement Part of the action displayed in the template
     * @returns According to the action's state, returns the right displayElement.
     */
    transform(a, displayElement) {
        /** Note that if an action has been activated, we display the elements of the reverse action ! */
        /** For example if the action of 'visualize' on map is activated, we display the reverse action 'Remove from map'. */
        switch (displayElement) {
            case 'label':
                return ActionHandler.isReversible(a) ?
                    (a.activated ? a.reverseAction?.label : a.label) :
                    a.label;
            case 'tooltip':
                return ActionHandler.isReversible(a) ?
                    (a.activated ? a.reverseAction?.tooltip : a.tooltip) :
                    a.tooltip;
            case 'id':
                return ActionHandler.isReversible(a) ?
                    (a.activated ? a.reverseAction?.id : a.id) :
                    a.id;
            case 'icon':
                return ActionHandler.isReversible(a) ?
                    (a.activated ? a.reverseAction?.icon : a.icon) :
                    a.icon;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ActionDisplayerPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ActionDisplayerPipe, name: "actionDisplayer" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ActionDisplayerPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'actionDisplayer'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * This component displays actions of an item.
 * - Actions are only displayed when we hover an item.
 * BUT
 * An action can be reversible. It means that this action has a reverse action.
 * - An example of reversible action:  Action => Add layer to map --///--  Reverse Action => Remove layer from map.
 * - When you click on a reversible action for the first time, the action become 'activated'.
 * - Activated actions should be displayed all the time on the resultlist (in list and grid view).
 * - When you click on an 'activated' action, the action is reversed and goes back to its initial state.
 * - Actions that are not activated are only displayed when we hover an item.
 * ALSO
 * When a reversible action has `fields` attribute. It means that this action needs the existence of the fields values in order to be executed.
 * - If one of the fields values is absent in the current item, the action will be hidden.
 */
class ResultActionsComponent {
    constructor(notifier) {
        this.notifier = notifier;
        /** Map <itemId, Set<actionIds>> : for each item, gives the list of activated actions. */
        this.activatedActionsPerItem = new Map();
        /** This data retriever allows to fetch the actions of each items + check if an action should be hidden. */
        this.detailedDataRetriever = null;
        /** Whether to stop propagation at click/hover of the action. */
        this.stopPropagation = false;
        /** Whether to display the actions as icon buttons or text buttons. */
        this.mode = 'icon';
        /** Emits an event when the action is clicked on it. */
        this.actionOnItemEvent = new Subject();
        /** Destroy subscriptions. */
        this._onDestroy$ = new Subject();
        /** When an Item is hovered: */
        this.notifier.itemHovered$.pipe(takeUntil$1(this._onDestroy$)).pipe(filter((i) => i.identifier === this.item.identifier)).subscribe({
            next: (i) => {
                /** Always show non reversible actions. */
                this.actions.filter(a => !ActionHandler.isReversible(a)).forEach(a => a.show = true);
                /** We check if reversible actions has 'fields'.
                 * - If one of the fields values is absent in the current item, the action will be hidden. */
                this.actions.filter(a => ActionHandler.isReversible(a) && a.fields && a.show === undefined).forEach(a => {
                    this.detailedDataRetriever.getValues(i.identifier, a.fields).pipe(take(1)).subscribe({
                        next: (values) => a.show = values.filter(v => !v).length === 0
                    });
                });
            }
        });
    }
    ngOnInit() {
        this.setItemActions(this.item);
    }
    ngOnChanges(changes) {
        if (changes.activatedActionsPerItem) {
            this.updateActions();
        }
    }
    /**
     * An action can be reversible. It means that this action has a reverse action.
     * - When you click on a reversible action for the first time, the action become 'activated'.
     * - Activated actions should be displayed all the time on the resultlist (in list and grid view).
     * - When you click on an 'activated' action, the action is reversed and goes back to its initial state.
     */
    triggerAction(event, action) {
        if (this.stopPropagation) {
            event.stopPropagation();
        }
        this.actionOnItemEvent.next(action);
        /** activate */
        if (ActionHandler.isReversible(action) && !action.activated) {
            ActionHandler.activate(action);
        }
        else if (ActionHandler.isReversible(action) && action.activated) {
            ActionHandler.reverse(action);
        }
        /** Retrigger the pipe ActionDisplayerPipe */
        this.actions = [...this.actions];
    }
    /**
     * An action can be reversible. It means that this action has a reverse action.
     * - When you click on a reversible action for the first time, the action become 'activated'.
     * - Activated actions should be displayed all the time on the resultlist (in list and grid view).
     * - When you click on an 'activated' action, the action is reversed and goes back to its initial state.
     */
    updateActions() {
        if (this.activatedActionsPerItem) {
            const actionIds = this.activatedActionsPerItem.get(this.item.identifier);
            if (!!actionIds && !!this.actions) {
                this.actions.filter(a => ActionHandler.isReversible(a)).forEach(a => {
                    if (actionIds.has(a.id)) {
                        ActionHandler.activate(a);
                        /** Always show activated actions. */
                        a.show = true;
                    }
                    else {
                        ActionHandler.reverse(a);
                    }
                });
                /** Retrigger ActionDisplayerPipe */
                this.actions = [...this.actions];
            }
        }
    }
    /**
     * @description set the list of actions of an item
     * @param item
     */
    setItemActions(item) {
        if (item && (!item.actions || (item.actions && item.actions.length === 0))) {
            item.actions = new Array();
            this.detailedDataRetriever.getActions(item).pipe(take(1)).subscribe(actions => {
                actions.forEach(action => {
                    item.actions.push({
                        id: action.id,
                        label: action.label,
                        actionBus: action.actionBus,
                        cssClass: action.cssClass,
                        tooltip: action.tooltip,
                        reverseAction: action.reverseAction,
                        icon: action.icon,
                        fields: action.fields,
                        show: action.show
                    });
                });
                this.actions = item.actions;
                this.updateActions();
            });
        }
        else if (item && item.actions && item.actions.length > 0) {
            this.actions = item.actions;
            this.updateActions();
        }
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultActionsComponent, deps: [{ token: ResultlistNotifierService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ResultActionsComponent, selector: "arlas-result-actions", inputs: { item: "item", width: "width", activatedActionsPerItem: "activatedActionsPerItem", detailedDataRetriever: "detailedDataRetriever", stopPropagation: "stopPropagation", mode: "mode" }, outputs: { actionOnItemEvent: "actionOnItemEvent" }, usesOnChanges: true, ngImport: i0, template: "<!-- This sections is for actions that we display as icon buttons -->\n<div [style.max-width.px]=\"width\" class=\"list_actions\" *ngIf=\"mode === 'icon'; else textActions\">\n    <ng-container *ngFor=\"let action of actions\">\n        <ng-container *ngIf=\"action?.show === true\">\n            <!-- The action is activated, which means it will always be displayed.-->\n            <ng-container *ngIf=\"action?.activated\">\n                <!-- The button icon is provided by css 'background-url' attribute.-->\n                <button *ngIf=\"!action?.icon else active_icon\" (click)=\"triggerAction($event, action)\"\n                    matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\"\n                    class=\"resultitem-list__actions {{action.id}}-onhover-action {{action.cssClass}}-onhover-action\">\n                    {{action | actionDisplayer:'label' | translate}}\n                </button>\n                <ng-template #active_icon>\n                    <!-- The icon is provided by the action itself.-->\n                    <mat-icon (click)=\"triggerAction($event, action)\" class=\"icon\"\n                        matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                        {{action | actionDisplayer:'icon'}}\n                    </mat-icon>\n                </ng-template>\n            </ng-container>\n        </ng-container>\n    </ng-container>\n    <ng-container *ngFor=\"let action of actions\">\n        <ng-container *ngIf=\"action?.show === true\">\n            <!-- The action is not activated, which means it will appear only when an item is hovered.-->\n            <ng-container *ngIf=\"!action?.activated\">\n                <button *ngIf=\"!action?.icon else not_active_icon\" (click)=\"triggerAction($event, action)\"\n                    class=\"not_activated\" matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\"\n                    class=\"resultitem-list__actions {{action.id}}-onhover-action {{action.cssClass}}-onhover-action\">\n                    {{action | actionDisplayer:'label' | translate}}\n                </button>\n                <ng-template #not_active_icon>\n                    <mat-icon (click)=\"triggerAction($event, action)\" class=\"icon not_activated\"\n                        matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                        {{action | actionDisplayer:'icon'}}\n                    </mat-icon>\n                </ng-template>\n            </ng-container>\n        </ng-container>\n    </ng-container>\n\n</div>\n<!-- This sections is for actions that we display as text buttons instead of icon buttons-->\n<ng-template #textActions>\n    <ng-container *ngFor=\"let action of actions\">\n        <ng-container *ngIf=\"action?.show === true\">\n            <button mat-raised-button *ngIf=\"!action?.activated else activeButton\" class=\"text-action {{action.id}}-action {{action.cssClass}}-action\"\n                (click)=\"triggerAction($event, action)\" matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                {{action | actionDisplayer:'label' | translate}}\n            </button>\n            <ng-template #activeButton>\n                <button mat-raised-button *ngIf=\"action?.activated\" (click)=\"triggerAction($event, action)\"\n                    class=\"resultdetaileditem__actions text-action {{action.id}}-action {{action.cssClass}}-action\" matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                    {{action | actionDisplayer:'label' | translate}}\n                </button>\n            </ng-template>\n        </ng-container>\n    </ng-container>\n</ng-template>\n", styles: ["@charset \"UTF-8\";.resultitem-list__actions{min-width:0;border-radius:50%;border:none;padding:0;width:24px;height:24px;font-size:0;color:#fff;margin-left:5px;background-color:#fff;background-image:url(\"data:image/svg+xml,%3Csvg%20width%3D%2720%27%20height%3D%2720%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%20%3Cg%3E%20%20%3Ctitle%3Ebackground%3C%2Ftitle%3E%20%20%3Crect%20fill%3D%27%23fff%27%20id%3D%27canvas_background%27%20height%3D%2722%27%20width%3D%2722%27%20y%3D%27-1%27%20x%3D%27-1%27%2F%3E%20%20%3Cg%20display%3D%27none%27%20overflow%3D%27visible%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%20id%3D%27canvasGrid%27%3E%20%20%20%3Crect%20fill%3D%27url(%23gridpattern)%27%20stroke-width%3D%270%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%2F%3E%20%20%3C%2Fg%3E%20%3C%2Fg%3E%20%3Cg%3E%20%20%3Ctitle%3ELayer%201%3C%2Ftitle%3E%20%20%3Cellipse%20stroke%3D%27%23000000%27%20ry%3D%275.779194%27%20rx%3D%275.5%27%20id%3D%27svg_1%27%20cy%3D%2710.000004%27%20cx%3D%2710%27%20stroke-width%3D%272.5%27%20fill%3D%27%23ffffff%27%2F%3E%20%3C%2Fg%3E%3C%2Fsvg%3E\");background-repeat:no-repeat;background-position:center;float:right;cursor:pointer}.resultitem-list__actions:active{border:1px solid white}.list_actions{display:flex;flex-direction:row-reverse;align-items:center;position:absolute;right:0;top:0;height:100%;width:max-content}.list_actions .not_activated{display:none}.list_actions .icon{margin-left:5px;float:right;width:24px;height:24px;font-size:20px;text-align:center;align-content:space-evenly;background-color:#fff;border-radius:50%;cursor:pointer}.list_active_actions{display:flex;flex-direction:row-reverse;align-items:center;position:absolute;right:35px;top:0;height:100%;width:max-content}.text-action{font-family:Roboto,Helvetica Neue,sans-serif;font-size:11px;margin:3px;padding:5px 10px;height:25px;line-height:0;cursor:pointer;color:#000;background-color:#fff;border:1.5px solid black;border-radius:2px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }, { kind: "pipe", type: ActionDisplayerPipe, name: "actionDisplayer" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultActionsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-result-actions', template: "<!-- This sections is for actions that we display as icon buttons -->\n<div [style.max-width.px]=\"width\" class=\"list_actions\" *ngIf=\"mode === 'icon'; else textActions\">\n    <ng-container *ngFor=\"let action of actions\">\n        <ng-container *ngIf=\"action?.show === true\">\n            <!-- The action is activated, which means it will always be displayed.-->\n            <ng-container *ngIf=\"action?.activated\">\n                <!-- The button icon is provided by css 'background-url' attribute.-->\n                <button *ngIf=\"!action?.icon else active_icon\" (click)=\"triggerAction($event, action)\"\n                    matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\"\n                    class=\"resultitem-list__actions {{action.id}}-onhover-action {{action.cssClass}}-onhover-action\">\n                    {{action | actionDisplayer:'label' | translate}}\n                </button>\n                <ng-template #active_icon>\n                    <!-- The icon is provided by the action itself.-->\n                    <mat-icon (click)=\"triggerAction($event, action)\" class=\"icon\"\n                        matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                        {{action | actionDisplayer:'icon'}}\n                    </mat-icon>\n                </ng-template>\n            </ng-container>\n        </ng-container>\n    </ng-container>\n    <ng-container *ngFor=\"let action of actions\">\n        <ng-container *ngIf=\"action?.show === true\">\n            <!-- The action is not activated, which means it will appear only when an item is hovered.-->\n            <ng-container *ngIf=\"!action?.activated\">\n                <button *ngIf=\"!action?.icon else not_active_icon\" (click)=\"triggerAction($event, action)\"\n                    class=\"not_activated\" matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\"\n                    class=\"resultitem-list__actions {{action.id}}-onhover-action {{action.cssClass}}-onhover-action\">\n                    {{action | actionDisplayer:'label' | translate}}\n                </button>\n                <ng-template #not_active_icon>\n                    <mat-icon (click)=\"triggerAction($event, action)\" class=\"icon not_activated\"\n                        matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                        {{action | actionDisplayer:'icon'}}\n                    </mat-icon>\n                </ng-template>\n            </ng-container>\n        </ng-container>\n    </ng-container>\n\n</div>\n<!-- This sections is for actions that we display as text buttons instead of icon buttons-->\n<ng-template #textActions>\n    <ng-container *ngFor=\"let action of actions\">\n        <ng-container *ngIf=\"action?.show === true\">\n            <button mat-raised-button *ngIf=\"!action?.activated else activeButton\" class=\"text-action {{action.id}}-action {{action.cssClass}}-action\"\n                (click)=\"triggerAction($event, action)\" matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                {{action | actionDisplayer:'label' | translate}}\n            </button>\n            <ng-template #activeButton>\n                <button mat-raised-button *ngIf=\"action?.activated\" (click)=\"triggerAction($event, action)\"\n                    class=\"resultdetaileditem__actions text-action {{action.id}}-action {{action.cssClass}}-action\" matTooltip=\"{{action | actionDisplayer:'tooltip' |translate}}\">\n                    {{action | actionDisplayer:'label' | translate}}\n                </button>\n            </ng-template>\n        </ng-container>\n    </ng-container>\n</ng-template>\n", styles: ["@charset \"UTF-8\";.resultitem-list__actions{min-width:0;border-radius:50%;border:none;padding:0;width:24px;height:24px;font-size:0;color:#fff;margin-left:5px;background-color:#fff;background-image:url(\"data:image/svg+xml,%3Csvg%20width%3D%2720%27%20height%3D%2720%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%20%3Cg%3E%20%20%3Ctitle%3Ebackground%3C%2Ftitle%3E%20%20%3Crect%20fill%3D%27%23fff%27%20id%3D%27canvas_background%27%20height%3D%2722%27%20width%3D%2722%27%20y%3D%27-1%27%20x%3D%27-1%27%2F%3E%20%20%3Cg%20display%3D%27none%27%20overflow%3D%27visible%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%20id%3D%27canvasGrid%27%3E%20%20%20%3Crect%20fill%3D%27url(%23gridpattern)%27%20stroke-width%3D%270%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%2F%3E%20%20%3C%2Fg%3E%20%3C%2Fg%3E%20%3Cg%3E%20%20%3Ctitle%3ELayer%201%3C%2Ftitle%3E%20%20%3Cellipse%20stroke%3D%27%23000000%27%20ry%3D%275.779194%27%20rx%3D%275.5%27%20id%3D%27svg_1%27%20cy%3D%2710.000004%27%20cx%3D%2710%27%20stroke-width%3D%272.5%27%20fill%3D%27%23ffffff%27%2F%3E%20%3C%2Fg%3E%3C%2Fsvg%3E\");background-repeat:no-repeat;background-position:center;float:right;cursor:pointer}.resultitem-list__actions:active{border:1px solid white}.list_actions{display:flex;flex-direction:row-reverse;align-items:center;position:absolute;right:0;top:0;height:100%;width:max-content}.list_actions .not_activated{display:none}.list_actions .icon{margin-left:5px;float:right;width:24px;height:24px;font-size:20px;text-align:center;align-content:space-evenly;background-color:#fff;border-radius:50%;cursor:pointer}.list_active_actions{display:flex;flex-direction:row-reverse;align-items:center;position:absolute;right:35px;top:0;height:100%;width:max-content}.text-action{font-family:Roboto,Helvetica Neue,sans-serif;font-size:11px;margin:3px;padding:5px 10px;height:25px;line-height:0;cursor:pointer;color:#000;background-color:#fff;border:1.5px solid black;border-radius:2px}\n"] }]
        }], ctorParameters: () => [{ type: ResultlistNotifierService }], propDecorators: { item: [{
                type: Input
            }], width: [{
                type: Input
            }], activatedActionsPerItem: [{
                type: Input
            }], detailedDataRetriever: [{
                type: Input
            }], stopPropagation: [{
                type: Input
            }], mode: [{
                type: Input
            }], actionOnItemEvent: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultGridTileComponent extends ItemComponent {
    constructor() {
        super();
        /**
         * @constant
         */
        this.SHOW_IMAGE = marker('Click to show details');
        /**
         * @Input
         * @description How to fit the thumbnail to the tile:
         * - `height` fit the height of the thumbnail.
         * - `width` fit the width of the thumbnail.
         * - `contain` fit the wholethumbnail.
         */
        this.thumbnailFit = ThumbnailFitEnum.contain;
        /**
         * @Input : Angular
         * @description Map <itemId, Set<actionIds>> : for each item, gives the list of activated actions.
        */
        this.activatedActionsPerItem = new Map();
        /**
        * @Input
        * @description Display or not big full info icon on the grid.
        */
        this.displayInfoIcon = false;
        /**
         * @Output
         * @description Emits the event of applying the specified action on the specified item.
         */
        this.actionOnItemEvent = new Subject();
        /**
         * @Output
         * @description Emits the list of selected items in result-list.component.
         */
        this.selectedItemsEvent = new Subject();
        /**
         * @Output
         * @description Emits the selected/unselected item.
         * @deprecated
         */
        this.selectedItemPositionEvent = new Subject();
        /**
         * @Output
         * @description Emits the the item that it has been clicked on it.
         */
        this.clickedOnItemEvent = new Subject();
        this.ThumbnailFitEnum = ThumbnailFitEnum;
    }
    /**
     * Hides the cell's tooltip when the mouse is over the attachements buttons
     * @param event mouseover event
     */
    hideCellTooltip(event) {
        event.stopPropagation();
        this.cellTooltip.hide();
    }
    /**
     * Shows the cell's tooltip when the mouse is over the tile
     */
    showCellTooltip() {
        this.cellTooltip.show();
    }
    ngOnInit() { }
    // Update the list of the selected items
    setSelectedItem() {
        super.setSelectedItem(this.gridTile.isChecked, this.gridTile.identifier, this.selectedItems);
        this.gridTile.isChecked = !this.gridTile.isChecked;
        // Emit to the result list the fact that this checkbox has changed in order to notify the correspondant one in list mode
        this.selectedItemsEvent.next(this.selectedItems);
    }
    determinateItem() {
        this.gridTile.isChecked = true;
        this.gridTile.isindeterminated = false;
        this.selectedItems.add(this.gridTile.identifier);
        // Emit to the result list the fact that this checkbox has changed in order to notify the correspondant one in grid mode
        this.selectedItemsEvent.next(this.selectedItems);
    }
    setClickedOnItem() {
        this.retrieveAdditionalInfo(this.detailedDataRetriever, this.gridTile);
        this.clickedOnItemEvent.next(this.gridTile);
    }
    triggerActionOnItem(action) {
        this.actionOnItemEvent.next({
            action: action,
            elementidentifier: { idFieldName: this.idFieldName, idValue: this.gridTile.identifier }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultGridTileComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ResultGridTileComponent, selector: "arlas-result-grid-tile", inputs: { gridTile: "gridTile", thumbnailFit: "thumbnailFit", selectedItems: "selectedItems", detailedDataRetriever: "detailedDataRetriever", options: "options", idFieldName: "idFieldName", activatedActionsPerItem: "activatedActionsPerItem", displayInfoIcon: "displayInfoIcon" }, outputs: { actionOnItemEvent: "actionOnItemEvent", selectedItemsEvent: "selectedItemsEvent", selectedItemPositionEvent: "selectedItemPositionEvent", clickedOnItemEvent: "clickedOnItemEvent" }, viewQueries: [{ propertyName: "cellTooltip", first: true, predicate: ["cellTooltip"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"resultgrid\" >\n  <div class=\"resultgrid--container resultgrid--container-highlight-{{gridTile?.ishighLight}}\" color=\"primary\"[style.border-color]=\"gridTile?.color ? gridTile?.color : 'none'\">\n    <mat-icon *ngIf=\"gridTile?.isChecked && !gridTile?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultgrid__icon_check mat-icon material-icons\">check_box</mat-icon>\n    <mat-icon *ngIf=\"!gridTile?.isChecked && !gridTile?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultgrid__icon_check mat-icon material-icons\">check_box_outline_blank</mat-icon>\n    <mat-icon *ngIf=\"gridTile?.isindeterminated\" (click)=\"determinateItem()\" class=\"primary resultgrid__icon_check mat-icon material-icons\">indeterminate_check_box</mat-icon>\n    <div id=\"{{'grid-tile-' + gridTile?.identifier}}\" (click)=\"setClickedOnItem()\" (mouseover)=\"showCellTooltip()\" #cellTooltip=\"matTooltip\" matTooltip=\"{{SHOW_IMAGE | translate}}\"  class=\"resultgrid__img {{gridTile?.iconCssClass}}\">\n      <img [defaultImage]=\"options?.defautlImgUrl\" [lazyLoad]=\"gridTile?.urlThumbnail\"\n        [class.contain_thumbnail]=\"thumbnailFit === ThumbnailFitEnum.contain\" [class.height_thumbnail]=\"thumbnailFit === ThumbnailFitEnum.height\"\n        [class.width_thumbnail]=\"thumbnailFit === ThumbnailFitEnum.width\">\n      <div *ngIf=\"options?.showActionsOnhover\" class=\"actions\" (mouseover)=\"hideCellTooltip($event)\">\n        <arlas-result-actions \n          [activatedActionsPerItem]=\"activatedActionsPerItem\" \n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [item]=\"gridTile\"\n          [stopPropagation]=\"true\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\" ></arlas-result-actions>\n\n      </div>\n      <mat-icon class=\"resultlist__md-grid-tile__selected--icon\" *ngIf=\"displayInfoIcon\">info_outline</mat-icon>\n    </div>\n    <div class=\"resultgrid__title-highlight-{{gridTile?.ishighLight}}\">\n      <span *ngIf=\"gridTile?.color\" matTooltip=\"{{gridTile?.tooltip}}\" class=\"tablet\" [style.background-color]=\"gridTile?.color\"></span>\n      <span class=\"resultgrid__title  resultgrid__title-{{gridTile?.iconCssClass}}\" > {{gridTile?.title}} </span>\n    </div>\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.resultgrid{width:100%;height:100%}.resultitem-grid__actions{min-width:0;border-radius:50%;border:none;width:24px;height:24px;box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f;font-size:0;margin:1px 5px;background-color:#fff;background-image:url(\"data:image/svg+xml,%3Csvg%20width%3D%2720%27%20height%3D%2720%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%20%3Cg%3E%20%20%3Ctitle%3Ebackground%3C%2Ftitle%3E%20%20%3Crect%20fill%3D%27%23fff%27%20id%3D%27canvas_background%27%20height%3D%2722%27%20width%3D%2722%27%20y%3D%27-1%27%20x%3D%27-1%27%2F%3E%20%20%3Cg%20display%3D%27none%27%20overflow%3D%27visible%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%20id%3D%27canvasGrid%27%3E%20%20%20%3Crect%20fill%3D%27url(%23gridpattern)%27%20stroke-width%3D%270%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%2F%3E%20%20%3C%2Fg%3E%20%3C%2Fg%3E%20%3Cg%3E%20%20%3Ctitle%3ELayer%201%3C%2Ftitle%3E%20%20%3Cellipse%20stroke%3D%27%23000000%27%20ry%3D%275.779194%27%20rx%3D%275.5%27%20id%3D%27svg_1%27%20cy%3D%2710.000004%27%20cx%3D%2710%27%20stroke-width%3D%272.5%27%20fill%3D%27%23ffffff%27%2F%3E%20%3C%2Fg%3E%3C%2Fsvg%3E\");background-repeat:no-repeat;background-position:center}.resultitem-grid__actions:active{border:1px solid white}.grid_actions{flex-direction:row-reverse;flex-wrap:wrap-reverse;position:absolute;bottom:1px;right:0;margin-left:2px;margin-top:2px}.resultgrid__img:hover .grid_actions{display:flex;justify-content:space-between}.resultgrid--container,.resultgrid--container-highlight-{width:100%;height:100%;margin:1px;background-color:#fff;position:relative;color:#000}.resultgrid .resultgrid--container .resultgrid__img:hover .actions ::ng-deep .list_actions .not_activated{display:block}.resultgrid .resultgrid--container .resultgrid__img .actions{position:absolute;bottom:15%;right:2px}.resultgrid--container-highlight-false{opacity:.3}.resultgrid--container-highlight-true{opacity:1}.resultgrid__icon_check{position:absolute;top:5px;left:5px;font-size:15px;width:15px;height:15px;color:#fff;cursor:pointer;z-index:5;-webkit-user-select:none;user-select:none}.resultgrid__img{box-sizing:border-box;display:flex;height:85%;width:100%;padding:2px;background-position:center center;background-repeat:no-repeat;position:relative;align-items:center;justify-content:center;background-color:#000}.resultgrid__title-highlight-,.resultgrid__title-highlight-false,.resultgrid__title-highlight-true{height:15%;color:#000;font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;display:flex;justify-content:space-between;align-items:center;padding:0 5px;box-sizing:border-box}.resultgrid__title-highlight- .tablet,.resultgrid__title-highlight-false .tablet,.resultgrid__title-highlight-true .tablet{height:80%;max-height:20px;aspect-ratio:1;border-radius:100px;margin-right:2px}.resultgrid__title-highlight- .resultgrid__title,.resultgrid__title-highlight-false .resultgrid__title,.resultgrid__title-highlight-true .resultgrid__title{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.resultgrid__title-highlight-false{opacity:.3}.fill-images{object-fit:cover;width:100%;height:100%;background-color:#000}.contain_thumbnail{object-fit:contain;width:100%;height:100%;background-color:#000}.height_thumbnail{object-fit:cover;max-width:100%;max-height:100%;height:100%;background-color:#000}.width_thumbnail{object-fit:cover;max-width:100%;max-height:100%;width:100%;background-color:#000}.resultlist__md-grid-tile{margin-top:5px}.resultlist__md-grid-tile__selected--icon{position:absolute;z-index:1;top:15px;color:#fff;background-color:transparent;opacity:50%;font-size:72px;height:72px!important;width:72px!important;pointer-events:auto;cursor:default}\n"], dependencies: [{ kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "directive", type: i4$1.LazyLoadImageDirective, selector: "[lazyLoad]", inputs: ["lazyLoad", "defaultImage", "errorImage", "scrollTarget", "customObservable", "offset", "useSrcset", "decode", "debug"], outputs: ["onStateChange"] }, { kind: "component", type: ResultActionsComponent, selector: "arlas-result-actions", inputs: ["item", "width", "activatedActionsPerItem", "detailedDataRetriever", "stopPropagation", "mode"], outputs: ["actionOnItemEvent"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultGridTileComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-result-grid-tile', template: "<div class=\"resultgrid\" >\n  <div class=\"resultgrid--container resultgrid--container-highlight-{{gridTile?.ishighLight}}\" color=\"primary\"[style.border-color]=\"gridTile?.color ? gridTile?.color : 'none'\">\n    <mat-icon *ngIf=\"gridTile?.isChecked && !gridTile?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultgrid__icon_check mat-icon material-icons\">check_box</mat-icon>\n    <mat-icon *ngIf=\"!gridTile?.isChecked && !gridTile?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultgrid__icon_check mat-icon material-icons\">check_box_outline_blank</mat-icon>\n    <mat-icon *ngIf=\"gridTile?.isindeterminated\" (click)=\"determinateItem()\" class=\"primary resultgrid__icon_check mat-icon material-icons\">indeterminate_check_box</mat-icon>\n    <div id=\"{{'grid-tile-' + gridTile?.identifier}}\" (click)=\"setClickedOnItem()\" (mouseover)=\"showCellTooltip()\" #cellTooltip=\"matTooltip\" matTooltip=\"{{SHOW_IMAGE | translate}}\"  class=\"resultgrid__img {{gridTile?.iconCssClass}}\">\n      <img [defaultImage]=\"options?.defautlImgUrl\" [lazyLoad]=\"gridTile?.urlThumbnail\"\n        [class.contain_thumbnail]=\"thumbnailFit === ThumbnailFitEnum.contain\" [class.height_thumbnail]=\"thumbnailFit === ThumbnailFitEnum.height\"\n        [class.width_thumbnail]=\"thumbnailFit === ThumbnailFitEnum.width\">\n      <div *ngIf=\"options?.showActionsOnhover\" class=\"actions\" (mouseover)=\"hideCellTooltip($event)\">\n        <arlas-result-actions \n          [activatedActionsPerItem]=\"activatedActionsPerItem\" \n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [item]=\"gridTile\"\n          [stopPropagation]=\"true\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\" ></arlas-result-actions>\n\n      </div>\n      <mat-icon class=\"resultlist__md-grid-tile__selected--icon\" *ngIf=\"displayInfoIcon\">info_outline</mat-icon>\n    </div>\n    <div class=\"resultgrid__title-highlight-{{gridTile?.ishighLight}}\">\n      <span *ngIf=\"gridTile?.color\" matTooltip=\"{{gridTile?.tooltip}}\" class=\"tablet\" [style.background-color]=\"gridTile?.color\"></span>\n      <span class=\"resultgrid__title  resultgrid__title-{{gridTile?.iconCssClass}}\" > {{gridTile?.title}} </span>\n    </div>\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.resultgrid{width:100%;height:100%}.resultitem-grid__actions{min-width:0;border-radius:50%;border:none;width:24px;height:24px;box-shadow:0 3px 1px -2px #0003,0 2px 2px #00000024,0 1px 5px #0000001f;font-size:0;margin:1px 5px;background-color:#fff;background-image:url(\"data:image/svg+xml,%3Csvg%20width%3D%2720%27%20height%3D%2720%27%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%3E%20%3Cg%3E%20%20%3Ctitle%3Ebackground%3C%2Ftitle%3E%20%20%3Crect%20fill%3D%27%23fff%27%20id%3D%27canvas_background%27%20height%3D%2722%27%20width%3D%2722%27%20y%3D%27-1%27%20x%3D%27-1%27%2F%3E%20%20%3Cg%20display%3D%27none%27%20overflow%3D%27visible%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%20id%3D%27canvasGrid%27%3E%20%20%20%3Crect%20fill%3D%27url(%23gridpattern)%27%20stroke-width%3D%270%27%20y%3D%270%27%20x%3D%270%27%20height%3D%27100%25%27%20width%3D%27100%25%27%2F%3E%20%20%3C%2Fg%3E%20%3C%2Fg%3E%20%3Cg%3E%20%20%3Ctitle%3ELayer%201%3C%2Ftitle%3E%20%20%3Cellipse%20stroke%3D%27%23000000%27%20ry%3D%275.779194%27%20rx%3D%275.5%27%20id%3D%27svg_1%27%20cy%3D%2710.000004%27%20cx%3D%2710%27%20stroke-width%3D%272.5%27%20fill%3D%27%23ffffff%27%2F%3E%20%3C%2Fg%3E%3C%2Fsvg%3E\");background-repeat:no-repeat;background-position:center}.resultitem-grid__actions:active{border:1px solid white}.grid_actions{flex-direction:row-reverse;flex-wrap:wrap-reverse;position:absolute;bottom:1px;right:0;margin-left:2px;margin-top:2px}.resultgrid__img:hover .grid_actions{display:flex;justify-content:space-between}.resultgrid--container,.resultgrid--container-highlight-{width:100%;height:100%;margin:1px;background-color:#fff;position:relative;color:#000}.resultgrid .resultgrid--container .resultgrid__img:hover .actions ::ng-deep .list_actions .not_activated{display:block}.resultgrid .resultgrid--container .resultgrid__img .actions{position:absolute;bottom:15%;right:2px}.resultgrid--container-highlight-false{opacity:.3}.resultgrid--container-highlight-true{opacity:1}.resultgrid__icon_check{position:absolute;top:5px;left:5px;font-size:15px;width:15px;height:15px;color:#fff;cursor:pointer;z-index:5;-webkit-user-select:none;user-select:none}.resultgrid__img{box-sizing:border-box;display:flex;height:85%;width:100%;padding:2px;background-position:center center;background-repeat:no-repeat;position:relative;align-items:center;justify-content:center;background-color:#000}.resultgrid__title-highlight-,.resultgrid__title-highlight-false,.resultgrid__title-highlight-true{height:15%;color:#000;font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;display:flex;justify-content:space-between;align-items:center;padding:0 5px;box-sizing:border-box}.resultgrid__title-highlight- .tablet,.resultgrid__title-highlight-false .tablet,.resultgrid__title-highlight-true .tablet{height:80%;max-height:20px;aspect-ratio:1;border-radius:100px;margin-right:2px}.resultgrid__title-highlight- .resultgrid__title,.resultgrid__title-highlight-false .resultgrid__title,.resultgrid__title-highlight-true .resultgrid__title{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.resultgrid__title-highlight-false{opacity:.3}.fill-images{object-fit:cover;width:100%;height:100%;background-color:#000}.contain_thumbnail{object-fit:contain;width:100%;height:100%;background-color:#000}.height_thumbnail{object-fit:cover;max-width:100%;max-height:100%;height:100%;background-color:#000}.width_thumbnail{object-fit:cover;max-width:100%;max-height:100%;width:100%;background-color:#000}.resultlist__md-grid-tile{margin-top:5px}.resultlist__md-grid-tile__selected--icon{position:absolute;z-index:1;top:15px;color:#fff;background-color:transparent;opacity:50%;font-size:72px;height:72px!important;width:72px!important;pointer-events:auto;cursor:default}\n"] }]
        }], ctorParameters: () => [], propDecorators: { cellTooltip: [{
                type: ViewChild,
                args: ['cellTooltip', { static: true }]
            }], gridTile: [{
                type: Input
            }], thumbnailFit: [{
                type: Input
            }], selectedItems: [{
                type: Input
            }], detailedDataRetriever: [{
                type: Input
            }], options: [{
                type: Input
            }], idFieldName: [{
                type: Input
            }], activatedActionsPerItem: [{
                type: Input
            }], displayInfoIcon: [{
                type: Input
            }], actionOnItemEvent: [{
                type: Output
            }], selectedItemsEvent: [{
                type: Output
            }], selectedItemPositionEvent: [{
                type: Output
            }], clickedOnItemEvent: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class FormatNumberPipe {
    constructor(translate) {
        this.translate = translate;
    }
    transform(x, formatChar = ' ') {
        return formatNumber(x, this.translate.instant(formatChar));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberPipe, deps: [{ token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberPipe, name: "formatNumber" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'formatNumber'
                }]
        }, {
            type: Injectable
        }], ctorParameters: () => [{ type: i2.TranslateService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultItemComponent extends ItemComponent {
    constructor(colorService, translate) {
        super();
        this.colorService = colorService;
        this.translate = translate;
        /**
         * @constant
         */
        this.HIDE_DETAILS = marker('Hide details');
        /**
         * @constant
         */
        this.SHOW_DETAILS = marker('Show details');
        this.CellBackgroundStyleEnum = CellBackgroundStyleEnum;
        /**
         * @Input : Angular
         * @description Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a
         * factor (between 0 and 1) that tightens this scale to [(1-colorsSaturationWeight), 1].
         * Therefore saturation of generated colors will be within this tightened scale.
         */
        this.colorsSaturationWeight = 1 / 2;
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the cells of the item (the row) according to the terms displayed
         */
        this.useColorService = false;
        /**
         * @Input : Angular
         * @description The way the cell will be colorized: filled or outlined
         */
        this.cellBackgroundStyle = CellBackgroundStyleEnum.filled;
        /**
         * @Input : Angular
         * @description Map <itemId, Set<actionIds>> : for each item, gives the list of activated actions.
        */
        this.activatedActionsPerItem = new Map();
        /**
         * @Output
         * @description Emits the list of selected items in result-list.component.
         */
        this.selectedItemsEvent = new Subject();
        /**
         * @Output
         * @description Emits the event of applying the specified action on the specified item.
         */
        this.actionOnItemEvent = new Subject();
        /**
         * @Output
         * @description Emits the selected/unselected item.
         * @deprecated
         */
        this.selectedItemPositionEvent = new Subject();
        /**
         * @Output
         * @description Emits the border line style depending on the item's toggle state.
         */
        this.borderStyleEvent = new Subject();
        this.isDetailToggled = false;
        this.detailedData = '';
        this.borderStyle = 'solid';
        this.colors = {};
        this.NUMBER_FORMAT_CHAR = NUMBER_FORMAT_CHAR;
        this.colorService.changekeysToColors$.subscribe(() => this.updateColors());
    }
    ngOnInit() {
        this.identifier = this.rowItem?.identifier;
        this.updateColors();
    }
    // Detailed data is retrieved wheb the row is toggled for the first time
    toggle() {
        if (this.rowItem.isDetailToggled === false) {
            this.retrieveAdditionalInfo(this.detailedDataRetriever, this.rowItem);
            this.borderStyle = 'dashed';
        }
        else {
            this.borderStyle = 'solid';
        }
        this.borderStyleEvent.next(this.borderStyle);
        this.rowItem.isDetailToggled = !this.rowItem.isDetailToggled;
    }
    // Update the list of the selected items
    setSelectedItem() {
        super.setSelectedItem(this.rowItem.isChecked, this.identifier, this.selectedItems);
        this.rowItem.isChecked = !this.rowItem.isChecked;
        // Emit to the result list the fact that this checkbox has changed in order to notify the correspondant one in grid mode
        this.selectedItemsEvent.next(this.selectedItems);
    }
    determinateItem() {
        this.rowItem.isChecked = true;
        this.rowItem.isindeterminated = false;
        this.selectedItems.add(this.identifier);
        // Emit to the result list the fact that this checkbox has changed in order to notify the correspondant one in grid mode
        this.selectedItemsEvent.next(this.selectedItems);
    }
    getTextColor(key) {
        if (key !== undefined && key !== null) {
            return this.colorService.getTextColor(key.toString());
        }
        else {
            return '';
        }
    }
    triggerActionOnItem(action) {
        this.actionOnItemEvent.next({ action: action, elementidentifier: { idFieldName: this.idFieldName, idValue: this.rowItem.identifier } });
    }
    updateColors() {
        const newColor = {};
        this.rowItem?.columns.forEach(c => {
            if (c.useColorService) {
                const key = this.rowItem?.itemData.get(c.fieldName);
                if (key !== undefined && key !== null) {
                    newColor[key.toString()] = {};
                    newColor[key.toString()]['color'] = this.getColor(key);
                    newColor[key.toString()]['textColor'] = this.getTextColor(key);
                }
            }
        });
        this.colors = newColor;
    }
    getColor(key) {
        if (key !== undefined && key !== null) {
            return this.colorService.getColor(key.toString(), this.keysToColors, this.colorsSaturationWeight);
        }
        else {
            return '';
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultItemComponent, deps: [{ token: ArlasColorService }, { token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ResultItemComponent, selector: "[arlas-result-item]", inputs: { options: "options", rowItem: "rowItem", idFieldName: "idFieldName", detailedDataRetriever: "detailedDataRetriever", selectedItems: "selectedItems", keysToColors: "keysToColors", colorsSaturationWeight: "colorsSaturationWeight", useColorService: "useColorService", cellBackgroundStyle: "cellBackgroundStyle", activatedActionsPerItem: "activatedActionsPerItem", tableWidth: "tableWidth" }, outputs: { selectedItemsEvent: "selectedItemsEvent", actionOnItemEvent: "actionOnItemEvent", selectedItemPositionEvent: "selectedItemPositionEvent", borderStyleEvent: "borderStyleEvent" }, usesInheritance: true, ngImport: i0, template: "  <ng-container *ngFor=\"let column of rowItem?.columns;\">\n    <!-- If the column corresponds to an id field, then we put the checkbox that enables to check the item-->\n    <td *ngIf=\"column.isIdField\" class=\"resultitem__cell\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\" >\n      <div class=\"checkbox\">\n        <mat-icon *ngIf=\"rowItem?.isChecked && !rowItem?.isindeterminated\"  (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box</mat-icon>\n        <mat-icon *ngIf=\"!rowItem?.isChecked && !rowItem?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box_outline_blank</mat-icon>\n        <mat-icon *ngIf=\"rowItem?.isindeterminated\" (click)=\"determinateItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">indeterminate_check_box</mat-icon>\n      </div>\n    </td>\n\n    <!-- If the column is not an id field nor a toggle, then we put the value of the corespondant field-->\n    <td *ngIf=\"!column.isIdField && !column.isToggleField\" class=\"resultitem__cell resultitem__cell__{{column.fieldName}}\"\n          [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\">\n      <label *ngIf=\"(!useColorService || !column.useColorService || cellBackgroundStyle === undefined); else labelModeIsDefined\" class=\"resultitem__cell--label resultitem__cell--label__{{column.fieldName}}  resultitem__cell--label__{{rowItem?.itemData.get(column.fieldName)}}\">\n        {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n      </label>\n      <ng-template #labelModeIsDefined>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.filled && column.useColorService\" class=\"resultitem__cell--label resultitem__cell--label__filled\"\n          [style.background-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'transparent'\" \n          [style.color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ?  colors[rowItem?.itemData.get(column.fieldName)]['textColor'] : 'black'\">\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.outlined && column.useColorService && !!rowItem?.itemData.get(column.fieldName) && rowItem?.itemData.get(column.fieldName) !== ''\" class=\"resultitem__cell--label resultitem__cell--label__outlined\"\n          [style.border-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'black'\"  >\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n      </ng-template>\n    </td>\n\n    <!-- If the column is a toggle, then we put the + button that enables to fetch detailed data of the item-->\n    <td *ngIf=\"column.isToggleField\" class=\"resultitem__cell toggle\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\">\n      <div *ngIf=\"options.showActionsOnhover\" class=\"actions\">\n        <arlas-result-actions\n          [item]=\"rowItem\"\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [width]=\"tableWidth * 80 / 100\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\"></arlas-result-actions>\n      </div>\n      <mat-icon id= \"{{'open-detail-' + rowItem?.identifier}}\" matTooltip=\"{{SHOW_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" *ngIf=\"!rowItem?.isDetailToggled; else cancel_toggle\" (click) = \"toggle()\">{{options.showDetailIconName}}</mat-icon>\n      <ng-template #cancel_toggle>\n        <mat-icon id= \"{{'close-detail-' + rowItem?.identifier}}\"   matTooltip=\"{{HIDE_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" (click) = \"toggle()\">{{options.hideDetailIconName}}</mat-icon>\n      </ng-template>\n    </td>\n\n  </ng-container>\n\n\n\n", styles: [".resultitem__cell{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;text-align:left;vertical-align:middle;box-sizing:border-box}.resultitem__cell__toggle--icon{font-size:18px;width:18px;height:18px;display:block;cursor:pointer}.resultitem__cell--label{margin:0}.resultitem__icon_check{float:right;font-size:15px;width:15px;height:15px;cursor:pointer}.resultitem__cell--label__filled{padding:2px;border-radius:2px}.resultitem__cell--label__outlined{padding:2px;border-radius:2px;border:1.5px solid;display:inline-grid}.toggle{position:relative;cursor:pointer}.actions{position:absolute;right:35px;top:0;height:100%;width:100%}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "component", type: ResultActionsComponent, selector: "arlas-result-actions", inputs: ["item", "width", "activatedActionsPerItem", "detailedDataRetriever", "stopPropagation", "mode"], outputs: ["actionOnItemEvent"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }, { kind: "pipe", type: FormatNumberPipe, name: "formatNumber" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultItemComponent, decorators: [{
            type: Component,
            args: [{ selector: '[arlas-result-item]', template: "  <ng-container *ngFor=\"let column of rowItem?.columns;\">\n    <!-- If the column corresponds to an id field, then we put the checkbox that enables to check the item-->\n    <td *ngIf=\"column.isIdField\" class=\"resultitem__cell\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\" >\n      <div class=\"checkbox\">\n        <mat-icon *ngIf=\"rowItem?.isChecked && !rowItem?.isindeterminated\"  (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box</mat-icon>\n        <mat-icon *ngIf=\"!rowItem?.isChecked && !rowItem?.isindeterminated\" (click)=\"setSelectedItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">check_box_outline_blank</mat-icon>\n        <mat-icon *ngIf=\"rowItem?.isindeterminated\" (click)=\"determinateItem()\" class=\"primary resultitem__icon_check mat-icon material-icons\">indeterminate_check_box</mat-icon>\n      </div>\n    </td>\n\n    <!-- If the column is not an id field nor a toggle, then we put the value of the corespondant field-->\n    <td *ngIf=\"!column.isIdField && !column.isToggleField\" class=\"resultitem__cell resultitem__cell__{{column.fieldName}}\"\n          [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\">\n      <label *ngIf=\"(!useColorService || !column.useColorService || cellBackgroundStyle === undefined); else labelModeIsDefined\" class=\"resultitem__cell--label resultitem__cell--label__{{column.fieldName}}  resultitem__cell--label__{{rowItem?.itemData.get(column.fieldName)}}\">\n        {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n      </label>\n      <ng-template #labelModeIsDefined>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.filled && column.useColorService\" class=\"resultitem__cell--label resultitem__cell--label__filled\"\n          [style.background-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'transparent'\" \n          [style.color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ?  colors[rowItem?.itemData.get(column.fieldName)]['textColor'] : 'black'\">\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n        <label *ngIf=\"cellBackgroundStyle === CellBackgroundStyleEnum.outlined && column.useColorService && !!rowItem?.itemData.get(column.fieldName) && rowItem?.itemData.get(column.fieldName) !== ''\" class=\"resultitem__cell--label resultitem__cell--label__outlined\"\n          [style.border-color]=\"!!colors[rowItem?.itemData.get(column.fieldName)] ? colors[rowItem?.itemData.get(column.fieldName)]['color'] : 'black'\"  >\n          {{rowItem?.itemData.get(column.fieldName) | formatNumber:NUMBER_FORMAT_CHAR}}{{column.dataType}}\n        </label>\n      </ng-template>\n    </td>\n\n    <!-- If the column is a toggle, then we put the + button that enables to fetch detailed data of the item-->\n    <td *ngIf=\"column.isToggleField\" class=\"resultitem__cell toggle\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\">\n      <div *ngIf=\"options.showActionsOnhover\" class=\"actions\">\n        <arlas-result-actions\n          [item]=\"rowItem\"\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [width]=\"tableWidth * 80 / 100\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\"></arlas-result-actions>\n      </div>\n      <mat-icon id= \"{{'open-detail-' + rowItem?.identifier}}\" matTooltip=\"{{SHOW_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" *ngIf=\"!rowItem?.isDetailToggled; else cancel_toggle\" (click) = \"toggle()\">{{options.showDetailIconName}}</mat-icon>\n      <ng-template #cancel_toggle>\n        <mat-icon id= \"{{'close-detail-' + rowItem?.identifier}}\"   matTooltip=\"{{HIDE_DETAILS | translate}}\" class=\"resultitem__cell__toggle--icon\" (click) = \"toggle()\">{{options.hideDetailIconName}}</mat-icon>\n      </ng-template>\n    </td>\n\n  </ng-container>\n\n\n\n", styles: [".resultitem__cell{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;text-align:left;vertical-align:middle;box-sizing:border-box}.resultitem__cell__toggle--icon{font-size:18px;width:18px;height:18px;display:block;cursor:pointer}.resultitem__cell--label{margin:0}.resultitem__icon_check{float:right;font-size:15px;width:15px;height:15px;cursor:pointer}.resultitem__cell--label__filled{padding:2px;border-radius:2px}.resultitem__cell--label__outlined{padding:2px;border-radius:2px;border:1.5px solid;display:inline-grid}.toggle{position:relative;cursor:pointer}.actions{position:absolute;right:35px;top:0;height:100%;width:100%}\n"] }]
        }], ctorParameters: () => [{ type: ArlasColorService }, { type: i2.TranslateService }], propDecorators: { options: [{
                type: Input
            }], rowItem: [{
                type: Input
            }], idFieldName: [{
                type: Input
            }], detailedDataRetriever: [{
                type: Input
            }], selectedItems: [{
                type: Input
            }], keysToColors: [{
                type: Input
            }], colorsSaturationWeight: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], cellBackgroundStyle: [{
                type: Input
            }], activatedActionsPerItem: [{
                type: Input
            }], tableWidth: [{
                type: Input
            }], selectedItemsEvent: [{
                type: Output
            }], actionOnItemEvent: [{
                type: Output
            }], selectedItemPositionEvent: [{
                type: Output
            }], borderStyleEvent: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ReplacePipe {
    transform(value, searchValue, replaceValue) {
        if (!!value) {
            return value.replace(searchValue, replaceValue);
        }
        return value;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ReplacePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ReplacePipe, name: "replace" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ReplacePipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ReplacePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'replace'
                }]
        }, {
            type: Injectable
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetAttachmentUrlPipe {
    transform(value) {
        if (value && !value.startsWith('http')) {
            return 'https://' + value;
        }
        return value;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetAttachmentUrlPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetAttachmentUrlPipe, name: "getAttachmentUrl" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetAttachmentUrlPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'getAttachmentUrl'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultDetailedItemComponent {
    constructor(translate) {
        this.translate = translate;
        /**
         * @Input
         * @description Whether display group with no detail.
         */
        this.showEmptyGroup = false;
        /**
         * @Output
         * @description Emits the event of applying the specified action on the specified item.
         */
        this.actionOnItemEvent = new Subject();
        /**
         * @Input : Angular
         * @description List of active actions per item.
        */
        this.activatedActionsPerItem = new Map();
        this.NUMBER_FORMAT_CHAR = NUMBER_FORMAT_CHAR;
    }
    ngOnInit() { }
    // Emits the action on this ResultDetailedItem to the parent (ResultList)
    triggerActionOnItem(action) {
        this.actionOnItemEvent.next({ action: action, elementidentifier: { idFieldName: this.idFieldName, idValue: this.rowItem.identifier } });
    }
    getGroups() {
        return (this.showEmptyGroup) ? (this.rowItem?.itemDetailedData) : (this.rowItem?.itemDetailedData.filter(d => d.details.length > 0));
    }
    getAttachmentLabel(attachment, index) {
        if (attachment.label && attachment.label.length > 0) {
            return attachment.label;
        }
        else {
            return this.translate.instant('Link') + ' ' + index;
        }
    }
    getAttachmentDescription(attachment) {
        if (attachment.description && attachment.description.length > 0) {
            return attachment.description;
        }
        else {
            return attachment.url;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultDetailedItemComponent, deps: [{ token: i2.TranslateService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ResultDetailedItemComponent, selector: "[arlas-result-detailed-item]", inputs: { detailColspan: "detailColspan", idFieldName: "idFieldName", containerType: "containerType", rowItem: "rowItem", showEmptyGroup: "showEmptyGroup", detailedDataRetriever: "detailedDataRetriever", activatedActionsPerItem: "activatedActionsPerItem" }, outputs: { actionOnItemEvent: "actionOnItemEvent" }, ngImport: i0, template: "<td class=\"checkboxcell\" [colSpan]=\"1\">\n</td>\n<td [class.grid-container]=\"containerType === 'grid'\" [colSpan]=\"detailColspan - 1\">\n  <div class=\"details-title\" *ngIf=\"rowItem?.detailsTitleEnabled\">{{rowItem?.detailsTitle}}</div>\n  <div class=\"resultdetaileditem\">\n    <ng-container *ngFor=\"let group of rowItem?.itemDetailedData\">\n      <div class=\"resultdetaileditem--group\" *ngIf=\"showEmptyGroup || group.details.length > 0\">\n        <span class=\"resultdetaileditem--group-title {{group.group | replace:' ':'-' | lowercase}}-item-detail\">\n          {{group.group | translate}}\n        </span>\n        <span *ngFor=\"let detail of group.details\" class=\"resultdetaileditem--item {{detail.key}}-item-detail\">\n          <span class=\"resultdetaileditem--item--key\">{{detail.key | translate}}</span>\n          <span class=\"resultdetaileditem--item--value\">{{detail.value | formatNumber:NUMBER_FORMAT_CHAR}}</span>\n        </span>\n      </div>\n    </ng-container>\n    <arlas-result-actions\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [item]=\"rowItem\"\n          [mode]=\"'text'\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\" ></arlas-result-actions>\n    <span class=\"result-attachments\" *ngIf=\"rowItem?.attachments && rowItem?.attachments.length > 0\">\n      <div class=\"result-attachments--title\">{{'Attachments' | translate}}</div>\n      <span class=\"result-attachments--item\" *ngFor=\"let att of rowItem?.attachments; index as i\">\n        <a class=\"result-attachments--item--link\" href=\"{{att.url | getAttachmentUrl}}\"\n          matTooltip=\"{{getAttachmentDescription(att)}}\" [matTooltipPosition]=\"'after'\" target=\"_blank\">\n          <mat-icon *ngIf=\"att.icon\" class=\"result-attachments--item--link--icon\">{{att.icon}}</mat-icon>\n          <span class=\"result-attachments--item--link--label\"> {{getAttachmentLabel(att, i + 1)}}</span>\n        </a>\n      </span>\n    </span>\n  </div>\n\n</td>\n", styles: ["@charset \"UTF-8\";.grid-container{overflow-y:auto;display:block;height:100%;padding:0}.grid-container .details-title{background-color:#fff;position:sticky;top:0}.details-title{font-weight:500;font-size:1.1em;padding:5px}.resultdetaileditem{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;text-align:left;padding:0 5px}.resultdetaileditem--group{padding-bottom:10px}.resultdetaileditem--group-title{font-weight:700;font-size:12px;border-bottom:1px solid rgba(240,238,238,.8117647059);display:block}.resultdetaileditem--item{display:block;color:#000;padding:3px;border-bottom:1px solid rgba(240,238,238,.8117647059)}.resultdetaileditem--item--key{font-size:11px;font-weight:500;width:120px;display:inline-block;white-space:pre-wrap}.resultdetaileditem--item--value{margin-right:10px;font-weight:500;font-size:11px;overflow-wrap:anywhere}.resultdetaileditem .resultdetaileditem__actions{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.9em;margin:3px;padding:5px 10px;height:25px;line-height:0;cursor:pointer;color:#000;background-color:#fff;border:1.5px solid black;border-radius:2px}.result-attachments{display:block;max-width:95%;padding-top:10px}.result-attachments--title{font-weight:700;color:#322d90;font-size:1.1em}.result-attachments--item{padding-right:5px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "component", type: ResultActionsComponent, selector: "arlas-result-actions", inputs: ["item", "width", "activatedActionsPerItem", "detailedDataRetriever", "stopPropagation", "mode"], outputs: ["actionOnItemEvent"] }, { kind: "pipe", type: i2$1.LowerCasePipe, name: "lowercase" }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }, { kind: "pipe", type: FormatNumberPipe, name: "formatNumber" }, { kind: "pipe", type: ReplacePipe, name: "replace" }, { kind: "pipe", type: GetAttachmentUrlPipe, name: "getAttachmentUrl" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultDetailedItemComponent, decorators: [{
            type: Component,
            args: [{ selector: '[arlas-result-detailed-item]', template: "<td class=\"checkboxcell\" [colSpan]=\"1\">\n</td>\n<td [class.grid-container]=\"containerType === 'grid'\" [colSpan]=\"detailColspan - 1\">\n  <div class=\"details-title\" *ngIf=\"rowItem?.detailsTitleEnabled\">{{rowItem?.detailsTitle}}</div>\n  <div class=\"resultdetaileditem\">\n    <ng-container *ngFor=\"let group of rowItem?.itemDetailedData\">\n      <div class=\"resultdetaileditem--group\" *ngIf=\"showEmptyGroup || group.details.length > 0\">\n        <span class=\"resultdetaileditem--group-title {{group.group | replace:' ':'-' | lowercase}}-item-detail\">\n          {{group.group | translate}}\n        </span>\n        <span *ngFor=\"let detail of group.details\" class=\"resultdetaileditem--item {{detail.key}}-item-detail\">\n          <span class=\"resultdetaileditem--item--key\">{{detail.key | translate}}</span>\n          <span class=\"resultdetaileditem--item--value\">{{detail.value | formatNumber:NUMBER_FORMAT_CHAR}}</span>\n        </span>\n      </div>\n    </ng-container>\n    <arlas-result-actions\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailedDataRetriever]=\"detailedDataRetriever\"\n          [item]=\"rowItem\"\n          [mode]=\"'text'\"\n          (actionOnItemEvent)=\"triggerActionOnItem($event)\" ></arlas-result-actions>\n    <span class=\"result-attachments\" *ngIf=\"rowItem?.attachments && rowItem?.attachments.length > 0\">\n      <div class=\"result-attachments--title\">{{'Attachments' | translate}}</div>\n      <span class=\"result-attachments--item\" *ngFor=\"let att of rowItem?.attachments; index as i\">\n        <a class=\"result-attachments--item--link\" href=\"{{att.url | getAttachmentUrl}}\"\n          matTooltip=\"{{getAttachmentDescription(att)}}\" [matTooltipPosition]=\"'after'\" target=\"_blank\">\n          <mat-icon *ngIf=\"att.icon\" class=\"result-attachments--item--link--icon\">{{att.icon}}</mat-icon>\n          <span class=\"result-attachments--item--link--label\"> {{getAttachmentLabel(att, i + 1)}}</span>\n        </a>\n      </span>\n    </span>\n  </div>\n\n</td>\n", styles: ["@charset \"UTF-8\";.grid-container{overflow-y:auto;display:block;height:100%;padding:0}.grid-container .details-title{background-color:#fff;position:sticky;top:0}.details-title{font-weight:500;font-size:1.1em;padding:5px}.resultdetaileditem{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;text-align:left;padding:0 5px}.resultdetaileditem--group{padding-bottom:10px}.resultdetaileditem--group-title{font-weight:700;font-size:12px;border-bottom:1px solid rgba(240,238,238,.8117647059);display:block}.resultdetaileditem--item{display:block;color:#000;padding:3px;border-bottom:1px solid rgba(240,238,238,.8117647059)}.resultdetaileditem--item--key{font-size:11px;font-weight:500;width:120px;display:inline-block;white-space:pre-wrap}.resultdetaileditem--item--value{margin-right:10px;font-weight:500;font-size:11px;overflow-wrap:anywhere}.resultdetaileditem .resultdetaileditem__actions{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.9em;margin:3px;padding:5px 10px;height:25px;line-height:0;cursor:pointer;color:#000;background-color:#fff;border:1.5px solid black;border-radius:2px}.result-attachments{display:block;max-width:95%;padding-top:10px}.result-attachments--title{font-weight:700;color:#322d90;font-size:1.1em}.result-attachments--item{padding-right:5px}\n"] }]
        }], ctorParameters: () => [{ type: i2.TranslateService }], propDecorators: { detailColspan: [{
                type: Input
            }], idFieldName: [{
                type: Input
            }], containerType: [{
                type: Input
            }], rowItem: [{
                type: Input
            }], showEmptyGroup: [{
                type: Input
            }], actionOnItemEvent: [{
                type: Output
            }], detailedDataRetriever: [{
                type: Input
            }], activatedActionsPerItem: [{
                type: Input
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultDetailedGridComponent {
    constructor(changeDetectorRef, http) {
        this.changeDetectorRef = changeDetectorRef;
        this.http = http;
        /**
         * @constant
         */
        this.SHOW_DETAILS = marker('Show details');
        /**
         * @constant
         */
        this.VIEW_IMAGE = marker('View in full screen');
        /**
         * @constant
         */
        this.SHOW_IMAGE = marker('Show image');
        /**
         * @constant
         */
        this.CLOSE_DETAILS = marker('Close details');
        this.fullScreenViewer = new FullScreenViewer();
        /**
         * @Input
         * @description Whether display group with no detail.
         */
        this.showEmptyGroup = false;
        /**
         * @Input : Angular
         * @description Whether to use a http request to query detailed image instead of relying on img tag internal mechanism.
         */
        this.useHttp = false;
        /**
         * @Input : Angular
         * @description List of active actions per item.
        */
        this.activatedActionsPerItem = new Map();
        /**
         * @Output
         * @description Emits the event of applying the specified action on the specified item.
         */
        this.actionOnItemEvent = new Subject();
        /**
       * @Output
       * @description Emits the event of closing details.
       */
        this.closeDetail = new Subject();
        this.isDetailedDataShowed = false;
        /**
         * @description Whether the request for the image is being processed
         */
        this.isLoading = false;
        /**
         * @description In the case of multiple images, indicates which one is selected
         */
        this.currentImageIndex = 0;
        /**
         * @description Whether the viewer is in full screen mode
         */
        this.isFullScreen = false;
    }
    ngOnDestroy() {
        this.destroyViewer(true);
    }
    ngOnChanges(changes) {
        if (changes['gridTile']) {
            if (this.viewer) {
                this.viewer = this.viewer.destroy();
            }
            this.isFullScreen = false;
            this.currentImageIndex = 0;
            this.getImage();
        }
    }
    getImage() {
        this.imgSrc = undefined;
        if (!this.gridTile || (this.gridTile && (!this.gridTile.urlImages || this.gridTile.urlImages.length === 0))) {
            return;
        }
        if (this.useHttp) {
            this.isLoading = true;
            this.http.get(this.gridTile.urlImages[this.currentImageIndex], { headers: { [PROTECTED_IMAGE_HEADER]: 'true' }, responseType: 'blob' })
                .subscribe({
                next: (image) => {
                    const reader = new FileReader();
                    reader.addEventListener('load', () => {
                        this.imgSrc = reader.result;
                        this.gridTile.imageEnabled = true;
                        this.isLoading = false;
                        this.resetViewer();
                    }, false);
                    if (image) {
                        reader.readAsDataURL(image);
                    }
                }, error: (err) => {
                    console.error(err);
                    this.isLoading = false;
                }
            });
        }
        else {
            this.imgSrc = this.gridTile.urlImages[this.currentImageIndex];
            this.gridTile.imageEnabled = true;
            this.resetViewer();
        }
    }
    resetViewer() {
        if (this.viewer) {
            this.viewer = this.viewer.destroy();
        }
        setTimeout(() => {
            if (this.isFullScreen) {
                this.fullScreenViewer.show(this.imgSrc);
            }
            else {
                if (!!this.imageViewer && !this.viewer) {
                    this.viewer = new ImageViewer(this.imageViewer.nativeElement);
                }
            }
        }, 0);
    }
    destroyViewer(isComponentDestroy) {
        if (this.viewer) {
            this.viewer = this.viewer.destroy();
        }
        if (isComponentDestroy && this.fullScreenViewer) {
            this.fullScreenViewer.destroy();
        }
        // Add a delay to allow for the viewer to be destroyed properly
        // before removing it due to visibility rules in the template
        setTimeout(() => {
            this.imgSrc = undefined;
        }, 0);
    }
    showHideDetailedData() {
        this.isDetailedDataShowed = !this.isDetailedDataShowed;
        this.changeDetectorRef.detectChanges();
        this.resetViewer();
    }
    closeDetailedData() {
        this.isDetailShowed = false;
        this.closeDetail.next(true);
    }
    // Emits the action on this ResultDetailedItem to the parent (ResultList)
    triggerActionOnItem(actionOnItem) {
        this.actionOnItemEvent.next(actionOnItem);
    }
    showOverlay() {
        this.isFullScreen = true;
        this.resetViewer();
        let viewerContainer;
        const fullScreenContainer = document.querySelector('.iv-fullscreen-container');
        const actionsInfos = document.getElementsByClassName('viewer_actions-infos');
        if (!!actionsInfos && !!actionsInfos[0]) {
            viewerContainer = actionsInfos[0].parentElement;
            const elements = actionsInfos.length;
            for (let i = 0; i < elements; i++) {
                // The element is removed from the list once retrieved
                fullScreenContainer.appendChild(actionsInfos.item(0));
            }
        }
        document.querySelector('.iv-fullscreen-close').addEventListener('click', () => {
            this.isFullScreen = false;
            if (viewerContainer) {
                const actionsInfosFullScreen = fullScreenContainer.getElementsByClassName('viewer_actions-infos');
                const elements = actionsInfosFullScreen.length;
                for (let i = 0; i < elements; i++) {
                    // The element is removed from the list once retrieved
                    viewerContainer.appendChild(actionsInfosFullScreen.item(0));
                }
            }
            this.resetViewer();
        });
    }
    onPrevious() {
        this.currentImageIndex -= 1;
        if (this.currentImageIndex < 0) {
            this.currentImageIndex = this.gridTile.urlImages.length - 1;
        }
        this.getImage();
    }
    onNext() {
        this.currentImageIndex += 1;
        if (this.currentImageIndex >= this.gridTile.urlImages.length) {
            this.currentImageIndex = 0;
        }
        this.getImage();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultDetailedGridComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i2$2.HttpClient }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ResultDetailedGridComponent, selector: "arlas-result-detailed-grid", inputs: { gridTile: "gridTile", detailWidth: "detailWidth", detailHeight: "detailHeight", idFieldName: "idFieldName", isDetailShowed: "isDetailShowed", showEmptyGroup: "showEmptyGroup", useHttp: "useHttp", activatedActionsPerItem: "activatedActionsPerItem", detailedDataRetriever: "detailedDataRetriever" }, outputs: { actionOnItemEvent: "actionOnItemEvent", closeDetail: "closeDetail" }, viewQueries: [{ propertyName: "imageViewer", first: true, predicate: ["image_detail"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"resultgrid\" *ngIf=isDetailShowed>\n  <div class=\"resultgrid--container\">\n    <div [hidden]=\"isDetailedDataShowed\">\n      <div class=\"resultgrid__img\" [style.height.px]=\"detailHeight\" [style.width.px]=\"detailWidth\">\n        <img class=\"image_view\" #image_detail *ngIf=\"gridTile.imageEnabled\" src=\"{{imgSrc}}\" (error)=\"destroyViewer()\">\n        <img *ngIf=\"(!gridTile.imageEnabled || !imgSrc) && !isLoading\" src=\"{{noViewImg}}\">\n        <mat-progress-spinner *ngIf=\"isLoading\" [color]=\"'accent'\" [diameter]=\"detailHeight < detailWidth ? detailHeight / 2 : detailWidth / 2\" [mode]=\"'indeterminate'\"></mat-progress-spinner>\n      </div>\n\n      <button mat-icon-button class=\"viewer_actions-infos navigate-button previous\" *ngIf=\"gridTile.urlImages && gridTile.urlImages.length > 1\" matTooltip=\"{{'Previous image' | translate}}\" (click)=\"onPrevious()\">\n        <mat-icon>keyboard_arrow_left</mat-icon>\n      </button>\n      <div class=\"viewer_actions-infos description\" *ngIf=\"gridTile.descriptions\">{{ gridTile.descriptions[currentImageIndex] }}</div>\n      <button mat-icon-button class=\"viewer_actions-infos navigate-button next\" *ngIf=\"gridTile.urlImages && gridTile.urlImages.length > 1\" matTooltip=\"{{'Next image' | translate}}\" (click)=\"onNext()\">\n        <mat-icon>keyboard_arrow_right</mat-icon>\n      </button>\n\n      <div class=\"resultgrid__info-button\">\n        <button [disabled]=\"!gridTile.imageEnabled || isLoading\" id=\"view_image_gridmode_btn\" matTooltip=\"{{VIEW_IMAGE | translate}}\"\n          class=\"resultgrid__info-view-button\" mat-mini-fab (click)=\"showOverlay()\">\n          <mat-icon class=\"resultgrid__info_outline\">fit_screen</mat-icon>\n        </button>\n        <button id=\"show_details_gridmode_btn\" matTooltip=\"{{SHOW_DETAILS | translate}}\" class=\"resultgrid__info-show-button\" mat-mini-fab color=\"primary\" (click)=\"showHideDetailedData()\">\n          <mat-icon class=\"resultgrid__info_outline\">info_outline</mat-icon>\n        </button>\n        <button id=\"close_details_gridmode_btn\" matTooltip=\"{{CLOSE_DETAILS | translate}}\" class=\"resultgrid__info-close-button\" mat-mini-fab color=\"primary\" (click)=\"closeDetailedData()\">\n            <mat-icon class=\"resultgrid__close\">close</mat-icon>\n        </button>\n      </div>\n    </div>\n\n    <div [hidden]=\"!isDetailedDataShowed\">\n      <div class=\"resultgrid__info-button\">\n        <button id=\"show_image_gridmode_btn\" matTooltip=\"{{SHOW_IMAGE | translate}}\" class=\"resultgrid__info-show-button\" mat-mini-fab color=\"primary\" (click)=\"showHideDetailedData()\">\n          <mat-icon class=\"resultgrid__image\">image</mat-icon>\n        </button>\n        <button id=\"close_details_gridmode_btn\" matTooltip=\"{{CLOSE_DETAILS | translate}}\" class=\"resultgrid__info-close-button\" mat-mini-fab color=\"primary\" (click)=\"closeDetailedData()\">\n          <mat-icon class=\"resultgrid__close\">close</mat-icon>\n        </button>\n      </div>\n      <div arlas-result-detailed-item class=\"resultgrid--detailed-item\"\n        [rowItem]=\"gridTile\" [containerType]=\"'grid'\" [idFieldName]=\"idFieldName\"\n        [detailedDataRetriever]=\"detailedDataRetriever\"\n        [activatedActionsPerItem]=\"activatedActionsPerItem\"\n        [style.width.px]=\"detailWidth\" [style.height.px]=\"detailHeight\"\n        [showEmptyGroup]= \"showEmptyGroup\" (actionOnItemEvent)=\"triggerActionOnItem($event)\">\n      </div>\n    </div>\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.resultgrid__img{overflow-y:hidden;overflow-x:hidden;text-align:center;vertical-align:middle;background-color:#000;display:flex;justify-content:center;align-items:center}.viewer_actions-infos{position:absolute;bottom:5px;z-index:999}.viewer_actions-infos.description{color:#fff;background-color:#6d6d6d99;padding:0 5px;left:50%;transform:translate(-50%)}.viewer_actions-infos.navigate-button{height:24px;width:24px;background-color:#fff;border:1px solid #a1a1a1;border-radius:4px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0}.viewer_actions-infos.navigate-button.previous{left:5px}.viewer_actions-infos.navigate-button.next{right:5px}.viewer_actions-infos.navigate-button ::ng-deep .mat-icon{overflow:unset}.resultgrid{width:100%;height:100%;font-family:Roboto,Helvetica Neue,sans-serif;text-align:left;vertical-align:middle}.resultgrid--container{width:100%;height:100%;position:relative}.resultgrid__info-button{position:absolute;top:5px;right:0;background-color:transparent;z-index:1}.resultgrid__info-button ::ng-deep .mat-mdc-mini-fab[disabled]{color:gray}.resultgrid__info-view-button,.resultgrid__info-show-button,.resultgrid__info-close-button{top:5px;right:15px;background-color:#fff;color:#000;width:24px;height:24px;margin-right:5px}.image_view{max-height:100%;max-width:100%;cursor:pointer}.full-screen{height:100vh;width:100vw}::ng-deep .iv-image-mode{display:flex;height:100%!important;width:100%!important}::-webkit-scrollbar{width:6px;height:6px;background-color:#fff}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#fff}::-webkit-scrollbar-thumb{background-color:#555}.resultgrid__info_outline,.resultgrid__close,.resultgrid__image{font-size:20px;width:20px;height:20px}.resultgrid-overlay{width:100vw;height:100vh;position:absolute;top:0;left:0;background-color:#555;opacity:.5}\n"], dependencies: [{ kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4.MatIconButton, selector: "button[mat-icon-button]", exportAs: ["matButton"] }, { kind: "component", type: i4.MatMiniFabButton, selector: "button[mat-mini-fab]", exportAs: ["matButton"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "component", type: i6.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "component", type: ResultDetailedItemComponent, selector: "[arlas-result-detailed-item]", inputs: ["detailColspan", "idFieldName", "containerType", "rowItem", "showEmptyGroup", "detailedDataRetriever", "activatedActionsPerItem"], outputs: ["actionOnItemEvent"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultDetailedGridComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-result-detailed-grid', template: "<div class=\"resultgrid\" *ngIf=isDetailShowed>\n  <div class=\"resultgrid--container\">\n    <div [hidden]=\"isDetailedDataShowed\">\n      <div class=\"resultgrid__img\" [style.height.px]=\"detailHeight\" [style.width.px]=\"detailWidth\">\n        <img class=\"image_view\" #image_detail *ngIf=\"gridTile.imageEnabled\" src=\"{{imgSrc}}\" (error)=\"destroyViewer()\">\n        <img *ngIf=\"(!gridTile.imageEnabled || !imgSrc) && !isLoading\" src=\"{{noViewImg}}\">\n        <mat-progress-spinner *ngIf=\"isLoading\" [color]=\"'accent'\" [diameter]=\"detailHeight < detailWidth ? detailHeight / 2 : detailWidth / 2\" [mode]=\"'indeterminate'\"></mat-progress-spinner>\n      </div>\n\n      <button mat-icon-button class=\"viewer_actions-infos navigate-button previous\" *ngIf=\"gridTile.urlImages && gridTile.urlImages.length > 1\" matTooltip=\"{{'Previous image' | translate}}\" (click)=\"onPrevious()\">\n        <mat-icon>keyboard_arrow_left</mat-icon>\n      </button>\n      <div class=\"viewer_actions-infos description\" *ngIf=\"gridTile.descriptions\">{{ gridTile.descriptions[currentImageIndex] }}</div>\n      <button mat-icon-button class=\"viewer_actions-infos navigate-button next\" *ngIf=\"gridTile.urlImages && gridTile.urlImages.length > 1\" matTooltip=\"{{'Next image' | translate}}\" (click)=\"onNext()\">\n        <mat-icon>keyboard_arrow_right</mat-icon>\n      </button>\n\n      <div class=\"resultgrid__info-button\">\n        <button [disabled]=\"!gridTile.imageEnabled || isLoading\" id=\"view_image_gridmode_btn\" matTooltip=\"{{VIEW_IMAGE | translate}}\"\n          class=\"resultgrid__info-view-button\" mat-mini-fab (click)=\"showOverlay()\">\n          <mat-icon class=\"resultgrid__info_outline\">fit_screen</mat-icon>\n        </button>\n        <button id=\"show_details_gridmode_btn\" matTooltip=\"{{SHOW_DETAILS | translate}}\" class=\"resultgrid__info-show-button\" mat-mini-fab color=\"primary\" (click)=\"showHideDetailedData()\">\n          <mat-icon class=\"resultgrid__info_outline\">info_outline</mat-icon>\n        </button>\n        <button id=\"close_details_gridmode_btn\" matTooltip=\"{{CLOSE_DETAILS | translate}}\" class=\"resultgrid__info-close-button\" mat-mini-fab color=\"primary\" (click)=\"closeDetailedData()\">\n            <mat-icon class=\"resultgrid__close\">close</mat-icon>\n        </button>\n      </div>\n    </div>\n\n    <div [hidden]=\"!isDetailedDataShowed\">\n      <div class=\"resultgrid__info-button\">\n        <button id=\"show_image_gridmode_btn\" matTooltip=\"{{SHOW_IMAGE | translate}}\" class=\"resultgrid__info-show-button\" mat-mini-fab color=\"primary\" (click)=\"showHideDetailedData()\">\n          <mat-icon class=\"resultgrid__image\">image</mat-icon>\n        </button>\n        <button id=\"close_details_gridmode_btn\" matTooltip=\"{{CLOSE_DETAILS | translate}}\" class=\"resultgrid__info-close-button\" mat-mini-fab color=\"primary\" (click)=\"closeDetailedData()\">\n          <mat-icon class=\"resultgrid__close\">close</mat-icon>\n        </button>\n      </div>\n      <div arlas-result-detailed-item class=\"resultgrid--detailed-item\"\n        [rowItem]=\"gridTile\" [containerType]=\"'grid'\" [idFieldName]=\"idFieldName\"\n        [detailedDataRetriever]=\"detailedDataRetriever\"\n        [activatedActionsPerItem]=\"activatedActionsPerItem\"\n        [style.width.px]=\"detailWidth\" [style.height.px]=\"detailHeight\"\n        [showEmptyGroup]= \"showEmptyGroup\" (actionOnItemEvent)=\"triggerActionOnItem($event)\">\n      </div>\n    </div>\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.resultgrid__img{overflow-y:hidden;overflow-x:hidden;text-align:center;vertical-align:middle;background-color:#000;display:flex;justify-content:center;align-items:center}.viewer_actions-infos{position:absolute;bottom:5px;z-index:999}.viewer_actions-infos.description{color:#fff;background-color:#6d6d6d99;padding:0 5px;left:50%;transform:translate(-50%)}.viewer_actions-infos.navigate-button{height:24px;width:24px;background-color:#fff;border:1px solid #a1a1a1;border-radius:4px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0}.viewer_actions-infos.navigate-button.previous{left:5px}.viewer_actions-infos.navigate-button.next{right:5px}.viewer_actions-infos.navigate-button ::ng-deep .mat-icon{overflow:unset}.resultgrid{width:100%;height:100%;font-family:Roboto,Helvetica Neue,sans-serif;text-align:left;vertical-align:middle}.resultgrid--container{width:100%;height:100%;position:relative}.resultgrid__info-button{position:absolute;top:5px;right:0;background-color:transparent;z-index:1}.resultgrid__info-button ::ng-deep .mat-mdc-mini-fab[disabled]{color:gray}.resultgrid__info-view-button,.resultgrid__info-show-button,.resultgrid__info-close-button{top:5px;right:15px;background-color:#fff;color:#000;width:24px;height:24px;margin-right:5px}.image_view{max-height:100%;max-width:100%;cursor:pointer}.full-screen{height:100vh;width:100vw}::ng-deep .iv-image-mode{display:flex;height:100%!important;width:100%!important}::-webkit-scrollbar{width:6px;height:6px;background-color:#fff}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#fff}::-webkit-scrollbar-thumb{background-color:#555}.resultgrid__info_outline,.resultgrid__close,.resultgrid__image{font-size:20px;width:20px;height:20px}.resultgrid-overlay{width:100vw;height:100vh;position:absolute;top:0;left:0;background-color:#555;opacity:.5}\n"] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i2$2.HttpClient }], propDecorators: { gridTile: [{
                type: Input
            }], detailWidth: [{
                type: Input
            }], detailHeight: [{
                type: Input
            }], idFieldName: [{
                type: Input
            }], isDetailShowed: [{
                type: Input
            }], showEmptyGroup: [{
                type: Input
            }], useHttp: [{
                type: Input
            }], activatedActionsPerItem: [{
                type: Input
            }], detailedDataRetriever: [{
                type: Input
            }], actionOnItemEvent: [{
                type: Output
            }], closeDetail: [{
                type: Output
            }], imageViewer: [{
                type: ViewChild,
                args: ['image_detail', { static: false }]
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultFilterComponent {
    constructor() {
        /**
         * @Input
         * @description A map of columns to filter : key = column (or field) name & value = field value.
         * This components sets directly this map.
         */
        this.filtersMap = new Map();
        /**
         * @Input
         * @description The values of dropdown list.
         */
        this.dropdownValues = new Array();
        /**
         * @Output
         * @description Emits the map of filtered columns and the filters values (fieldName-fieldValue map).
         */
        this.setFiltersEvent = new Subject();
        /**
         * @Output
         * @description Emits the column on change to notify the main component.
         */
        this.columnChanged = new Subject();
        this.selected = new Array();
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (changes['filtersMap'] !== undefined) {
            if (changes['filtersMap'].currentValue !== undefined) {
                if (changes['filtersMap'].currentValue !== changes['filtersMap'].previousValue) {
                    if (changes['filtersMap'].currentValue.get(this.column.fieldName) !== undefined) {
                        if (this.inputValue !== changes['filtersMap'].currentValue.get(this.column.fieldName)) {
                            this.inputValue = changes['filtersMap'].currentValue.get(this.column.fieldName);
                            this.selected = new Array();
                            this.inputValue.split(',').forEach(v => this.selected.push(v));
                        }
                    }
                    else {
                        this.inputValue = '';
                        this.selected = new Array();
                    }
                }
            }
        }
    }
    setFilterOnKeyEnter(event) {
        event.target.blur();
    }
    // Update the map of the filtered fields. If a filter is empty, the correspondant field is removed from the map
    setFilter() {
        if (this.inputValue === undefined || this.inputValue === '' || this.inputValue === null) {
            if (this.filtersMap.has(this.column.fieldName)) {
                this.filtersMap.delete(this.column.fieldName);
                this.setFiltersEvent.next(this.filtersMap);
                this.columnChanged.next(this.column);
            }
        }
        else {
            this.filtersMap.set(this.column.fieldName, this.inputValue);
            this.setFiltersEvent.next(this.filtersMap);
            this.columnChanged.next(this.column);
        }
    }
    selectionChange(event) {
        if (event.value.length > 0) {
            this.filtersMap.set(event.source.id, event.value.join(','));
            this.setFiltersEvent.next(this.filtersMap);
            this.columnChanged.next(this.column);
        }
        else {
            if (this.filtersMap.has(event.source.id)) {
                this.filtersMap.delete(event.source.id);
                this.setFiltersEvent.next(this.filtersMap);
                this.columnChanged.next(this.column);
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultFilterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: ResultFilterComponent, selector: "[arlas-result-filter]", inputs: { column: "column", filtersMap: "filtersMap", inputValue: "inputValue", dropdownValues: "dropdownValues" }, outputs: { setFiltersEvent: "setFiltersEvent", columnChanged: "columnChanged" }, usesOnChanges: true, ngImport: i0, template: "<input *ngIf=\"!column?.isIdField&&(dropdownValues?.length==0||dropdownValues==null)\" type=\"text\" class=\"form-control resultlist__header--filters resultlist__header--filters__{{column?.fieldName}}\" (blur)=\"setFilter()\" (keyup.enter)=\"setFilterOnKeyEnter($event)\"\n    [(ngModel)]=\"inputValue\">\n\n<mat-form-field *ngIf=\"!column?.isIdField&&dropdownValues?.length>0\" \n    class=\"form-control resultlist__header--filters resultlist__header--filters--dropdown resultlist__header--filters__{{column?.fieldName}}\" \n    [style.width.px]=\"column?.width-10\">\n    <mat-select [id]=\"column?.fieldName\" placeholder=\"\"  multiple class=\"resultlist__dropdown-select\" [style.width.px]=\"column?.width-20\" (selectionChange)=\"selectionChange($event)\" [value]=\"selected\">\n        <mat-option  class=\"resultlist__dropdown-option\" *ngFor=\"let value of dropdownValues\"  [value]=\"value\">{{value}}</mat-option>\n    </mat-select>\n</mat-form-field>\n", styles: [".resultlist__header--filters{margin:0}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$2.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "component", type: i10.MatSelect, selector: "mat-select", inputs: ["aria-describedby", "panelClass", "disabled", "disableRipple", "tabIndex", "hideSingleSelectionIndicator", "placeholder", "required", "multiple", "disableOptionCentering", "compareWith", "value", "aria-label", "aria-labelledby", "errorStateMatcher", "typeaheadDebounceInterval", "sortComparator", "id", "panelWidth"], outputs: ["openedChange", "opened", "closed", "selectionChange", "valueChange"], exportAs: ["matSelect"] }, { kind: "component", type: i4$3.MatOption, selector: "mat-option", inputs: ["value", "id", "disabled"], outputs: ["onSelectionChange"], exportAs: ["matOption"] }, { kind: "directive", type: i9.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i9.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i9.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultFilterComponent, decorators: [{
            type: Component,
            args: [{ selector: '[arlas-result-filter]', template: "<input *ngIf=\"!column?.isIdField&&(dropdownValues?.length==0||dropdownValues==null)\" type=\"text\" class=\"form-control resultlist__header--filters resultlist__header--filters__{{column?.fieldName}}\" (blur)=\"setFilter()\" (keyup.enter)=\"setFilterOnKeyEnter($event)\"\n    [(ngModel)]=\"inputValue\">\n\n<mat-form-field *ngIf=\"!column?.isIdField&&dropdownValues?.length>0\" \n    class=\"form-control resultlist__header--filters resultlist__header--filters--dropdown resultlist__header--filters__{{column?.fieldName}}\" \n    [style.width.px]=\"column?.width-10\">\n    <mat-select [id]=\"column?.fieldName\" placeholder=\"\"  multiple class=\"resultlist__dropdown-select\" [style.width.px]=\"column?.width-20\" (selectionChange)=\"selectionChange($event)\" [value]=\"selected\">\n        <mat-option  class=\"resultlist__dropdown-option\" *ngFor=\"let value of dropdownValues\"  [value]=\"value\">{{value}}</mat-option>\n    </mat-select>\n</mat-form-field>\n", styles: [".resultlist__header--filters{margin:0}\n"] }]
        }], ctorParameters: () => [], propDecorators: { column: [{
                type: Input
            }], filtersMap: [{
                type: Input
            }], inputValue: [{
                type: Input
            }], dropdownValues: [{
                type: Input
            }], setFiltersEvent: [{
                type: Output
            }], columnChanged: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultScrollDirective {
    constructor(el) {
        this.el = el;
        this.nextDataEvent = new Subject();
        this.previousDataEvent = new Subject();
        this.visibleItems = new Subject();
        this.lastScrollTop = 0;
        this.previousFirstId = null;
        this.previousLastId = null;
        this.scrolledProgramatically = false;
    }
    ngOnChanges(changes) {
        if (changes['items']) {
            /** New data is loaded : we reset all the variables */
            this.lastScrollTop = 0;
            this.previousFirstId = null;
            this.previousLastId = null;
            /** Repositioning the scroll bar to the top*/
            this.el.nativeElement.scrollTop = 0;
        }
        if (changes['resultMode']) {
            this.adjustScrollToMode();
        }
        if (changes['scrollOptions']) {
            if (this.scrollOptions.maintainScrollUpPosition === true && this.items) {
                /**
                 * Maintains the scroll position after loading rows in the top of the list
                 */
                this.el.nativeElement.scrollTop = this.el.nativeElement.scrollHeight * this.scrollOptions.nbLines / this.items.length;
            }
            if (this.scrollOptions.maintainScrollDownPosition === true && this.items) {
                /**
                 * Maintains the scroll position after loading rows in the bottom of the list
                 */
                this.el.nativeElement.scrollTop = this.el.nativeElement.scrollHeight -
                    this.el.nativeElement.scrollHeight * this.scrollOptions.nbLines / this.items.length - this.tbodyHeight / 2;
            }
        }
    }
    /** This method allows to stay around the same items when switching the mode grid/list */
    adjustScrollToMode() {
        if (this.items) {
            if (this.resultMode === ModeEnum.grid) {
                this.nbScrolledLines = Math.round(this.top / this.height * this.items.length);
                if (this.nbScrolledLines % this.nbGridColumns !== 0) {
                    this.nbScrolledLines = Math.max(this.nbScrolledLines - this.nbScrolledLines % this.nbGridColumns, 0);
                }
            }
            else {
                this.nbScrolledLines = Math.round(this.top / this.height * this.items.length);
            }
            this.triggerScrollEvent();
        }
    }
    // When scrolling, the position of the scroll bar is calculated
    // Loading the previous/next data is triggered when [nbEndScrollItems] items are left while scrolling up/down respectively
    onScroll(event) {
        this.tbodyHeight = this.el.nativeElement.offsetHeight;
        const scrollTop = this.el.nativeElement.scrollTop;
        const scrollHeight = this.el.nativeElement.scrollHeight;
        const nLastLines = this.nbLinesBeforeFetch / ((this.nbGridColumns - 1) * this.resultMode + 1);
        const dataLength = this.items.length / ((this.nbGridColumns - 1) * this.resultMode + 1);
        const downPositionTrigger = scrollHeight * (1 - nLastLines / dataLength - this.tbodyHeight / scrollHeight);
        const upPositionTrigger = scrollHeight * nLastLines / dataLength;
        if (this.scrolledProgramatically) {
            this.el.nativeElement.scrollTop = scrollHeight * this.nbScrolledLines / this.items.length;
            this.scrolledProgramatically = false;
        }
        this.top = scrollTop;
        this.height = scrollHeight;
        if (this.previousFirstId) {
            if (this.previousFirstId !== this.items[0].identifier || (this.fetchState && this.fetchState.endListDown)) {
                this.previousFirstId = null;
            }
        }
        if (this.previousLastId) {
            if (this.previousLastId !== this.items[this.items.length - 1].identifier || (this.fetchState && this.fetchState.endListUp)) {
                this.previousLastId = null;
            }
        }
        if (scrollTop >= downPositionTrigger && this.isScrollingDown(scrollTop)) {
            /** The following condition answers the question : when should I stop emitting `nextDataEvent` even if i reach the end of the scroll?
             * The answer is: when `nextDataEvent` is emitted and there is no new items loaded.
             * In other words if `downPositionTrigger` is reached and the last identifier we remember
             * from the previous scoll is different from the actual last identifer,
             * it means `nextDataEvent` still can be emitted
            **/
            if (this.items.length > 0 && this.items[this.items.length - 1].identifier !== this.previousLastId && this.fetchState
                && !this.fetchState.endListDown) {
                this.previousLastId = this.items[this.items.length - 1].identifier;
                this.previousFirstId = this.items[0].identifier;
                this.nextDataEvent.next(this.items[this.items.length - 1].itemData);
            }
        }
        if (scrollTop <= upPositionTrigger && this.isScrollingUp(scrollTop)) {
            /** Same logic as the condition above but on the top of the list this time. */
            if (this.items.length > 0 && this.items[0].identifier !== this.previousFirstId && this.fetchState && !this.fetchState.endListUp) {
                this.previousFirstId = this.items[0].identifier;
                this.previousLastId = this.items[this.items.length - 1].identifier;
                this.previousDataEvent.next(this.items[0].itemData);
            }
        }
        this.lastScrollTop = this.el.nativeElement.scrollTop;
        this.visibleItems.next(this.items.filter(i => this.isElementInViewport(document.getElementById(i.identifier))));
    }
    isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        return (rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth));
    }
    isScrollingDown(scrollTop) {
        if (scrollTop > this.lastScrollTop) {
            return true;
        }
    }
    isScrollingUp(scrollTop) {
        if (scrollTop < this.lastScrollTop) {
            return true;
        }
    }
    triggerScrollEvent() {
        this.scrolledProgramatically = true;
        this.el.nativeElement.scrollTop = 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultScrollDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: ResultScrollDirective, selector: "[arlasResultScroll]", inputs: { items: "items", nbLinesBeforeFetch: "nbLinesBeforeFetch", nbGridColumns: "nbGridColumns", resultMode: "resultMode", fetchState: "fetchState", scrollOptions: "scrollOptions" }, outputs: { nextDataEvent: "nextDataEvent", previousDataEvent: "previousDataEvent", visibleItems: "visibleItems" }, host: { listeners: { "scroll": "onScroll($event)" } }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultScrollDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[arlasResultScroll]',
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { items: [{
                type: Input
            }], nbLinesBeforeFetch: [{
                type: Input
            }], nbGridColumns: [{
                type: Input
            }], resultMode: [{
                type: Input
            }], fetchState: [{
                type: Input
            }], scrollOptions: [{
                type: Input
            }], nextDataEvent: [{
                type: Output
            }], previousDataEvent: [{
                type: Output
            }], visibleItems: [{
                type: Output
            }], onScroll: [{
                type: HostListener,
                args: ['scroll', ['$event']]
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * ResultList component allows to structure data in a filterable and sortable table.
 * Items can be represented as rows or grids and are multi-selectable.
 * For both list and grid modes, each item has detailed data that can be displayed in a togglable space.
 */
class ResultListComponent {
    constructor(iterableRowsDiffer, iterableColumnsDiffer, el, colorService, translate, notifier, cdr) {
        this.el = el;
        this.colorService = colorService;
        this.translate = translate;
        this.notifier = notifier;
        this.cdr = cdr;
        /**
         * @constant
         */
        this.GEO_DISTANCE = 'geodistance';
        /**
         * @constant
         */
        this.FILTER_ON = marker('Filter on');
        /**
         * @constant
         */
        this.GLOBAL_ACTIONS = marker('Global actions');
        /**
         * @constant
         */
        this.GEOSORT_ACTION = marker('Geo sort action');
        /**
         * @constant
         */
        this.GRID_MODE = marker('Grid mode');
        /**
         * @constant
         */
        this.LIST_MODE = marker('List mode');
        /**
         * @constant
         */
        this.CONTAIN_FIT = marker('Fit the whole thumbnail to the tile');
        /**
         * @constant
         */
        this.WIDTH_FIT = marker('Fit the thumbnail\'s width to the tile');
        /**
         * @constant
         */
        this.HEIGHT_FIT = marker('Fit the thumbnail\'s height to the tile');
        /**
         * @constant
         */
        this.GEOSORT_BUTTON = marker('Geo-sort');
        /**
         * @constant
         */
        this.COLUMN_ACTIONS_HEIGHT = 52;
        /**
         * @constant
         */
        this.COLUMN_NAME_HEIGHT = 27;
        /**
         * @constant
         */
        this.FILTERS_HEIGHT = 50;
        /**
         * @constant
         */
        this.TAIL_HEIGHT = 30;
        this.loadAnimationConfig = {
            animationType: ngxLoadingAnimationTypes.threeBounce, backdropBackgroundColour: 'rgba(100,100,100,0.5)',
            backdropBorderRadius: '0', primaryColour: '#ffffff', secondaryColour: '#ffffff', tertiaryColour: '#ffffff'
        };
        this.scrollOptions = { maintainScrollUpPosition: true, maintainScrollDownPosition: true, nbLines: 0 };
        this.fetchState = { endListUp: true, endListDown: false };
        /**
         * @Input : Angular
         * @description The table width. If not specified, the tableWidth value is
         * equal to container width.
         */
        this.tableWidth = null;
        /**
         * @Input : Angular
         * @description The number of items left on the list/grid when scrolling up or down upon which loading new data is triggered.
         * When scrolling up or down, once there is `nbLinesBeforeFetch` items left at the top or bottom of the list, previous/next
         * data is loaded.
        */
        this.nbLinesBeforeFetch = 5;
        /**
         * @Input : Angular
         * @description Height of the detail grid div (Grid Mode).
         */
        this.detailedGridHeight = 300;
        /**
         * @Input : Angular
         * @description Number of grid columns (Grid Mode).
         */
        this.nbGridColumns = 4;
        /**
         * @Input : Angular
         * @description List of actions to apply on the selected items.
         */
        this.globalActionsList = new Array();
        /**
         * @Input : Angular
         * @description A detailed-data-retriever object that implements
         * DetailedDataRetriever interface.
         */
        this.detailedDataRetriever = null;
        /**
         * @Input : Angular
         * @description List of items ids that are in a indeterminated status.
         */
        this.indeterminatedItems = new Set();
        /**
         * @Input : Angular
         * @description List of items ids that are in a selected status.
        */
        this.selectedItems = new Set();
        /**
         * @Input : Angular
         * @description Map <itemId, Set<actionIds>> : for each item, gives the list of activated actions.
        */
        this.activatedActionsPerItem = new Map();
        /**
         * @Input : Angular
         * @description List of items ids to be highlighted.
         */
        this.highlightItems = new Set();
        /**
         * @Input : Angular
         * @description Whether filters on list are displayed.
         */
        this.displayFilters = true;
        /**
         * @Input : Angular
         * @description Whether the sort on the geometry is enabled.
         */
        this.isGeoSortEnabled = false;
        /**
         * @Input : Angular
         * @description Whether the sort on the geometry is activated
         */
        this.isGeoSortActivated = false;
        /**
         * @Input : Angular
         * @description A  boolean to show or hide thead of table
         */
        this.displayThead = true;
        /**
         * @Input : Angular
         * @description Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a
         * factor (between 0 and 1) that tightens this scale to [(1-colorsSaturationWeight), 1].
         * Therefore saturation of generated colors will be within this tightened scale..
         */
        this.colorsSaturationWeight = 1 / 2;
        /**
         * @Input : Angular
         * @description Whether to allow colorizing cells and the grid tile of the list.
         */
        this.useColorService = false;
        /**
         * @Input : Angular
          * @description The way the cell will be colorized: filled or outlined
         */
        this.cellBackgroundStyle = CellBackgroundStyleEnum.filled;
        /**
         * @Input
         * @description Whether display group with no detail.
         */
        this.showEmptyGroup = false;
        /**
         * @Input
         * @description Whether display the detailled part in grid mode.
         */
        this.isDetailledGridOpen = false;
        /**
         * @Input
         * @description How to fit the thumbnail to the tile:
         * - `height` fit the height of the thumbnail.
         * - `width` fit the width of the thumbnail.
         * - `contain` fit the wholethumbnail.
         */
        this.thumbnailFit = ThumbnailFitEnum.contain;
        /**
         * @Output : Angular
         * @description Emits the event of sorting data on the specified column.
         */
        this.sortColumnEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the event of geo-sorting data.
         */
        this.geoSortEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the event of geo-sorting data.
         */
        this.geoAutoSortEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the list of items identifiers whose checkboxes are selected.
         */
        this.selectedItemsEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits one item identifier that is hovered..
         */
        this.consultedItemEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the item that is clicked on.
         */
        this.clickOnItemEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the filtred fields map (fieldName-fieldValue map).
         */
        this.setFiltersEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the request of more data to load. The emitted number is the number of times this event has been emitted.
         * @deprecated moreDataEvent can be replaced by `paginationEvent`
         */
        this.moreDataEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the request of a new page to load.
         * The emitted PageQuery contains the reference item from which the new page is loaded
         * and whether it is the previous or the next page.
         */
        this.paginationEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the event of applying the specified action on the specified item.
         */
        this.actionOnItemEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the event of applying the specified globalb action on the selected items.
         */
        this.globalActionEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits the event of applying the specified global action on the selected items.
         */
        this.columnFilterChanged = new Subject();
        /**
         * @Output : Angular
         * @description Emits the event of clicking on a grid tile.
         */
        this.clickOnTile = new Subject();
        /**
         * @Output : Angular
         * @description Emits the event of clicking on the switch mode button. Emits the new mode (grid or list).
         */
        this.changeResultMode = new Subject();
        /**
         * @Output : Angular
         * @description Emits the current visible items in the viewport.
         */
        this.visibleItems = new Subject();
        /**
        * @Output : Angular
        * @description Emits on changes rowItemList current value.
        */
        this.onChangeItems = new Subject();
        /**
         * @Output : Angular
         * @description Emits when changing how thumbnails fit in their div.
         */
        this.thumbnailFitEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits when result list is updated.
         */
        this.onResultListUpdate = new EventEmitter();
        /**
         * @Output : Angular
         * @description Emits when the list is ready.
         */
        this.onListLoaded = new EventEmitter();
        this.items = new Array();
        this.sortedColumn = { columnName: '', fieldName: '', sortDirection: SortEnum.asc };
        // Heights of table elements
        this.tbodyHeight = null;
        this.theadHeight = null;
        this.ModeEnum = ModeEnum;
        this.ThumbnailFitEnum = ThumbnailFitEnum;
        this.PageEnum = PageEnum;
        this.SortEnum = SortEnum;
        this.isNextPageRequested = false;
        this.isPreviousPageRequested = false;
        this.hasGridMode = false;
        this.allItemsChecked = false;
        this.borderStyle = 'solid';
        this.displayListGrid = 'inline';
        this.isShiftDown = false;
        this.debouncer = new Subject();
        this.scrollDebouncer = new Subject();
        this.emitVisibleItemsDebouncer = new Subject();
        this.iterableRowsDiffer = iterableRowsDiffer.find([]).create(null);
        this.iterableColumnsDiffer = iterableColumnsDiffer.find([]).create(null);
        // Resize the table height on window resize
        fromEvent(window, 'resize')
            .pipe(debounceTime(500))
            .subscribe((event) => {
            this.setTableHeight();
        });
        // Add debounce on hover item list
        this.debouncer.pipe(debounceTime(500)).subscribe(elementidentifier => this.consultedItemEvent.next(elementidentifier));
        this.scrollDebouncer.pipe(debounceTime(1000)).subscribe(page => this.paginationEvent.next(page));
        this.emitVisibleItemsDebouncer.pipe(debounceTime(1000)).subscribe(event => this.visibleItems.next(event));
    }
    shiftDown(_) {
        this.isShiftDown = true;
    }
    shiftUp(event) {
        this.isShiftDown = false;
    }
    ngOnInit() {
        this.resultMode = (this.defautMode && (this.defautMode.toString() === 'grid' ||
            this.defautMode.toString() === ModeEnum.grid.toString())) ? ModeEnum.grid : ModeEnum.list;
        this.options = Object.assign(new ResultListOptions(), this.options);
        if (!!this.fieldsConfiguration) {
            if (this.fieldsConfiguration.urlThumbnailTemplate !== undefined) {
                this.hasGridMode = true;
            }
        }
    }
    ngAfterViewInit() {
        this.onListLoaded.next(true);
        this.setTableWidth();
        this.setTableHeight();
    }
    emitThumbnailsFitStatus(fitChange) {
        this.thumbnailFit = ThumbnailFitEnum[fitChange.value];
        this.thumbnailFitEvent.next(this.thumbnailFit);
    }
    ngOnChanges(changes) {
        if (changes['defautMode'] !== undefined) {
            if (this.defautMode.toString() === 'grid' || this.defautMode.toString() === ModeEnum.grid.toString()) {
                this.resultMode = ModeEnum.grid;
                this.displayListGrid = 'block';
            }
            else {
                this.resultMode = ModeEnum.list;
                this.displayListGrid = 'inline';
            }
            this.setTableHeight();
        }
        if (changes['rowItemList'] !== undefined) {
            this.items = [];
            // Reset selected items when data change (ie a filter is applied/removed or pagination occur)
            this.selectedItems = new Set();
            this.isPreviousPageRequested = false;
            // If the selected item is not in the current list of items, close the detail
            const selectedItemInData = !!this.selectedGridItem && this.rowItemList
                .map(item => item.get(this.fieldsConfiguration.idFieldName))
                .includes(this.selectedGridItem.identifier);
            if (!(!!changes['rowItemList'].currentValue && selectedItemInData)) {
                this.closeDetail(true);
            }
            this.onChangeItems.next(changes['rowItemList'].currentValue);
        }
        if (changes['isDetailledGridOpen'] !== undefined) {
            this.isDetailledGridOpen = changes['isDetailledGridOpen'].currentValue;
        }
        if (changes['indeterminatedItems'] !== undefined) {
            this.items.forEach(item => {
                item.isindeterminated = false;
                this.indeterminatedItems.forEach(id => {
                    if (item.identifier === id && !this.selectedItems.has(id)) {
                        item.isindeterminated = true;
                    }
                });
            });
        }
        if (changes['selectedItems'] !== undefined) {
            this.items.forEach(item => {
                item.isChecked = false;
                this.selectedItems.forEach(id => {
                    if (item.identifier === id) {
                        item.isChecked = true;
                    }
                });
            });
            this.setSelectedItems(this.selectedItems);
        }
        if (changes['highlightItems'] !== undefined) {
            if (this.highlightItems.size > 0) {
                this.items.forEach(item => {
                    if (this.highlightItems.has(item.identifier)) {
                        item.ishighLight = true;
                    }
                    else {
                        item.ishighLight = false;
                    }
                });
            }
            else {
                this.items.forEach(item => {
                    item.ishighLight = undefined;
                });
            }
        }
        if (changes['fetchState'] !== undefined) {
            if (this.fetchState && this.fetchState.endListUp) {
                this.isPreviousPageRequested = false;
            }
            if (this.fetchState && this.fetchState.endListDown) {
                this.isNextPageRequested = false;
            }
        }
        if (changes['currentSortedColumn'] !== undefined && changes['currentSortedColumn'].currentValue) {
            this.sortedColumn = {
                columnName: changes['currentSortedColumn'].currentValue.columnName,
                fieldName: changes['currentSortedColumn'].currentValue.fieldName,
                sortDirection: changes['currentSortedColumn'].currentValue.sortDirection
            };
        }
    }
    ngDoCheck() {
        const columnChanges = this.iterableColumnsDiffer.diff(this.fieldsList);
        const itemChanges = this.iterableRowsDiffer.diff(this.rowItemList);
        if (columnChanges) {
            this.setColumns();
        }
        if (itemChanges) {
            let itemIndex = 0;
            itemChanges.forEachAddedItem(i => {
                this.onAddItems(i.item, this.isPreviousPageRequested, itemIndex);
                itemIndex++;
            });
            itemChanges.forEachRemovedItem(i => {
                if (this.isNextPageRequested) {
                    this.items.splice(0, 1);
                }
                else if (this.isPreviousPageRequested) {
                    this.items.splice(this.items.length - 1, 1);
                }
            });
            /**
             * This variable notifies the ResultScrollDirective whether the end of list is reached at top or bottom
             */
            if (this.isPreviousPageRequested) {
                /**
                 * This variable is set and given as an input to the `ResultScrollDirective`.
                 * The objective of this input is to inform `ResultScrollDirective` that it should
                 * maintain the Scroll Position when Adding Content to the top of the list
                 */
                this.scrollOptions = { maintainScrollUpPosition: true, maintainScrollDownPosition: false, nbLines: itemIndex };
            }
            if (this.isNextPageRequested) {
                /**
                 * This variable is set and given as an input to the `ResultScrollDirective`.
                 * The objective of this input is to inform `ResultScrollDirective` that it should
                 * maintain the Scroll Position when Adding Content to the bottom of the list
                 */
                this.scrollOptions = { maintainScrollUpPosition: false, maintainScrollDownPosition: true, nbLines: itemIndex };
            }
            this.setSelectedItems(this.selectedItems);
            this.isNextPageRequested = false;
            this.isPreviousPageRequested = false;
            this.onResultListUpdate.emit(true);
        }
    }
    emitVisibleItems(items) {
        this.emitVisibleItemsDebouncer.next(items);
    }
    /**
     * @description Emits the event of asking for next or previous page of items
     * @param referenceIdentifier : item identifier used as reference to fetch the next/previous page
     * @param whichPage : Whether to fetch the `next` or `previous` page
     */
    paginate(itemData, whichPage) {
        this.isNextPageRequested = whichPage === PageEnum.next;
        this.isPreviousPageRequested = whichPage === PageEnum.previous;
        this.scrollDebouncer.next({ reference: itemData, whichPage: whichPage });
    }
    /**
     * @description Emits which action to apply on which item/product
     */
    triggerActionOnItem(actionOnItem) {
        this.actionOnItemEvent.next(actionOnItem);
    }
    /**
     * @description Sets and emits the action to apply to all selected items
     */
    setGlobalAction(action) {
        this.globalActionEvent.next(action);
    }
    setGeoSortAction() {
        if (!this.isGeoSortActivated) {
            this.geoSort();
        }
        this.isGeoSortActivated = !this.isGeoSortActivated;
        this.geoAutoSortEvent.next(this.isGeoSortActivated);
    }
    /**
     * @description Sets and emits the [fieldName, filterValue] map of filtered fields
     */
    // Emits a map of only filtered fields
    setFilters(filtersMap) {
        this.filtersMap = filtersMap;
        this.setFiltersEvent.next(this.filtersMap);
    }
    /**
     * @description Sets and emits the identifiers list of selected items
     */
    setSelectedItems(selectedItems, stopPropagation) {
        // remove all text selection on current document
        // SB : Sometime blinking append, need to be deepened
        document.getSelection().removeAllRanges();
        this.selectedItems = selectedItems;
        if (selectedItems.size < this.items.length) {
            this.allItemsChecked = false;
        }
        else if (this.items.length !== 0) {
            this.allItemsChecked = this.items.filter(i => i.isChecked).length === this.items.length;
        }
        this.selectedItemsEvent.next(Array.from(this.selectedItems));
        if (this.isShiftDown && this.selectedItems.size > 1 && !stopPropagation) {
            this.selectInBetween();
        }
    }
    /**
     * @description Emits the column to sort on and the sort direction
     */
    sort(paramSortedColumn) {
        this.isGeoSortActivated = false;
        paramSortedColumn.sortDirection = this.sortedColumn.sortDirection;
        this.columns.forEach(column => {
            if (column.fieldName !== paramSortedColumn.fieldName) {
                column.sortDirection = SortEnum.none;
            }
        });
        this.sortColumnEvent.next(paramSortedColumn);
        // Reset direction to ASC after a clean
        if (this.sortedColumn.sortDirection === SortEnum.none) {
            this.sortedColumn.sortDirection = SortEnum.asc;
        }
    }
    setDirection(event) {
        event.stopPropagation();
        if (this.sortedColumn.sortDirection === SortEnum.asc) {
            this.sortedColumn.sortDirection = SortEnum.desc;
        }
        else {
            this.sortedColumn.sortDirection = SortEnum.asc;
        }
        this.sort(this.sortedColumn);
    }
    setSortedColumn(event) {
        if (event.value) {
            this.sortedColumn = {
                columnName: event.value.columnName,
                fieldName: event.value.fieldName,
                sortDirection: this.sortedColumn?.sortDirection ?? SortEnum.none
            };
        }
        else {
            this.sortedColumn = {
                columnName: '',
                fieldName: '',
                sortDirection: SortEnum.none
            };
        }
        this.sort(this.sortedColumn);
    }
    /**
     * @description Emits the request event of geo-sorting
     */
    geoSort() {
        this.columns.forEach(column => {
            if (!column.isIdField) {
                column.sortDirection = SortEnum.none;
            }
        });
        // Reset column filter when geo sort request
        this.sortedColumn = null;
        this.currentSortedColumn = null;
        this.geoSortEvent.next(this.GEO_DISTANCE);
    }
    /**
     * @description Sets and emits the hovered item's identifier
     */
    setConsultedItem(identifier) {
        const elementidentifier = {
            idFieldName: this.fieldsConfiguration.idFieldName,
            idValue: identifier
        };
        this.debouncer.next(elementidentifier);
    }
    /**
     * @description called on hovering an item : its sets the items actions + emits the item's identifier
     * @param item hovered item
     */
    onEnterItem(item) {
        this.setConsultedItem(item.identifier);
        this.notifier.notifyItemHover(item);
    }
    /**
     * @description called on leaving an item : emits the item's identifier
     * @param item item previously hovered
     */
    onLeaveItem(item) {
        this.setConsultedItem('leave-' + item.identifier);
    }
    /**
     * @description Called when item is clicked. It is instant compared to other events
     * @param item Item clicked on
     */
    onClickItem(item) {
        const elementidentifier = {
            idFieldName: this.fieldsConfiguration.idFieldName,
            idValue: item.identifier
        };
        this.clickOnItemEvent.next(elementidentifier);
    }
    /**
     * @description Sets the border style of rows
     */
    setBorderStyle(borderStyle) {
        this.borderStyle = borderStyle;
    }
    /**
     * @description Sets the selected grid item
     */
    setSelectedGridItem(item) {
        this.selectedGridItem = item;
        this.isDetailledGridOpen = true;
        this.setTableHeight();
        this.clickOnTile.next(item);
    }
    closeDetail(isClosed) {
        if (isClosed) {
            this.isDetailledGridOpen = false;
            this.setTableHeight();
        }
    }
    /**
     * @description Sets the display style according to the mode
     */
    whichMode(toggleChangeEvent) {
        if (toggleChangeEvent.value === ModeEnum.grid.toString()) {
            this.resultMode = ModeEnum.grid;
            this.displayListGrid = 'block';
        }
        else {
            this.resultMode = ModeEnum.list;
            this.displayListGrid = 'inline';
        }
        this.changeResultMode.next(this.resultMode);
        this.setTableHeight();
    }
    /**
     * @description Selects all the items
     */
    selectAllItems() {
        this.allItemsChecked = !this.allItemsChecked;
        this.selectedItems = new Set();
        this.items.forEach(item => {
            item.isChecked = this.allItemsChecked;
            item.isindeterminated = false;
            if (this.allItemsChecked) {
                this.selectedItems.add(item.identifier);
            }
        });
        this.setSelectedItems(this.selectedItems);
    }
    /**
     * @description Selects all the items between the farest and nearest selected items
     */
    selectInBetween() {
        const selectedItemsList = new Array();
        this.items.forEach(i => {
            if (this.selectedItems.has(i.identifier)) {
                selectedItemsList.push(i);
            }
        });
        if (selectedItemsList.length > 0) {
            const firstItem = selectedItemsList[0];
            const lastItem = selectedItemsList[selectedItemsList.length - 1];
            let inBetween = false;
            this.items.forEach(item => {
                if (item === firstItem) {
                    inBetween = true;
                }
                if (item === lastItem) {
                    inBetween = false;
                }
                if (inBetween) {
                    item.isChecked = true;
                    item.isindeterminated = false;
                    this.selectedItems.add(item.identifier);
                }
            });
            this.setSelectedItems(this.selectedItems, true);
        }
    }
    /**
     * @description Emits the column when a filter is addedd
     */
    columnChanged(colum) {
        this.columnFilterChanged.next(colum);
    }
    /**
     * @description Clear set of selection
     */
    clearSelection() {
        this.setSelectedItems(new Set());
        this.items.forEach(item => {
            item.isChecked = false;
            item.isindeterminated = false;
        });
    }
    byFieldName(item1, item2) {
        return item1 && item2 ? item1.fieldName === item2.fieldName : item1 === item2;
    }
    // Build the table's columns
    setColumns() {
        this.columns = new Array();
        const checkboxColumnWidth = 25;
        const toggleColumnWidth = 35;
        // id column is the first one and has a pre fixed width
        // It is the column where checkboxes are put
        const idColumn = new Column('', this.fieldsConfiguration.idFieldName, '');
        idColumn.isIdField = true;
        idColumn.width = checkboxColumnWidth;
        this.columns.unshift(idColumn);
        this.fieldsList.forEach(field => {
            const column = new Column(field.columnName, field.fieldName, field.dataType);
            column.width = (this.tableWidth - checkboxColumnWidth - toggleColumnWidth) / this.fieldsList.length;
            column.useColorService = field.useColorService ? field.useColorService : false;
            this.columns.push(column);
        });
        // add a column for toggle icon
        const toggleColumn = new Column('', 'toggle', '');
        toggleColumn.isToggleField = true;
        toggleColumn.width = toggleColumnWidth;
        this.columns.push(toggleColumn);
    }
    onAddItems(itemData, addOnTop, index) {
        const item = new Item(this.columns, itemData);
        item.identifier = itemData.get(this.fieldsConfiguration.idFieldName);
        if (this.fieldsConfiguration.titleFieldNames) {
            item.title = this.fieldsConfiguration.titleFieldNames
                .map(field => itemData.get(field.fieldPath + '_title'))
                .join(' ');
            if (item.title) {
                item.title = item.title.trim();
            }
        }
        if (this.useColorService && this.fieldsConfiguration.iconColorFieldName) {
            const colorFieldValue = itemData.get(this.fieldsConfiguration.iconColorFieldName + '_title');
            if (colorFieldValue) {
                item.color = this.colorService.getColor(colorFieldValue, this.keysToColors, this.colorsSaturationWeight);
            }
        }
        if (this.fieldsConfiguration.tooltipFieldNames) {
            item.tooltip = this.fieldsConfiguration.tooltipFieldNames
                .map(field => itemData.get(field.fieldPath + '_tooltip'))
                .join(' ');
            if (item.tooltip) {
                item.tooltip = item.tooltip.trim();
            }
        }
        if (this.fieldsConfiguration.icon) {
            item.icon = this.fieldsConfiguration.icon;
        }
        if (this.fieldsConfiguration.iconCssClass) {
            item.iconCssClass = itemData.get(this.fieldsConfiguration.iconCssClass);
            if (item.iconCssClass) {
                item.iconCssClass = item.iconCssClass.trim();
            }
        }
        item.imageEnabled = itemData.get('imageEnabled') === 'true';
        item.thumbnailEnabled = itemData.get('thumbnailEnabled') === 'true';
        item.detailsTitleEnabled = itemData.get('detailsTitleEnabled') === 'true';
        /** Retro-compatibility code */
        if (item.imageEnabled && this.fieldsConfiguration.urlImageTemplate) {
            item.urlImages = new Array();
            item.urlImages.push(matchAndReplace(itemData, this.fieldsConfiguration.urlImageTemplate));
        }
        /** End of retro-compatibility code */
        if (item.imageEnabled && this.fieldsConfiguration.urlImageTemplates && this.fieldsConfiguration.urlImageTemplates.length > 0) {
            item.urlImages = new Array();
            item.descriptions = new Array();
            this.fieldsConfiguration.urlImageTemplates.forEach(descUrl => {
                let condition = !descUrl.filter;
                if (descUrl.filter) {
                    const data = itemData.get(descUrl.filter.field);
                    if (Array.isArray(data)) {
                        condition = data.some(v => descUrl.filter.values.includes(v));
                    }
                    else if (data) {
                        condition = descUrl.filter.values.includes(data.toString());
                    }
                    else {
                        condition = false;
                    }
                }
                if (condition) {
                    item.urlImages.push(matchAndReplace(itemData, descUrl.url));
                    item.descriptions.push(matchAndReplace(itemData, descUrl.description));
                }
            });
        }
        if (item.thumbnailEnabled && this.fieldsConfiguration.urlThumbnailTemplate) {
            item.urlThumbnail = matchAndReplace(itemData, this.fieldsConfiguration.urlThumbnailTemplate);
        }
        if (item.detailsTitleEnabled && this.fieldsConfiguration.detailsTitleTemplate) {
            item.detailsTitle = matchAndReplace(itemData, this.fieldsConfiguration.detailsTitleTemplate);
        }
        item.position = this.items.length + 1;
        item.ishighLight = undefined;
        // When new data is loaded, check the one that were already checked +
        // remove the no longuer existing data from selectedItems (thanks to actualSelectedItems)
        if (this.allItemsChecked && (this.isNextPageRequested || this.isPreviousPageRequested)) {
            item.isChecked = true;
            this.selectedItems.add(item.identifier);
        }
        else {
            if (this.selectedItems.has(item.identifier)) {
                item.isChecked = true;
            }
            if (this.indeterminatedItems.has(item.identifier)) {
                item.isindeterminated = true;
            }
            else {
                item.isindeterminated = false;
            }
        }
        if (addOnTop) {
            this.items.splice(index, 0, item);
        }
        else {
            this.items.push(item);
        }
    }
    setTableWidth() {
        if (this.tableWidth === null) {
            const nativeElement = this.el.nativeElement;
            if (nativeElement.childNodes && nativeElement.childNodes.length > 0 && nativeElement.childNodes[0]) {
                this.tableWidth = this.el.nativeElement.childNodes[0].offsetWidth;
            }
        }
    }
    /**
     * @description Sets the table head and body height
     */
    setTableHeight(nbTrials = 0) {
        const tableElement = this.el.nativeElement.parentElement;
        if (!!tableElement && tableElement.getBoundingClientRect().height !== 0) {
            this.theadHeight = this.COLUMN_ACTIONS_HEIGHT +
                // Only in list mode
                this.COLUMN_NAME_HEIGHT * (this.resultMode === ModeEnum.list ? 1 : 0) +
                // Only if filters are present
                this.FILTERS_HEIGHT * (this.displayFilters ? 1 : 0);
            this.tbodyHeight = tableElement.getBoundingClientRect().height - this.theadHeight -
                // Only if the list is in grid mode
                this.TAIL_HEIGHT * (this.resultMode === ModeEnum.grid ? 1 : 0) -
                // Only if the list is in grid mode and has an element selected
                this.detailedGridHeight * (this.resultMode === ModeEnum.grid ? 1 : 0) * (this.isDetailledGridOpen ? 1 : 0);
            this.cdr.detectChanges();
        }
        else {
            // If the container has no height then try again for up to 10 times
            // Because of an issue with the DOM not loading properly the parent container, its height can be detected to be 0,
            // even with a preset height. Multiple tiemout values were tested, but they don't have an impact on this behavior.
            if (nbTrials < 10) {
                setTimeout(() => this.setTableHeight(nbTrials + 1), 0);
            }
            else {
                console.error('Failed to load the result list\'s height in less than 10 trials.' +
                    'Try to limit the element visibility to when it is really on screen to avoid this issue.');
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultListComponent, deps: [{ token: i0.IterableDiffers }, { token: i0.IterableDiffers }, { token: i0.ElementRef }, { token: ArlasColorService }, { token: i2.TranslateService }, { token: ResultlistNotifierService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.13", type: ResultListComponent, selector: "arlas-result-list", inputs: { options: "options", fetchState: "fetchState", fieldsList: "fieldsList", rowItemList: "rowItemList", fieldsConfiguration: "fieldsConfiguration", tableWidth: "tableWidth", nLastLines: "nLastLines", nbLinesBeforeFetch: "nbLinesBeforeFetch", detailedGridHeight: "detailedGridHeight", nbGridColumns: "nbGridColumns", globalActionsList: "globalActionsList", detailedDataRetriever: "detailedDataRetriever", indeterminatedItems: "indeterminatedItems", selectedItems: "selectedItems", activatedActionsPerItem: "activatedActionsPerItem", highlightItems: "highlightItems", defautMode: "defautMode", isBodyHidden: "isBodyHidden", displayFilters: "displayFilters", isGeoSortEnabled: "isGeoSortEnabled", isGeoSortActivated: "isGeoSortActivated", currentSortedColumn: "currentSortedColumn", filtersMap: "filtersMap", dropDownMapValues: "dropDownMapValues", displayThead: "displayThead", keysToColors: "keysToColors", colorsSaturationWeight: "colorsSaturationWeight", useColorService: "useColorService", cellBackgroundStyle: "cellBackgroundStyle", selectedGridItem: "selectedGridItem", showEmptyGroup: "showEmptyGroup", isDetailledGridOpen: "isDetailledGridOpen", thumbnailFit: "thumbnailFit" }, outputs: { sortColumnEvent: "sortColumnEvent", geoSortEvent: "geoSortEvent", geoAutoSortEvent: "geoAutoSortEvent", selectedItemsEvent: "selectedItemsEvent", consultedItemEvent: "consultedItemEvent", clickOnItemEvent: "clickOnItemEvent", setFiltersEvent: "setFiltersEvent", moreDataEvent: "moreDataEvent", paginationEvent: "paginationEvent", actionOnItemEvent: "actionOnItemEvent", globalActionEvent: "globalActionEvent", columnFilterChanged: "columnFilterChanged", clickOnTile: "clickOnTile", changeResultMode: "changeResultMode", visibleItems: "visibleItems", onChangeItems: "onChangeItems", thumbnailFitEvent: "thumbnailFitEvent", onResultListUpdate: "onResultListUpdate", onListLoaded: "onListLoaded" }, host: { listeners: { "document:keydown.shift": "shiftDown($event)", "document:keyup.shift": "shiftUp($event)" } }, usesOnChanges: true, ngImport: i0, template: "<table [style.width.px]=\"tableWidth\" class=\"resultlist\">\n  <thead *ngIf=\"displayThead\">\n    <tr class=\"resultlist__filter resultlist__thead__tr\" *ngIf=\"this.displayFilters\">\n      <ng-container *ngFor=\"let column of columns\">\n        <td [style.width.px]=\"column.width\" *ngIf=\"column.isIdField\">\n          <span class=\"resultlist__header--columns--hidden\"></span>\n        </td>\n        <td arlas-result-filter class=\"resultlist__filter__{{column.columnName}}\"\n          *ngIf=\"!column.isIdField && !column.isToggleField\"\n          matTooltip=\"{{FILTER_ON | translate}} {{column.columnName  | translate}}\" [style.width.px]=\"column.width\"\n          [column]=\"column\" [dropdownValues]=\"dropDownMapValues?.get(column.fieldName)|async\" [filtersMap]=\"filtersMap\"\n          (columnChanged)=\"columnChanged($event)\" (setFiltersEvent)=\"setFilters($event)\">\n        </td>\n        <td *ngIf=\"column.isToggleField\" [style.width.px]=\"column.width\">\n          <span class=\"resultlist__header--columns--hidden\"></span>\n        </td>\n      </ng-container>\n    </tr>\n    <tr class=\"resultlist__tools resultlist__thead__tr\">\n      <td [style.width.px]=\"tableWidth\" class=\"resultlist__tools__td\">\n        <div class=\"resultlist__tools--select\">\n          <div class=\"resultgrid--checkbox\">\n            <mat-checkbox (change)=\"selectAllItems()\" [checked]=\"allItemsChecked\"\n              [indeterminate]=\"!allItemsChecked && selectedItems.size > 0\"></mat-checkbox>\n            <div class=\"resultgrid--checkbox__count\">\n              {{selectedItems.size}}\n            </div>\n          </div>\n          <div class=\"resultlist__tools--menu\">\n              <mat-icon id=\"global_actions_btn\" matTooltip=\"{{GLOBAL_ACTIONS | translate}}\" mat-icon-button [matMenuTriggerFor]=\"menu\" *ngIf=\"globalActionsList.length > 0\">more_vert</mat-icon>\n              <mat-menu #menu=\"matMenu\">\n                <button id=\"{{action.label + '_btn'}}'\" *ngFor=\"let action of globalActionsList\"  [disabled]=\"!action.alwaysEnabled && selectedItems.size===0\" mat-menu-item (click)=\"setGlobalAction(action)\">\n                  {{action.label | translate}}\n                </button>\n              </mat-menu>\n          </div>\n        </div>\n        <div class=\"resultlist__tools--separator\">|</div>\n        <div class=\"resultlist__tools--sort-container\" id=\"resultlist_sort\">\n          <mat-slide-toggle *ngIf=\"isGeoSortEnabled\" class=\"resultlist__tools--geosort\"\n            [disableRipple]=\"true\" [checked]=\"isGeoSortActivated\" [labelPosition]=\"'before'\"\n            matTooltip=\"{{GEOSORT_ACTION | translate}}\" (change)=\"setGeoSortAction()\" [hideIcon]=\"true\">\n            {{GEOSORT_BUTTON | translate}}</mat-slide-toggle>\n          <mat-select class=\"resultlist__tools--sort\" [panelClass]=\"'resultlist__tools--sort'\"\n            [compareWith]=\"byFieldName\" (selectionChange)=\"setSortedColumn($event)\"\n            [ngModel]=\"sortedColumn\" placeholder=\"{{'Sort on' | translate}}\">\n              <mat-select-trigger>\n                @if (sortedColumn?.fieldName) {\n                  <span>\n                    {{sortedColumn.columnName | translate}}\n                  </span>\n                }\n              </mat-select-trigger>\n              <mat-option [value]=\"\" class=\"resultlist__tools--sort-option\"> - - </mat-option>\n              @for (column of columns; track column.fieldName) {\n                @if (!column.isIdField && !column.isToggleField) {\n                  <mat-option [value]=\"column\" class=\"resultlist__tools--sort-option\">\n                    {{column.columnName | translate}}\n                  </mat-option>\n                }\n              }\n          </mat-select>\n          @if (sortedColumn?.fieldName) {\n            <mat-button mat-icon-button class=\"resultlist__tools--sort-direction\" (click)=\"setDirection($event)\"\n                (keydown)=\"setDirection($event)\" [matTooltip]=\"'Change sort direction' | translate\">\n              <mat-icon [class.reversed]=\"sortedColumn.sortDirection === SortEnum.asc\">trending_flat</mat-icon>\n            </mat-button>\n          }\n        </div>\n        <ng-container *ngIf=\"hasGridMode\">\n          <div class=\"resultlist__tools--separator\">|</div>\n          <div class=\"resultlist__tools--mode\" id=\"resultlist_mode\">\n            <mat-button-toggle-group [name]=\"'modeGroup'\" (change)=\"whichMode($event)\" [hideSingleSelectionIndicator]=\"true\">\n              <mat-button-toggle id=\"list_mode_btn\" matTooltip=\"{{LIST_MODE | translate}}\" value=\"{{ModeEnum.list}}\"\n                [checked]=\"resultMode==ModeEnum.list\">\n                <mat-icon>list</mat-icon>\n              </mat-button-toggle>\n              <mat-button-toggle id=\"grid_mode_btn\" matTooltip=\"{{GRID_MODE | translate}}\" value=\"{{ModeEnum.grid}}\"\n                [checked]=\"resultMode==ModeEnum.grid\">\n                <mat-icon>grid_view</mat-icon>\n              </mat-button-toggle>\n            </mat-button-toggle-group>\n          </div>\n        </ng-container>\n      </td>\n    </tr>\n    <tr class=\"resultlist__header resultlist__thead__tr\" *ngIf=\"resultMode !== ModeEnum.grid\">\n      <ng-container *ngFor=\"let column of columns\">\n        <th *ngIf=\"column.isIdField\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\"\n          class=\"resultlist__header--columns\">\n          <span class=\"resultlist__header--columns--hidden\"></span>\n        </th>\n        <th *ngIf=\"!column.isIdField && !column.isToggleField\" [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\" class=\"resultlist__header--columns\"\n          [matTooltip]=\"(column.columnName | translate) + (!!column.dataType ? '(' + column.dataType + ')' : '')\">\n          <span>\n            {{column.columnName | translate}}{{column.dataType ? ' (' + column.dataType + ')': ''}}\n          </span>\n        </th>\n        <th *ngIf=\"column.isToggleField\" class=\"resultlist__header--columns\" [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\">\n          <span class=\"resultlist__header--columns--hidden\">\n          </span>\n        </th>\n      </ng-container>\n    </tr>\n    <tr class=\"resultlist__grid-detail resultlist__thead__tr\"\n      *ngIf=\"selectedGridItem !== null && resultMode === ModeEnum.grid && isDetailledGridOpen\">\n      <td class=\"resultlist__grid-detail--td\" [colSpan]=\"columns?.length\">\n        <arlas-result-detailed-grid [gridTile]=\"selectedGridItem\" [detailWidth]=\"tableWidth\"\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailHeight]=\"detailedGridHeight\" [idFieldName]=\"fieldsConfiguration.idFieldName\"\n          [isDetailShowed]=\"isDetailledGridOpen\" (actionOnItemEvent)=\"triggerActionOnItem($event)\"\n          [showEmptyGroup]=\"showEmptyGroup\" [useHttp]=\"fieldsConfiguration.useHttpQuicklooks\"\n          (closeDetail)=\"closeDetail($event)\">\n        </arlas-result-detailed-grid>\n      </td>\n    </tr>\n  </thead>\n  <div *ngIf=\"isPreviousPageRequested\" class=\"resultlist__loading resultlist__top_loading\"\n    [style.width.px]=\"tableWidth\">\n    <ngx-loading [show]=\"isPreviousPageRequested\" [config]=\"loadAnimationConfig\"></ngx-loading>\n  </div>\n  <tbody class=\"resultlist__tbody\" arlasResultScroll *ngIf=\"!isBodyHidden\" [style.overflow-anchor]=\"'none'\"\n    [style.height.px]=\"tbodyHeight\" [scrollOptions]=\"scrollOptions\" [items]=\"items\" [style.position]=\"'relative'\"\n    [nbGridColumns]=\"nbGridColumns\"\n    [nbLinesBeforeFetch]=\"(nbLinesBeforeFetch !== undefined) ? nbLinesBeforeFetch:nLastLines\" [fetchState]=\"fetchState\"\n    [resultMode]=\"resultMode\" (visibleItems)=\"emitVisibleItems($event)\"\n    (nextDataEvent)=\"paginate($event, PageEnum.next)\" (previousDataEvent)=\"paginate($event, PageEnum.previous)\">\n    <mat-grid-list cols=\"{{nbGridColumns}}\" rowHeight=\"1:1\" [style.display]=\"displayListGrid\">\n      <ng-container *ngFor=\"let rowItem of items; index as i\">\n        <ng-container *ngIf=\"resultMode === ModeEnum.list; else grid_mode\">\n          <tr arlas-result-item [activatedActionsPerItem]=\"activatedActionsPerItem\" id=\"{{rowItem.identifier}}\" class=\"resultlist__body--item-hover-{{rowItem.ishighLight}}\"\n            [options]=\"options\" (mouseenter)=\"onEnterItem(rowItem)\" (mouseleave)=\"onLeaveItem(rowItem)\"\n            (click)=\"onClickItem(rowItem)\" [idFieldName]=\"fieldsConfiguration.idFieldName\" [tableWidth]=\"tableWidth\"\n            [rowItem]=\"rowItem\" [useColorService]=\"useColorService\" [cellBackgroundStyle]=\"cellBackgroundStyle\"\n            [keysToColors]=\"keysToColors\" [colorsSaturationWeight]=\"colorsSaturationWeight\"\n            [detailedDataRetriever]=\"detailedDataRetriever\" [selectedItems]=\"selectedItems\"\n            (selectedItemsEvent)=\"setSelectedItems($event)\" (borderStyleEvent)=\"setBorderStyle($event)\"\n            [style.border-bottom-style]=\"borderStyle\" (actionOnItemEvent)=\"triggerActionOnItem($event)\"\n           >\n          </tr>\n          <tr arlas-result-detailed-item *ngIf=\"rowItem.isDetailToggled\" class=\"resultlist__body--detailed-item\"\n            (mouseenter)=\"onEnterItem(rowItem)\" (mouseleave)=\"onLeaveItem(rowItem)\"\n            [detailedDataRetriever]=\"detailedDataRetriever\"\n            [activatedActionsPerItem]=\"activatedActionsPerItem\"\n            [detailColspan]=\"rowItem.columns.length\" [rowItem]=\"rowItem\" [showEmptyGroup]=showEmptyGroup\n            [idFieldName]=\"fieldsConfiguration.idFieldName\" (actionOnItemEvent)=\"triggerActionOnItem($event)\">\n          </tr>\n\n        </ng-container>\n        <ng-template #grid_mode>\n          <div class=\"div-grid-tile\" (mouseenter)=\"onEnterItem(rowItem)\" (mouseleave)=\"onLeaveItem(rowItem)\" >\n            <mat-grid-tile *ngIf=\"resultMode === ModeEnum.grid\" class=\"resultlist__md-grid-tile\">\n              <arlas-result-grid-tile\n                [activatedActionsPerItem]=\"activatedActionsPerItem\"\n                [displayInfoIcon]=\"rowItem.identifier === selectedGridItem?.identifier && isDetailledGridOpen\"\n                [thumbnailFit]=\"thumbnailFit\"\n                id=\"{{rowItem.identifier}}\" class=\"resultlist__grid-tile\" [options]=\"options\" [gridTile]=\"rowItem\"\n                [selectedItems]=\"selectedItems\" [detailedDataRetriever]=\"detailedDataRetriever\"\n                (selectedItemsEvent)=\"setSelectedItems($event)\" (clickedOnItemEvent)=\"setSelectedGridItem($event)\"\n                [idFieldName]=\"fieldsConfiguration.idFieldName\" (actionOnItemEvent)=\"triggerActionOnItem($event)\">\n              </arlas-result-grid-tile>\n            </mat-grid-tile>\n          </div>\n        </ng-template>\n      </ng-container>\n    </mat-grid-list>\n  </tbody>\n  <div *ngIf=\"resultMode === ModeEnum.grid\" class=\"resultlist-thumbnails-fit\">\n    <mat-button-toggle-group [name]=\"'thumbnailFitGroup'\" (change)=\"emitThumbnailsFitStatus($event)\"\n        class=\"fit-group\" [hideSingleSelectionIndicator]=\"true\">\n      <mat-button-toggle matTooltip=\"{{WIDTH_FIT | translate}}\" value=\"{{ThumbnailFitEnum.width}}\"\n        [checked]=\"thumbnailFit==ThumbnailFitEnum.width\">\n        <mat-icon style=\"transform: rotate(-90deg)\" class=\"fit-icon\">expand</mat-icon>\n      </mat-button-toggle>\n      <mat-button-toggle matTooltip=\"{{CONTAIN_FIT | translate}}\" value=\"{{ThumbnailFitEnum.contain}}\"\n        [checked]=\"thumbnailFit==ThumbnailFitEnum.contain\" class=\"contain-icon-wrapper\">\n        <mat-icon class=\"contain-icon fit-icon\">expand</mat-icon>\n        <mat-icon class=\"fit-icon\">expand</mat-icon>\n      </mat-button-toggle>\n      <mat-button-toggle matTooltip=\"{{HEIGHT_FIT | translate}}\" value=\"{{ThumbnailFitEnum.height}}\"\n        [checked]=\"thumbnailFit==ThumbnailFitEnum.height\">\n        <mat-icon class=\"fit-icon\">expand</mat-icon>\n      </mat-button-toggle>\n    </mat-button-toggle-group>\n  </div>\n  <div *ngIf=\"isNextPageRequested\" class=\"resultlist__loading resultlist__bottom_loading\" [style.width.px]=\"tableWidth\">\n    <ngx-loading [show]=\"isNextPageRequested\" [config]=\"loadAnimationConfig\"></ngx-loading>\n  </div>\n</table>\n", styles: ["@charset \"UTF-8\";.resultlist__header{text-align:center;height:25px}.resultlist__header--columns{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.9em;text-align:left;vertical-align:middle;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;box-sizing:border-box}.resultlist__header--columns__sort{float:right}.resultlist__header--columns__sort--icon{font-size:18px}.resultlist{width:100%;overflow:hidden;display:table;table-layout:fixed;margin-bottom:0;border-collapse:collapse}.resultlist__tools__td{padding:5px;display:flex;flex-direction:row;align-items:center}.resultlist__loading{width:100%;height:100px;position:absolute;z-index:1000;background-color:#fff;opacity:.7}.resultlist__bottom_loading{bottom:0}.resultlist__body--item{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef}.resultlist__body--item-hover-true{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef;background-color:#fff;position:relative;font-weight:500}.resultlist__body--item-hover-{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef;position:relative;background-color:#fff}.resultlist__body--item-hover-false{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef;position:relative;background-color:#eee;color:#aaa}tr:hover .toggle .actions arlas-result-actions .list_actions .not_activated{display:block}.resultlist__lastline{border-top:1px dashed #e9ecef;border-bottom:0px solid #e9ecef}.resultlist__body--detailed-item{border-top:1px dashed #e9ecef;border-bottom:1px solid #e9ecef;background-color:#fff}.resultlist__header,.resultlist__filter,.resultlist__tools,.resultlist__grid-detail{border-top:1px solid #e9ecef;border-bottom:1px solid #e9ecef}.resultlist-thumbnails-fit{display:flex;align-items:center;justify-content:center;height:30px}.resultlist-thumbnails-fit .mat-button-toggle-label-content{line-height:36px!important;height:36px;width:36px;padding:0!important}.resultlist__tools{height:50px;overflow:hidden}.resultlist__tools .resultlist__tools--geosort{font-size:14px;padding-right:10px;white-space:nowrap;overflow:hidden;--mdc-switch-track-height: 10px;--mdc-switch-handle-width: 15px;--mdc-switch-track-width: 30px;--mdc-switch-state-layer-size: 0}.resultlist__tools .resultlist__tools--geosort .mdc-switch__handle{--mat-switch-unselected-handle-size: 15px;--mat-switch-selected-handle-size: 15px;--mat-switch-pressed-handle-size: 15px}.resultlist__tools .resultlist__tools--geosort .mdc-form-field--align-end>label{padding-right:10px}.resultlist__grid-detail{display:block;margin-bottom:3px}.resultlist__grid-detail--td{padding:0!important}.resultlist__tools--select{flex:1;display:flex;align-items:center;justify-content:space-between}.resultgrid--checkbox{float:left;display:flex;align-items:center;--mdc-checkbox-state-layer-size: 18px}.resultgrid--checkbox__count{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;font-weight:700;padding:2px 0 0 8px;min-width:21px}.resultlist__tools--menu{cursor:pointer;float:left;padding-top:6px}.resultlist__tools--mode{text-align:right}.resultlist__tools--mode .mat-button-toggle-label-content{line-height:36px!important;height:36px;width:36px;padding:0!important}.resultlist__grid-tile{display:block;height:100%;width:100%}.resultlist__thead__tr{display:block;position:relative;width:100%}.resultlist__tbody{display:block;overflow-y:auto;overflow-x:hidden;width:100%;background-color:#ddd}::-webkit-scrollbar{width:6px;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}.select_between__icon,.select_all__icon_check{cursor:pointer}.resultgrid__clear{font-size:14px;width:14px;height:14px;cursor:pointer}.resultlist__tools--sort-container{flex:1;font-size:14px;display:flex;align-items:center}.resultlist__tools--sort-container .resultlist__tools--sort{flex:1;padding-right:5px;--mdc-typography-body1-font-size: 14px}.resultlist__tools--sort-container .resultlist__tools--sort .mat-mdc-select-trigger{gap:5px}.resultlist__tools--sort-container .resultlist__tools--sort-direction mat-icon{transform:rotate(90deg);font-size:18px;height:18px;width:18px;cursor:pointer}.resultlist__tools--sort-container .resultlist__tools--sort-direction .reversed{transform:rotate(-90deg)}.resultlist__tools--separator{padding:0 5px;color:#d3d3d3;font-size:24px;font-weight:100}.fit-images{color:#9b9b9b}.cover-images{color:#444}.fit-group{height:25px;align-items:center}.contain-icon{position:absolute;top:10px;transform:rotate(90deg)}.fit-icon{height:18px!important;width:18px!important;font-size:18px}.contain-icon-wrapper{position:relative}.cdk-overlay-pane:has(.mat-mdc-select-panel.resultlist__tools--sort){width:auto!important;--mat-select-trigger-text-tracking: 0;--mat-option-label-text-tracking: 0;--mat-option-label-text-size: 14px;--mdc-radio-state-layer-size: 20px}.cdk-overlay-pane:has(.mat-mdc-select-panel.resultlist__tools--sort) .mat-mdc-option{min-height:30px}.cdk-overlay-pane:has(.mat-mdc-select-panel.resultlist__tools--sort) .mat-mdc-option.mdc-list-item--disabled{opacity:unset}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i6$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled", "disabledInteractive", "hideSingleSelectionIndicator", "hideMultipleSelectionIndicator"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i6$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "disableRipple", "appearance", "checked", "disabled", "disabledInteractive"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: i7.MatGridList, selector: "mat-grid-list", inputs: ["cols", "gutterSize", "rowHeight"], exportAs: ["matGridList"] }, { kind: "component", type: i7.MatGridTile, selector: "mat-grid-tile", inputs: ["rowspan", "colspan"], exportAs: ["matGridTile"] }, { kind: "component", type: i8.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "disabledInteractive", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "component", type: i9$1.MatMenu, selector: "mat-menu", inputs: ["backdropClass", "aria-label", "aria-labelledby", "aria-describedby", "xPosition", "yPosition", "overlapTrigger", "hasBackdrop", "class", "classList"], outputs: ["closed", "close"], exportAs: ["matMenu"] }, { kind: "component", type: i9$1.MatMenuItem, selector: "[mat-menu-item]", inputs: ["role", "disabled", "disableRipple"], exportAs: ["matMenuItem"] }, { kind: "directive", type: i9$1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", inputs: ["mat-menu-trigger-for", "matMenuTriggerFor", "matMenuTriggerData", "matMenuTriggerRestoreFocus"], outputs: ["menuOpened", "onMenuOpen", "menuClosed", "onMenuClose"], exportAs: ["matMenuTrigger"] }, { kind: "component", type: i10.MatSelect, selector: "mat-select", inputs: ["aria-describedby", "panelClass", "disabled", "disableRipple", "tabIndex", "hideSingleSelectionIndicator", "placeholder", "required", "multiple", "disableOptionCentering", "compareWith", "value", "aria-label", "aria-labelledby", "errorStateMatcher", "typeaheadDebounceInterval", "sortComparator", "id", "panelWidth"], outputs: ["openedChange", "opened", "closed", "selectionChange", "valueChange"], exportAs: ["matSelect"] }, { kind: "directive", type: i10.MatSelectTrigger, selector: "mat-select-trigger" }, { kind: "component", type: i4$3.MatOption, selector: "mat-option", inputs: ["value", "id", "disabled"], outputs: ["onSelectionChange"], exportAs: ["matOption"] }, { kind: "component", type: i12.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["name", "id", "labelPosition", "aria-label", "aria-labelledby", "aria-describedby", "required", "color", "disabled", "disableRipple", "tabIndex", "checked", "hideIcon", "disabledInteractive"], outputs: ["change", "toggleChange"], exportAs: ["matSlideToggle"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "directive", type: i9.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i9.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i15.NgxLoadingComponent, selector: "ngx-loading", inputs: ["show", "config", "template"] }, { kind: "component", type: ResultGridTileComponent, selector: "arlas-result-grid-tile", inputs: ["gridTile", "thumbnailFit", "selectedItems", "detailedDataRetriever", "options", "idFieldName", "activatedActionsPerItem", "displayInfoIcon"], outputs: ["actionOnItemEvent", "selectedItemsEvent", "selectedItemPositionEvent", "clickedOnItemEvent"] }, { kind: "component", type: ResultItemComponent, selector: "[arlas-result-item]", inputs: ["options", "rowItem", "idFieldName", "detailedDataRetriever", "selectedItems", "keysToColors", "colorsSaturationWeight", "useColorService", "cellBackgroundStyle", "activatedActionsPerItem", "tableWidth"], outputs: ["selectedItemsEvent", "actionOnItemEvent", "selectedItemPositionEvent", "borderStyleEvent"] }, { kind: "component", type: ResultDetailedItemComponent, selector: "[arlas-result-detailed-item]", inputs: ["detailColspan", "idFieldName", "containerType", "rowItem", "showEmptyGroup", "detailedDataRetriever", "activatedActionsPerItem"], outputs: ["actionOnItemEvent"] }, { kind: "component", type: ResultDetailedGridComponent, selector: "arlas-result-detailed-grid", inputs: ["gridTile", "detailWidth", "detailHeight", "idFieldName", "isDetailShowed", "showEmptyGroup", "useHttp", "activatedActionsPerItem", "detailedDataRetriever"], outputs: ["actionOnItemEvent", "closeDetail"] }, { kind: "component", type: ResultFilterComponent, selector: "[arlas-result-filter]", inputs: ["column", "filtersMap", "inputValue", "dropdownValues"], outputs: ["setFiltersEvent", "columnChanged"] }, { kind: "directive", type: ResultScrollDirective, selector: "[arlasResultScroll]", inputs: ["items", "nbLinesBeforeFetch", "nbGridColumns", "resultMode", "fetchState", "scrollOptions"], outputs: ["nextDataEvent", "previousDataEvent", "visibleItems"] }, { kind: "pipe", type: i2$1.AsyncPipe, name: "async" }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-result-list', encapsulation: ViewEncapsulation.None, template: "<table [style.width.px]=\"tableWidth\" class=\"resultlist\">\n  <thead *ngIf=\"displayThead\">\n    <tr class=\"resultlist__filter resultlist__thead__tr\" *ngIf=\"this.displayFilters\">\n      <ng-container *ngFor=\"let column of columns\">\n        <td [style.width.px]=\"column.width\" *ngIf=\"column.isIdField\">\n          <span class=\"resultlist__header--columns--hidden\"></span>\n        </td>\n        <td arlas-result-filter class=\"resultlist__filter__{{column.columnName}}\"\n          *ngIf=\"!column.isIdField && !column.isToggleField\"\n          matTooltip=\"{{FILTER_ON | translate}} {{column.columnName  | translate}}\" [style.width.px]=\"column.width\"\n          [column]=\"column\" [dropdownValues]=\"dropDownMapValues?.get(column.fieldName)|async\" [filtersMap]=\"filtersMap\"\n          (columnChanged)=\"columnChanged($event)\" (setFiltersEvent)=\"setFilters($event)\">\n        </td>\n        <td *ngIf=\"column.isToggleField\" [style.width.px]=\"column.width\">\n          <span class=\"resultlist__header--columns--hidden\"></span>\n        </td>\n      </ng-container>\n    </tr>\n    <tr class=\"resultlist__tools resultlist__thead__tr\">\n      <td [style.width.px]=\"tableWidth\" class=\"resultlist__tools__td\">\n        <div class=\"resultlist__tools--select\">\n          <div class=\"resultgrid--checkbox\">\n            <mat-checkbox (change)=\"selectAllItems()\" [checked]=\"allItemsChecked\"\n              [indeterminate]=\"!allItemsChecked && selectedItems.size > 0\"></mat-checkbox>\n            <div class=\"resultgrid--checkbox__count\">\n              {{selectedItems.size}}\n            </div>\n          </div>\n          <div class=\"resultlist__tools--menu\">\n              <mat-icon id=\"global_actions_btn\" matTooltip=\"{{GLOBAL_ACTIONS | translate}}\" mat-icon-button [matMenuTriggerFor]=\"menu\" *ngIf=\"globalActionsList.length > 0\">more_vert</mat-icon>\n              <mat-menu #menu=\"matMenu\">\n                <button id=\"{{action.label + '_btn'}}'\" *ngFor=\"let action of globalActionsList\"  [disabled]=\"!action.alwaysEnabled && selectedItems.size===0\" mat-menu-item (click)=\"setGlobalAction(action)\">\n                  {{action.label | translate}}\n                </button>\n              </mat-menu>\n          </div>\n        </div>\n        <div class=\"resultlist__tools--separator\">|</div>\n        <div class=\"resultlist__tools--sort-container\" id=\"resultlist_sort\">\n          <mat-slide-toggle *ngIf=\"isGeoSortEnabled\" class=\"resultlist__tools--geosort\"\n            [disableRipple]=\"true\" [checked]=\"isGeoSortActivated\" [labelPosition]=\"'before'\"\n            matTooltip=\"{{GEOSORT_ACTION | translate}}\" (change)=\"setGeoSortAction()\" [hideIcon]=\"true\">\n            {{GEOSORT_BUTTON | translate}}</mat-slide-toggle>\n          <mat-select class=\"resultlist__tools--sort\" [panelClass]=\"'resultlist__tools--sort'\"\n            [compareWith]=\"byFieldName\" (selectionChange)=\"setSortedColumn($event)\"\n            [ngModel]=\"sortedColumn\" placeholder=\"{{'Sort on' | translate}}\">\n              <mat-select-trigger>\n                @if (sortedColumn?.fieldName) {\n                  <span>\n                    {{sortedColumn.columnName | translate}}\n                  </span>\n                }\n              </mat-select-trigger>\n              <mat-option [value]=\"\" class=\"resultlist__tools--sort-option\"> - - </mat-option>\n              @for (column of columns; track column.fieldName) {\n                @if (!column.isIdField && !column.isToggleField) {\n                  <mat-option [value]=\"column\" class=\"resultlist__tools--sort-option\">\n                    {{column.columnName | translate}}\n                  </mat-option>\n                }\n              }\n          </mat-select>\n          @if (sortedColumn?.fieldName) {\n            <mat-button mat-icon-button class=\"resultlist__tools--sort-direction\" (click)=\"setDirection($event)\"\n                (keydown)=\"setDirection($event)\" [matTooltip]=\"'Change sort direction' | translate\">\n              <mat-icon [class.reversed]=\"sortedColumn.sortDirection === SortEnum.asc\">trending_flat</mat-icon>\n            </mat-button>\n          }\n        </div>\n        <ng-container *ngIf=\"hasGridMode\">\n          <div class=\"resultlist__tools--separator\">|</div>\n          <div class=\"resultlist__tools--mode\" id=\"resultlist_mode\">\n            <mat-button-toggle-group [name]=\"'modeGroup'\" (change)=\"whichMode($event)\" [hideSingleSelectionIndicator]=\"true\">\n              <mat-button-toggle id=\"list_mode_btn\" matTooltip=\"{{LIST_MODE | translate}}\" value=\"{{ModeEnum.list}}\"\n                [checked]=\"resultMode==ModeEnum.list\">\n                <mat-icon>list</mat-icon>\n              </mat-button-toggle>\n              <mat-button-toggle id=\"grid_mode_btn\" matTooltip=\"{{GRID_MODE | translate}}\" value=\"{{ModeEnum.grid}}\"\n                [checked]=\"resultMode==ModeEnum.grid\">\n                <mat-icon>grid_view</mat-icon>\n              </mat-button-toggle>\n            </mat-button-toggle-group>\n          </div>\n        </ng-container>\n      </td>\n    </tr>\n    <tr class=\"resultlist__header resultlist__thead__tr\" *ngIf=\"resultMode !== ModeEnum.grid\">\n      <ng-container *ngFor=\"let column of columns\">\n        <th *ngIf=\"column.isIdField\" [style.max-width.px]=\"column.width\" [style.min-width.px]=\"column.width\"\n          class=\"resultlist__header--columns\">\n          <span class=\"resultlist__header--columns--hidden\"></span>\n        </th>\n        <th *ngIf=\"!column.isIdField && !column.isToggleField\" [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\" class=\"resultlist__header--columns\"\n          [matTooltip]=\"(column.columnName | translate) + (!!column.dataType ? '(' + column.dataType + ')' : '')\">\n          <span>\n            {{column.columnName | translate}}{{column.dataType ? ' (' + column.dataType + ')': ''}}\n          </span>\n        </th>\n        <th *ngIf=\"column.isToggleField\" class=\"resultlist__header--columns\" [style.max-width.px]=\"column.width\"\n          [style.min-width.px]=\"column.width\">\n          <span class=\"resultlist__header--columns--hidden\">\n          </span>\n        </th>\n      </ng-container>\n    </tr>\n    <tr class=\"resultlist__grid-detail resultlist__thead__tr\"\n      *ngIf=\"selectedGridItem !== null && resultMode === ModeEnum.grid && isDetailledGridOpen\">\n      <td class=\"resultlist__grid-detail--td\" [colSpan]=\"columns?.length\">\n        <arlas-result-detailed-grid [gridTile]=\"selectedGridItem\" [detailWidth]=\"tableWidth\"\n          [activatedActionsPerItem]=\"activatedActionsPerItem\"\n          [detailHeight]=\"detailedGridHeight\" [idFieldName]=\"fieldsConfiguration.idFieldName\"\n          [isDetailShowed]=\"isDetailledGridOpen\" (actionOnItemEvent)=\"triggerActionOnItem($event)\"\n          [showEmptyGroup]=\"showEmptyGroup\" [useHttp]=\"fieldsConfiguration.useHttpQuicklooks\"\n          (closeDetail)=\"closeDetail($event)\">\n        </arlas-result-detailed-grid>\n      </td>\n    </tr>\n  </thead>\n  <div *ngIf=\"isPreviousPageRequested\" class=\"resultlist__loading resultlist__top_loading\"\n    [style.width.px]=\"tableWidth\">\n    <ngx-loading [show]=\"isPreviousPageRequested\" [config]=\"loadAnimationConfig\"></ngx-loading>\n  </div>\n  <tbody class=\"resultlist__tbody\" arlasResultScroll *ngIf=\"!isBodyHidden\" [style.overflow-anchor]=\"'none'\"\n    [style.height.px]=\"tbodyHeight\" [scrollOptions]=\"scrollOptions\" [items]=\"items\" [style.position]=\"'relative'\"\n    [nbGridColumns]=\"nbGridColumns\"\n    [nbLinesBeforeFetch]=\"(nbLinesBeforeFetch !== undefined) ? nbLinesBeforeFetch:nLastLines\" [fetchState]=\"fetchState\"\n    [resultMode]=\"resultMode\" (visibleItems)=\"emitVisibleItems($event)\"\n    (nextDataEvent)=\"paginate($event, PageEnum.next)\" (previousDataEvent)=\"paginate($event, PageEnum.previous)\">\n    <mat-grid-list cols=\"{{nbGridColumns}}\" rowHeight=\"1:1\" [style.display]=\"displayListGrid\">\n      <ng-container *ngFor=\"let rowItem of items; index as i\">\n        <ng-container *ngIf=\"resultMode === ModeEnum.list; else grid_mode\">\n          <tr arlas-result-item [activatedActionsPerItem]=\"activatedActionsPerItem\" id=\"{{rowItem.identifier}}\" class=\"resultlist__body--item-hover-{{rowItem.ishighLight}}\"\n            [options]=\"options\" (mouseenter)=\"onEnterItem(rowItem)\" (mouseleave)=\"onLeaveItem(rowItem)\"\n            (click)=\"onClickItem(rowItem)\" [idFieldName]=\"fieldsConfiguration.idFieldName\" [tableWidth]=\"tableWidth\"\n            [rowItem]=\"rowItem\" [useColorService]=\"useColorService\" [cellBackgroundStyle]=\"cellBackgroundStyle\"\n            [keysToColors]=\"keysToColors\" [colorsSaturationWeight]=\"colorsSaturationWeight\"\n            [detailedDataRetriever]=\"detailedDataRetriever\" [selectedItems]=\"selectedItems\"\n            (selectedItemsEvent)=\"setSelectedItems($event)\" (borderStyleEvent)=\"setBorderStyle($event)\"\n            [style.border-bottom-style]=\"borderStyle\" (actionOnItemEvent)=\"triggerActionOnItem($event)\"\n           >\n          </tr>\n          <tr arlas-result-detailed-item *ngIf=\"rowItem.isDetailToggled\" class=\"resultlist__body--detailed-item\"\n            (mouseenter)=\"onEnterItem(rowItem)\" (mouseleave)=\"onLeaveItem(rowItem)\"\n            [detailedDataRetriever]=\"detailedDataRetriever\"\n            [activatedActionsPerItem]=\"activatedActionsPerItem\"\n            [detailColspan]=\"rowItem.columns.length\" [rowItem]=\"rowItem\" [showEmptyGroup]=showEmptyGroup\n            [idFieldName]=\"fieldsConfiguration.idFieldName\" (actionOnItemEvent)=\"triggerActionOnItem($event)\">\n          </tr>\n\n        </ng-container>\n        <ng-template #grid_mode>\n          <div class=\"div-grid-tile\" (mouseenter)=\"onEnterItem(rowItem)\" (mouseleave)=\"onLeaveItem(rowItem)\" >\n            <mat-grid-tile *ngIf=\"resultMode === ModeEnum.grid\" class=\"resultlist__md-grid-tile\">\n              <arlas-result-grid-tile\n                [activatedActionsPerItem]=\"activatedActionsPerItem\"\n                [displayInfoIcon]=\"rowItem.identifier === selectedGridItem?.identifier && isDetailledGridOpen\"\n                [thumbnailFit]=\"thumbnailFit\"\n                id=\"{{rowItem.identifier}}\" class=\"resultlist__grid-tile\" [options]=\"options\" [gridTile]=\"rowItem\"\n                [selectedItems]=\"selectedItems\" [detailedDataRetriever]=\"detailedDataRetriever\"\n                (selectedItemsEvent)=\"setSelectedItems($event)\" (clickedOnItemEvent)=\"setSelectedGridItem($event)\"\n                [idFieldName]=\"fieldsConfiguration.idFieldName\" (actionOnItemEvent)=\"triggerActionOnItem($event)\">\n              </arlas-result-grid-tile>\n            </mat-grid-tile>\n          </div>\n        </ng-template>\n      </ng-container>\n    </mat-grid-list>\n  </tbody>\n  <div *ngIf=\"resultMode === ModeEnum.grid\" class=\"resultlist-thumbnails-fit\">\n    <mat-button-toggle-group [name]=\"'thumbnailFitGroup'\" (change)=\"emitThumbnailsFitStatus($event)\"\n        class=\"fit-group\" [hideSingleSelectionIndicator]=\"true\">\n      <mat-button-toggle matTooltip=\"{{WIDTH_FIT | translate}}\" value=\"{{ThumbnailFitEnum.width}}\"\n        [checked]=\"thumbnailFit==ThumbnailFitEnum.width\">\n        <mat-icon style=\"transform: rotate(-90deg)\" class=\"fit-icon\">expand</mat-icon>\n      </mat-button-toggle>\n      <mat-button-toggle matTooltip=\"{{CONTAIN_FIT | translate}}\" value=\"{{ThumbnailFitEnum.contain}}\"\n        [checked]=\"thumbnailFit==ThumbnailFitEnum.contain\" class=\"contain-icon-wrapper\">\n        <mat-icon class=\"contain-icon fit-icon\">expand</mat-icon>\n        <mat-icon class=\"fit-icon\">expand</mat-icon>\n      </mat-button-toggle>\n      <mat-button-toggle matTooltip=\"{{HEIGHT_FIT | translate}}\" value=\"{{ThumbnailFitEnum.height}}\"\n        [checked]=\"thumbnailFit==ThumbnailFitEnum.height\">\n        <mat-icon class=\"fit-icon\">expand</mat-icon>\n      </mat-button-toggle>\n    </mat-button-toggle-group>\n  </div>\n  <div *ngIf=\"isNextPageRequested\" class=\"resultlist__loading resultlist__bottom_loading\" [style.width.px]=\"tableWidth\">\n    <ngx-loading [show]=\"isNextPageRequested\" [config]=\"loadAnimationConfig\"></ngx-loading>\n  </div>\n</table>\n", styles: ["@charset \"UTF-8\";.resultlist__header{text-align:center;height:25px}.resultlist__header--columns{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.9em;text-align:left;vertical-align:middle;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;box-sizing:border-box}.resultlist__header--columns__sort{float:right}.resultlist__header--columns__sort--icon{font-size:18px}.resultlist{width:100%;overflow:hidden;display:table;table-layout:fixed;margin-bottom:0;border-collapse:collapse}.resultlist__tools__td{padding:5px;display:flex;flex-direction:row;align-items:center}.resultlist__loading{width:100%;height:100px;position:absolute;z-index:1000;background-color:#fff;opacity:.7}.resultlist__bottom_loading{bottom:0}.resultlist__body--item{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef}.resultlist__body--item-hover-true{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef;background-color:#fff;position:relative;font-weight:500}.resultlist__body--item-hover-{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef;position:relative;background-color:#fff}.resultlist__body--item-hover-false{border-top:1px solid #e9ecef;border-bottom:1px dashed #e9ecef;position:relative;background-color:#eee;color:#aaa}tr:hover .toggle .actions arlas-result-actions .list_actions .not_activated{display:block}.resultlist__lastline{border-top:1px dashed #e9ecef;border-bottom:0px solid #e9ecef}.resultlist__body--detailed-item{border-top:1px dashed #e9ecef;border-bottom:1px solid #e9ecef;background-color:#fff}.resultlist__header,.resultlist__filter,.resultlist__tools,.resultlist__grid-detail{border-top:1px solid #e9ecef;border-bottom:1px solid #e9ecef}.resultlist-thumbnails-fit{display:flex;align-items:center;justify-content:center;height:30px}.resultlist-thumbnails-fit .mat-button-toggle-label-content{line-height:36px!important;height:36px;width:36px;padding:0!important}.resultlist__tools{height:50px;overflow:hidden}.resultlist__tools .resultlist__tools--geosort{font-size:14px;padding-right:10px;white-space:nowrap;overflow:hidden;--mdc-switch-track-height: 10px;--mdc-switch-handle-width: 15px;--mdc-switch-track-width: 30px;--mdc-switch-state-layer-size: 0}.resultlist__tools .resultlist__tools--geosort .mdc-switch__handle{--mat-switch-unselected-handle-size: 15px;--mat-switch-selected-handle-size: 15px;--mat-switch-pressed-handle-size: 15px}.resultlist__tools .resultlist__tools--geosort .mdc-form-field--align-end>label{padding-right:10px}.resultlist__grid-detail{display:block;margin-bottom:3px}.resultlist__grid-detail--td{padding:0!important}.resultlist__tools--select{flex:1;display:flex;align-items:center;justify-content:space-between}.resultgrid--checkbox{float:left;display:flex;align-items:center;--mdc-checkbox-state-layer-size: 18px}.resultgrid--checkbox__count{font-family:Roboto,Helvetica Neue,sans-serif;font-size:.7em;font-weight:700;padding:2px 0 0 8px;min-width:21px}.resultlist__tools--menu{cursor:pointer;float:left;padding-top:6px}.resultlist__tools--mode{text-align:right}.resultlist__tools--mode .mat-button-toggle-label-content{line-height:36px!important;height:36px;width:36px;padding:0!important}.resultlist__grid-tile{display:block;height:100%;width:100%}.resultlist__thead__tr{display:block;position:relative;width:100%}.resultlist__tbody{display:block;overflow-y:auto;overflow-x:hidden;width:100%;background-color:#ddd}::-webkit-scrollbar{width:6px;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}.select_between__icon,.select_all__icon_check{cursor:pointer}.resultgrid__clear{font-size:14px;width:14px;height:14px;cursor:pointer}.resultlist__tools--sort-container{flex:1;font-size:14px;display:flex;align-items:center}.resultlist__tools--sort-container .resultlist__tools--sort{flex:1;padding-right:5px;--mdc-typography-body1-font-size: 14px}.resultlist__tools--sort-container .resultlist__tools--sort .mat-mdc-select-trigger{gap:5px}.resultlist__tools--sort-container .resultlist__tools--sort-direction mat-icon{transform:rotate(90deg);font-size:18px;height:18px;width:18px;cursor:pointer}.resultlist__tools--sort-container .resultlist__tools--sort-direction .reversed{transform:rotate(-90deg)}.resultlist__tools--separator{padding:0 5px;color:#d3d3d3;font-size:24px;font-weight:100}.fit-images{color:#9b9b9b}.cover-images{color:#444}.fit-group{height:25px;align-items:center}.contain-icon{position:absolute;top:10px;transform:rotate(90deg)}.fit-icon{height:18px!important;width:18px!important;font-size:18px}.contain-icon-wrapper{position:relative}.cdk-overlay-pane:has(.mat-mdc-select-panel.resultlist__tools--sort){width:auto!important;--mat-select-trigger-text-tracking: 0;--mat-option-label-text-tracking: 0;--mat-option-label-text-size: 14px;--mdc-radio-state-layer-size: 20px}.cdk-overlay-pane:has(.mat-mdc-select-panel.resultlist__tools--sort) .mat-mdc-option{min-height:30px}.cdk-overlay-pane:has(.mat-mdc-select-panel.resultlist__tools--sort) .mat-mdc-option.mdc-list-item--disabled{opacity:unset}\n"] }]
        }], ctorParameters: () => [{ type: i0.IterableDiffers }, { type: i0.IterableDiffers }, { type: i0.ElementRef }, { type: ArlasColorService }, { type: i2.TranslateService }, { type: ResultlistNotifierService }, { type: i0.ChangeDetectorRef }], propDecorators: { options: [{
                type: Input
            }], fetchState: [{
                type: Input
            }], fieldsList: [{
                type: Input
            }], rowItemList: [{
                type: Input
            }], fieldsConfiguration: [{
                type: Input
            }], tableWidth: [{
                type: Input
            }], nLastLines: [{
                type: Input
            }], nbLinesBeforeFetch: [{
                type: Input
            }], detailedGridHeight: [{
                type: Input
            }], nbGridColumns: [{
                type: Input
            }], globalActionsList: [{
                type: Input
            }], detailedDataRetriever: [{
                type: Input
            }], indeterminatedItems: [{
                type: Input
            }], selectedItems: [{
                type: Input
            }], activatedActionsPerItem: [{
                type: Input
            }], highlightItems: [{
                type: Input
            }], defautMode: [{
                type: Input
            }], isBodyHidden: [{
                type: Input
            }], displayFilters: [{
                type: Input
            }], isGeoSortEnabled: [{
                type: Input
            }], isGeoSortActivated: [{
                type: Input
            }], currentSortedColumn: [{
                type: Input
            }], filtersMap: [{
                type: Input
            }], dropDownMapValues: [{
                type: Input
            }], displayThead: [{
                type: Input
            }], keysToColors: [{
                type: Input
            }], colorsSaturationWeight: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], cellBackgroundStyle: [{
                type: Input
            }], selectedGridItem: [{
                type: Input
            }], showEmptyGroup: [{
                type: Input
            }], isDetailledGridOpen: [{
                type: Input
            }], thumbnailFit: [{
                type: Input
            }], sortColumnEvent: [{
                type: Output
            }], geoSortEvent: [{
                type: Output
            }], geoAutoSortEvent: [{
                type: Output
            }], selectedItemsEvent: [{
                type: Output
            }], consultedItemEvent: [{
                type: Output
            }], clickOnItemEvent: [{
                type: Output
            }], setFiltersEvent: [{
                type: Output
            }], moreDataEvent: [{
                type: Output
            }], paginationEvent: [{
                type: Output
            }], actionOnItemEvent: [{
                type: Output
            }], globalActionEvent: [{
                type: Output
            }], columnFilterChanged: [{
                type: Output
            }], clickOnTile: [{
                type: Output
            }], changeResultMode: [{
                type: Output
            }], visibleItems: [{
                type: Output
            }], onChangeItems: [{
                type: Output
            }], thumbnailFitEvent: [{
                type: Output
            }], onResultListUpdate: [{
                type: Output
            }], onListLoaded: [{
                type: Output
            }], shiftDown: [{
                type: HostListener,
                args: ['document:keydown.shift', ['$event']]
            }], shiftUp: [{
                type: HostListener,
                args: ['document:keyup.shift', ['$event']]
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ColorGeneratorModule {
    /**
     * Use this method in your root module to provide the ColorGeneratorLoader
     */
    static forRoot(config = {}) {
        return {
            ngModule: ColorGeneratorModule,
            providers: [
                config.loader || { provide: ColorGeneratorLoader, useClass: AwcColorGeneratorLoader }
            ]
        };
    }
    static forChild(config = {}) {
        return {
            ngModule: ColorGeneratorModule,
            providers: [
                config.loader || { provide: ColorGeneratorLoader, useClass: AwcColorGeneratorLoader }
            ]
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ColorGeneratorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ColorGeneratorModule }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ColorGeneratorModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ColorGeneratorModule, decorators: [{
            type: NgModule,
            args: [{}]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class FormatNumberModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberModule, declarations: [FormatNumberPipe], exports: [FormatNumberPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatNumberModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [
                        FormatNumberPipe
                    ],
                    exports: [
                        FormatNumberPipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ReplaceModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ReplaceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ReplaceModule, declarations: [ReplacePipe], exports: [ReplacePipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ReplaceModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ReplaceModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [
                        ReplacePipe
                    ],
                    exports: [
                        ReplacePipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetAttachmentUrlModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetAttachmentUrlModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetAttachmentUrlModule, declarations: [GetAttachmentUrlPipe], exports: [GetAttachmentUrlPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetAttachmentUrlModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetAttachmentUrlModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [
                        GetAttachmentUrlPipe
                    ],
                    exports: [
                        GetAttachmentUrlPipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ResultsModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ResultsModule, declarations: [ResultListComponent, ResultGridTileComponent,
            ResultItemComponent, ResultDetailedItemComponent, ResultDetailedGridComponent,
            ResultFilterComponent, ResultScrollDirective, ResultActionsComponent, ActionDisplayerPipe], imports: [CommonModule, ColorGeneratorModule, MatIconModule,
            MatChipsModule,
            MatButtonToggleModule,
            MatButtonModule,
            MatGridListModule,
            MatCheckboxModule,
            MatMenuModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatTooltipModule,
            MatRadioModule,
            MatProgressSpinnerModule,
            FormsModule,
            LazyLoadImageModule,
            NgxLoadingModule,
            TranslateModule,
            FormatNumberModule,
            ReplaceModule,
            GetAttachmentUrlModule], exports: [ResultListComponent, ResultGridTileComponent,
            ResultItemComponent, ResultDetailedItemComponent, ResultDetailedGridComponent,
            ResultFilterComponent, ResultScrollDirective, ResultActionsComponent, ActionDisplayerPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultsModule, imports: [CommonModule,
            ColorGeneratorModule.forRoot(),
            MatIconModule,
            MatChipsModule,
            MatButtonToggleModule,
            MatButtonModule,
            MatGridListModule,
            MatCheckboxModule,
            MatMenuModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatTooltipModule,
            MatRadioModule,
            MatProgressSpinnerModule,
            FormsModule,
            LazyLoadImageModule,
            NgxLoadingModule,
            TranslateModule,
            FormatNumberModule,
            ReplaceModule,
            GetAttachmentUrlModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ColorGeneratorModule.forRoot(),
                        MatIconModule,
                        MatChipsModule,
                        MatButtonToggleModule,
                        MatButtonModule,
                        MatGridListModule,
                        MatCheckboxModule,
                        MatMenuModule,
                        MatSelectModule,
                        MatSlideToggleModule,
                        MatTooltipModule,
                        MatRadioModule,
                        MatProgressSpinnerModule,
                        FormsModule,
                        LazyLoadImageModule,
                        NgxLoadingModule,
                        TranslateModule,
                        FormatNumberModule,
                        ReplaceModule,
                        GetAttachmentUrlModule
                    ],
                    declarations: [ResultListComponent, ResultGridTileComponent,
                        ResultItemComponent, ResultDetailedItemComponent, ResultDetailedGridComponent,
                        ResultFilterComponent, ResultScrollDirective, ResultActionsComponent, ActionDisplayerPipe],
                    exports: [ResultListComponent, ResultGridTileComponent,
                        ResultItemComponent, ResultDetailedItemComponent, ResultDetailedGridComponent,
                        ResultFilterComponent, ResultScrollDirective, ResultActionsComponent, ActionDisplayerPipe],
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class CollectionModule {
    /**
     * Use this method in your root module to provide the ColorGeneratorLoader
     */
    static forRoot(config = {}) {
        return {
            ngModule: CollectionModule,
            providers: [
                config.loader || { provide: BaseCollectionService, useClass: AwcCollectionService }
            ]
        };
    }
    static forChild(config = {}) {
        return {
            ngModule: CollectionModule,
            providers: [
                config.loader || { provide: BaseCollectionService, useClass: AwcCollectionService }
            ]
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CollectionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: CollectionModule }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CollectionModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CollectionModule, decorators: [{
            type: NgModule,
            args: [{}]
        }] });

var $schema$2 = "http://json-schema.org/draft-06/schema#";
var title$2 = "Card input configuration";
var description$2 = "The Configuration input of Card";
var type$2 = "object";
var $id$2 = "metric.schema.json";
var properties$2 = {
	customizedCssClass: {
		description: "Css class name to use to customize a specific card's style.",
		type: "string"
	}
};
var metric_schema = {
	$schema: $schema$2,
	title: title$2,
	description: description$2,
	type: type$2,
	$id: $id$2,
	properties: properties$2
};

var metricJsonSchema = /*#__PURE__*/Object.freeze({
   __proto__: null,
   $id: $id$2,
   $schema: $schema$2,
   default: metric_schema,
   description: description$2,
   properties: properties$2,
   title: title$2,
   type: type$2
});

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * This component will contain a phrase composed of 3 parts
 * - beforeValue = `Speed average : `
 * - value = `25`
 * - afterValue = ` km/h`.
 * The phrase that will be represented in this card is : **Speed average : 25 km/h**
 *
 */
class MetricComponent {
    constructor() {
        this.beforeValue = '';
        this.afterValue = '';
        this.valuePrecision = 2;
        /**
         * Whether to shorten the metric value
         */
        this.shortValue = false;
        /**
         * Whether to display a '~' before the metric value
         */
        this.approximateValue = false;
        /**
         * @Input : Angular
         * @description Chart's width. If not specified, the chart takes the component's container width.
         */
        this.chartWidth = null;
        this.displayedValue = '0';
        this.NUMBER_FORMAT_CHAR = NUMBER_FORMAT_CHAR;
    }
    ngOnInit() {
        if (this.value) {
            this.setDisplayedValue();
        }
    }
    ngOnChanges(changes) {
        if (changes['value']) {
            if (this.value !== undefined && !Number.isNaN(this.value)) {
                this.setDisplayedValue();
            }
            else {
                /** '-' will be set when `value` is undefined or not a number */
                this.displayedValue = '-';
            }
        }
    }
    /**
     * @returns Json schema of the donut component for configuration
     */
    static getMetricJsonSchema() {
        return metricJsonSchema;
    }
    static round(value, precision) {
        if (precision === 0 || precision === undefined) {
            return Math.round(value);
        }
        else {
            const multiplier = Math.pow(10, precision * 10 || 0);
            return +(Math.round(value * multiplier) / multiplier).toFixed(precision);
        }
    }
    /**
     * Sets the value displayed in html
     */
    setDisplayedValue() {
        if (this.shortValue) {
            this.displayedValue = numberToShortValue(this.value, this.valuePrecision);
        }
        else {
            this.displayedValue = MetricComponent.round(this.value, this.valuePrecision);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MetricComponent, selector: "arlas-metric", inputs: { beforeValue: "beforeValue", value: "value", afterValue: "afterValue", customizedCssClass: "customizedCssClass", valuePrecision: "valuePrecision", shortValue: "shortValue", approximateValue: "approximateValue", chartWidth: "chartWidth" }, usesOnChanges: true, ngImport: i0, template: "<div [style.width.px]=\"!!chartWidth ? chartWidth : 'unset'\" class=\"arlas-metric\" [ngClass]=\"customizedCssClass\" >\n  <div class=\"arlas-metric__title\">\n    {{beforeValue | translate}}\n  </div>\n  <div class=\"arlas-metric__value\">\n    <span class=\"arlas-metric__value--approximmate\" *ngIf=\"approximateValue\"> ~ </span>\n    {{this.displayedValue | formatNumber:NUMBER_FORMAT_CHAR}}\n  </div>\n  <div class=\"arlas-metric__description\">\n    {{afterValue | translate}}\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.arlas-metric{line-height:normal;padding-top:10px;padding-bottom:10px}.arlas-metric__title{text-align:center;white-space:nowrap;display:flex;justify-content:center;font-size:16px}.arlas-metric__value{font-weight:400;font-size:25px;padding:5px 0;white-space:nowrap;display:flex;justify-content:center}.arlas-metric__description{font-size:16px;font-weight:300;display:flex;justify-content:center}\n"], dependencies: [{ kind: "directive", type: i2$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: FormatNumberPipe, name: "formatNumber" }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-metric', template: "<div [style.width.px]=\"!!chartWidth ? chartWidth : 'unset'\" class=\"arlas-metric\" [ngClass]=\"customizedCssClass\" >\n  <div class=\"arlas-metric__title\">\n    {{beforeValue | translate}}\n  </div>\n  <div class=\"arlas-metric__value\">\n    <span class=\"arlas-metric__value--approximmate\" *ngIf=\"approximateValue\"> ~ </span>\n    {{this.displayedValue | formatNumber:NUMBER_FORMAT_CHAR}}\n  </div>\n  <div class=\"arlas-metric__description\">\n    {{afterValue | translate}}\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.arlas-metric{line-height:normal;padding-top:10px;padding-bottom:10px}.arlas-metric__title{text-align:center;white-space:nowrap;display:flex;justify-content:center;font-size:16px}.arlas-metric__value{font-weight:400;font-size:25px;padding:5px 0;white-space:nowrap;display:flex;justify-content:center}.arlas-metric__description{font-size:16px;font-weight:300;display:flex;justify-content:center}\n"] }]
        }], ctorParameters: () => [], propDecorators: { beforeValue: [{
                type: Input
            }], value: [{
                type: Input
            }], afterValue: [{
                type: Input
            }], customizedCssClass: [{
                type: Input
            }], valuePrecision: [{
                type: Input
            }], shortValue: [{
                type: Input
            }], approximateValue: [{
                type: Input
            }], chartWidth: [{
                type: Input
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MetricModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: MetricModule, declarations: [MetricComponent], imports: [CommonModule,
            FormatNumberModule,
            TranslateModule], exports: [MetricComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricModule, imports: [CommonModule,
            FormatNumberModule,
            TranslateModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormatNumberModule,
                        TranslateModule
                    ],
                    declarations: [MetricComponent],
                    exports: [MetricComponent]
                }]
        }] });

var $schema$1 = "http://json-schema.org/draft-06/schema#";
var title$1 = "Powerbars input configuration";
var description$1 = "The Configuration input of  powerbars";
var type$1 = "object";
var $id$1 = "powerbars.schema.json";
var properties$1 = {
	customizedCssClass: {
		description: "Css class name to use to customize a specific powerbar's style.",
		type: "string"
	},
	keysToColors: {
		description: "List of [key, color] couples that associates a hex color to each key",
		type: "array",
		items: {
			type: "array",
			minItems: 2,
			maxItems: 2,
			items: [
				{
					description: "Key to which a color is associated",
					type: "string"
				},
				{
					description: "Hex color associated to the key",
					type: "string"
				}
			]
		}
	},
	colorsSaturationWeight: {
		description: "Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a factor (between 0 and 1) that tightens this scale to [(1-colorsSaturationWeight), 1]. Therefore all generated colors saturation will be within this scale.",
		type: "number"
	},
	useColorService: {
		description: "Whether to allow colorizing the bar according to its term or not using the ArlasColorService",
		type: "boolean"
	},
	displayFilter: {
		description: "Whether text input, to filter powerbars, is displayed",
		type: "boolean"
	},
	unit: {
		description: "Unit that a powerbar represents",
		type: "string"
	},
	filterOperator: {
		description: "Options about how to apply filters on powerbars",
		type: "object",
		properties: {
			value: {
				description: "The default operator value. \n if 'Eq', the selected powerbar is included in the ARLAS filter. \n if 'Neq', the selected powerbar is excluded in the ARLAS filter.",
				type: "string",
				"enum": [
					"Eq",
					"Neq"
				]
			},
			display: {
				description: "Whether to display a switcher between 'Eq' and 'Neq' or keep the default operator all the time",
				type: "boolean"
			}
		}
	},
	groupSelections: {
		description: "Whether to group the selected powerbars in a dedicated list or not.",
		type: "boolean"
	},
	selectWithCheckbox: {
		description: " Whether to have the option to select the powerbar using checkboxes.",
		type: "boolean"
	}
};
var powerbars_schema = {
	$schema: $schema$1,
	title: title$1,
	description: description$1,
	type: type$1,
	$id: $id$1,
	properties: properties$1
};

var powerbarsJsonSchema = /*#__PURE__*/Object.freeze({
   __proto__: null,
   $id: $id$1,
   $schema: $schema$1,
   default: powerbars_schema,
   description: description$1,
   properties: properties$1,
   title: title$1,
   type: type$1
});

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ShortenNumberPipe {
    constructor() { }
    transform(number, precision = DEFAULT_SHORTENING_PRECISION) {
        return numberToShortValue(number, precision);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberPipe, name: "shortenNumber" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'shortenNumber'
                }]
        }, {
            type: Injectable
        }], ctorParameters: () => [] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class PowerbarComponent {
    constructor() {
        /**
         * @Input : Angular
         * @description Precision when rounding numbers (ie the count next to the progress bar).
         * Default is 2.
         */
        this.numberShorteningPrecision = DEFAULT_SHORTENING_PRECISION;
        /**
         * @Input : Angular
         * @description Unit the a powerbar represents
         */
        this.unit = '';
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the bar according to its term or not using keysToColors
         */
        this.useColorService = false;
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the bar according to its term or not using a field of the data
         */
        this.useColorFromData = false;
        /**
         * @Input : Angular
         * @description Hide selected powerbar
         */
        this.hideSelected = true;
        /**
         * @Input : Angular
         * @description Whether to have the option to select the powerbar using checkboxes.
         */
        this.selectWithCheckbox = false;
        this.onCheckEvent = new EventEmitter();
        this.onClickEvent = new EventEmitter();
        this.NUMBER_FORMAT_CHAR = NUMBER_FORMAT_CHAR;
    }
    onCheck() {
        this.onCheckEvent.emit(true);
    }
    onSelect() {
        this.onClickEvent.emit(true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: PowerbarComponent, selector: "arlas-powerbar", inputs: { powerbar: "powerbar", numberShorteningPrecision: "numberShorteningPrecision", unit: "unit", useColorService: "useColorService", useColorFromData: "useColorFromData", hideSelected: "hideSelected", selectWithCheckbox: "selectWithCheckbox" }, outputs: { onCheckEvent: "onCheckEvent", onClickEvent: "onClickEvent" }, ngImport: i0, template: "<ng-container *ngIf=\"!!powerbar\">\n    <ng-container *ngIf=\"!powerbar.isSelected || (powerbar.isSelected && !hideSelected)\">\n        <div class=\"container\" (click)=\"onSelect()\"> <!-- //NOSONAR -->\n            <section *ngIf=\"selectWithCheckbox\" class=\"checkbox checkbox-{{powerbar.classSuffix}}\">\n                <mat-checkbox [checked]=\"powerbar.isSelected\" (change)=\"onCheck()\" (click)=\"$event.stopPropagation()\"></mat-checkbox> <!-- //NOSONAR -->\n            </section>\n            <section style=\"width: 100%;\">\n                <div class=\"powerbars__powerbar powerbars__powerbar--{{powerbar.classSuffix}}\"\n                    matTooltip=\"{{(powerbar.count | formatNumber:NUMBER_FORMAT_CHAR) + ' ' + (unit | translate)}}\"\n                    [matTooltipPosition]=\"'after'\">\n                    <div class=\"powerbars__powerbar--top-group\">\n                        <div [class.powerbars__powerbar--selected]=\"powerbar.isSelected\" class=\"powerbars__powerbar--term powerbars__powerbar--term-{{powerbar.classSuffix}} powerbars__powerbar--term--{{powerbar.term}}\">\n                            {{powerbar.term | translate}}\n                        </div>\n\n                        <div [class.powerbars__powerbar--selected]=\"powerbar.isSelected\" class=\"powerbars__powerbar--count powerbars__powerbar--term-{{powerbar.classSuffix}} powerbars__powerbar--term--{{powerbar.term}}\">\n                            {{powerbar.count | shortenNumber:numberShorteningPrecision}}\n                        </div>\n                    </div>\n\n                    <div *ngIf=\"!useColorService && !useColorFromData\" class=\"powerbars__powerbar--progression-default-colour\"\n                        [style.width.%]=\"powerbar.progression\"></div>\n                    <div *ngIf=\"useColorService || useColorFromData\" [style.background-color]=\"powerbar.color\"\n                        [style.border-color]=\"powerbar.color\" [style.width.%]=\"powerbar.progression\" class=\"powerbars__powerbar--progression\"></div>\n                </div>\n            </section>\n        </div>\n    </ng-container>\n</ng-container>", styles: ["@charset \"UTF-8\";.container{display:flex;align-items:flex-start;--mdc-checkbox-state-layer-size: 10px}.container ::ng-deep .mdc-checkbox__native-control{top:0!important;right:0!important;left:0!important}.container ::ng-deep .mdc-checkbox,.container ::ng-deep .mdc-checkbox__background,.container ::ng-deep .mat-mdc-checkbox-touch-target,.container ::ng-deep .mdc-checkbox__ripple,.container ::ng-deep .mat-mdc-checkbox-ripple{width:10px;height:10px;top:0!important;left:0!important}.container ::ng-deep .mat-mdc-checkbox-touch-target{transform:unset}.checkbox{margin-right:5px;padding-bottom:5px}.powerbars__powerbar{position:relative;display:flex;flex-direction:column;justify-content:space-between}.powerbars__powerbar--neutral-state,.powerbars__powerbar--selected-bar,.powerbars__powerbar--unselected-bar,.powerbars__powerbar--selected-no-mounted-bar{margin-top:0;padding-bottom:8px}.powerbars__powerbar--neutral-state:hover,.powerbars__powerbar--selected-bar:hover,.powerbars__powerbar--unselected-bar:hover{opacity:.8;cursor:pointer}.powerbars__powerbar--progression-default-colour{background-color:#88c9c3;height:4px;border-radius:2px}.powerbars__powerbar--progression{height:4px;border-radius:2px}.powerbars__powerbar--top-group{cursor:pointer;display:flex;align-items:center;justify-content:space-between;width:100%}.powerbars__powerbar--term{font-size:10px;width:70%;cursor:pointer;position:absolute;display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:left}.powerbars__powerbar--count{font-size:10px;width:100%;cursor:pointer;position:relative;display:inline-block;white-space:nowrap;text-align:right}.powerbars__powerbar--selected{font-weight:700}.powerbars__powerbar--term-unselected-bar{color:#888}.powerbars__powerbar--selected-bar,.powerbars__powerbar--selected-no-mounted-bar{background-color:#fff}\n"], dependencies: [{ kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "component", type: i8.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "disabledInteractive", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }, { kind: "pipe", type: ShortenNumberPipe, name: "shortenNumber" }, { kind: "pipe", type: FormatNumberPipe, name: "formatNumber" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-powerbar', template: "<ng-container *ngIf=\"!!powerbar\">\n    <ng-container *ngIf=\"!powerbar.isSelected || (powerbar.isSelected && !hideSelected)\">\n        <div class=\"container\" (click)=\"onSelect()\"> <!-- //NOSONAR -->\n            <section *ngIf=\"selectWithCheckbox\" class=\"checkbox checkbox-{{powerbar.classSuffix}}\">\n                <mat-checkbox [checked]=\"powerbar.isSelected\" (change)=\"onCheck()\" (click)=\"$event.stopPropagation()\"></mat-checkbox> <!-- //NOSONAR -->\n            </section>\n            <section style=\"width: 100%;\">\n                <div class=\"powerbars__powerbar powerbars__powerbar--{{powerbar.classSuffix}}\"\n                    matTooltip=\"{{(powerbar.count | formatNumber:NUMBER_FORMAT_CHAR) + ' ' + (unit | translate)}}\"\n                    [matTooltipPosition]=\"'after'\">\n                    <div class=\"powerbars__powerbar--top-group\">\n                        <div [class.powerbars__powerbar--selected]=\"powerbar.isSelected\" class=\"powerbars__powerbar--term powerbars__powerbar--term-{{powerbar.classSuffix}} powerbars__powerbar--term--{{powerbar.term}}\">\n                            {{powerbar.term | translate}}\n                        </div>\n\n                        <div [class.powerbars__powerbar--selected]=\"powerbar.isSelected\" class=\"powerbars__powerbar--count powerbars__powerbar--term-{{powerbar.classSuffix}} powerbars__powerbar--term--{{powerbar.term}}\">\n                            {{powerbar.count | shortenNumber:numberShorteningPrecision}}\n                        </div>\n                    </div>\n\n                    <div *ngIf=\"!useColorService && !useColorFromData\" class=\"powerbars__powerbar--progression-default-colour\"\n                        [style.width.%]=\"powerbar.progression\"></div>\n                    <div *ngIf=\"useColorService || useColorFromData\" [style.background-color]=\"powerbar.color\"\n                        [style.border-color]=\"powerbar.color\" [style.width.%]=\"powerbar.progression\" class=\"powerbars__powerbar--progression\"></div>\n                </div>\n            </section>\n        </div>\n    </ng-container>\n</ng-container>", styles: ["@charset \"UTF-8\";.container{display:flex;align-items:flex-start;--mdc-checkbox-state-layer-size: 10px}.container ::ng-deep .mdc-checkbox__native-control{top:0!important;right:0!important;left:0!important}.container ::ng-deep .mdc-checkbox,.container ::ng-deep .mdc-checkbox__background,.container ::ng-deep .mat-mdc-checkbox-touch-target,.container ::ng-deep .mdc-checkbox__ripple,.container ::ng-deep .mat-mdc-checkbox-ripple{width:10px;height:10px;top:0!important;left:0!important}.container ::ng-deep .mat-mdc-checkbox-touch-target{transform:unset}.checkbox{margin-right:5px;padding-bottom:5px}.powerbars__powerbar{position:relative;display:flex;flex-direction:column;justify-content:space-between}.powerbars__powerbar--neutral-state,.powerbars__powerbar--selected-bar,.powerbars__powerbar--unselected-bar,.powerbars__powerbar--selected-no-mounted-bar{margin-top:0;padding-bottom:8px}.powerbars__powerbar--neutral-state:hover,.powerbars__powerbar--selected-bar:hover,.powerbars__powerbar--unselected-bar:hover{opacity:.8;cursor:pointer}.powerbars__powerbar--progression-default-colour{background-color:#88c9c3;height:4px;border-radius:2px}.powerbars__powerbar--progression{height:4px;border-radius:2px}.powerbars__powerbar--top-group{cursor:pointer;display:flex;align-items:center;justify-content:space-between;width:100%}.powerbars__powerbar--term{font-size:10px;width:70%;cursor:pointer;position:absolute;display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:left}.powerbars__powerbar--count{font-size:10px;width:100%;cursor:pointer;position:relative;display:inline-block;white-space:nowrap;text-align:right}.powerbars__powerbar--selected{font-weight:700}.powerbars__powerbar--term-unselected-bar{color:#888}.powerbars__powerbar--selected-bar,.powerbars__powerbar--selected-no-mounted-bar{background-color:#fff}\n"] }]
        }], propDecorators: { powerbar: [{
                type: Input
            }], numberShorteningPrecision: [{
                type: Input
            }], unit: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], useColorFromData: [{
                type: Input
            }], hideSelected: [{
                type: Input
            }], selectWithCheckbox: [{
                type: Input
            }], onCheckEvent: [{
                type: Output
            }], onClickEvent: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * Powerbars component transforms a [term, occurence_count] map to a descreasingly sorted list of multiselectable bars.
 * A bar progression represents the term's occurence count.
 */
class PowerbarsComponent {
    constructor(colorService) {
        this.colorService = colorService;
        /**
         * @Input : Angular
         * @description Which level of the tree inputData to plot as powerbars
         */
        this.level = 1;
        /**
         * @Input : Angular
         * @description Powerbar title
         */
        this.powerbarTitle = '';
        /**
         * @Input : Angular
         * @description Unit the a powerbar represents
         */
        this.unit = '';
        /**
         * @Input : Angular
         * @description List of selected paths in `inputData` from which the powerbars to select
         * are determined
         */
        this.selectedPaths = new Array();
        /**
         * @Input : Angular
         * @description Whether text input, to filter powerbars, is displayed
         */
        this.displayFilterField = false;
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the bar according to its term or not using keysToColors
         */
        this.useColorService = false;
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the bar according to its term or not using a field of the data
         */
        this.useColorFromData = false;
        /**
         * @Input : Angular
         * @description Chart's width. If not specified, the chart takes the component's container width.
         */
        this.chartWidth = null;
        /**
           * @Input : Angular
           * @description Whether the powerbar is scrollable or fully displayed
           */
        this.scrollable = false;
        /**
           * @Input : Angular
           * @description Options about how to apply filters on powerbars
           * - value : The default value.
           *           if 'Eq', the selected powerbar is included in the ARLAS filter.
           *           if 'Neq', the selected powerbar is excluded in the ARLAS filter.
           * - display: Whether to display a switcher between 'Eq' and 'Neq' or keep the default operator all the time
           */
        this.filterOperator = {
            value: 'Eq',
            display: true
        };
        /**
         * @Input : Angular
         * @description Precision when rounding numbers (ie the count next to the progress bar).
         * Default is 2.
         */
        this.numberShorteningPrecision = DEFAULT_SHORTENING_PRECISION;
        /**
         * @Input : Angular
         * @description Whether to group the selected powerbars in a dedicated list or not.
         */
        this.groupSelections = true;
        /**
         * @Input : Angular
         * @description Whether to have the option to select the powerbar using checkboxes.
         */
        this.selectWithCheckbox = false;
        /**
         * @Output : Angular
         * @description Emits the filter operator
         */
        this.filterOperatorEvent = new EventEmitter();
        /**
         * @Output : Angular
         * @description Emits the list of selected paths in the tree inputData
         */
        this.selectedPowerBarEvent = new Subject();
        /**
         * @Output : Angular
         * @description Emits searched term
         */
        this.searchedTerm = new Subject();
        this.selectedPowerbarsSet = new Set();
        this.selectedPowerbarsTerms = new Set();
        /**
         * @constant
         */
        this.SELECTED_BAR = 'selected-bar';
        /**
         * @constant
         */
        this.UNSELECTED_BAR = 'unselected-bar';
        /**
         * @constant
         */
        this.NEUTRAL_STATE = 'neutral-state';
        /**
         * @constant
         */
        this.SELECTED_NO_MOUNTED_BAR = 'selected-no-mounted-bar';
        this.NUMBER_FORMAT_CHAR = NUMBER_FORMAT_CHAR;
        this._onDestroy$ = new Subject();
        this.colorService.changekeysToColors$
            .pipe(takeUntil$1(this._onDestroy$))
            .subscribe(() => {
            this.powerBarsList.forEach(p => {
                if (this.useColorService) {
                    const rgbaColor = tinycolor__default(this.colorService.getColor(p.term, this.keysToColors, this.colorsSaturationWeight)).toRgb();
                    p.color = this.getPowerbarColor(rgbaColor);
                }
            });
        });
    }
    static getPowerbarsJsonSchema() {
        return powerbarsJsonSchema;
    }
    ngOnInit() {
        if (this.missingLeafEvent) {
            this.missingLeafEvent
                .pipe(takeUntil$1(this._onDestroy$))
                .subscribe(data => {
                if (this.selectedPaths !== undefined && this.selectedPaths !== null) {
                    this.setSelectedPowerbars(this.selectedPaths);
                    data.filter(d => !!d.value).forEach(d => {
                        const value = d.value;
                        const key = d.key;
                        const missingLeaf = Array.from(this.selectedPowerbarsSet).filter(pw => pw.term === key)[0];
                        const missingLeafToUpdate = { ...missingLeaf };
                        missingLeafToUpdate.count = value;
                        missingLeafToUpdate.isSelected = true;
                        missingLeafToUpdate.classSuffix = this.SELECTED_BAR;
                        if (this.useColorService) {
                            const rgbaColor = tinycolor__default(this.colorService.getColor(missingLeafToUpdate.term, this.keysToColors, this.colorsSaturationWeight)).toRgb();
                            missingLeafToUpdate.color = this.getPowerbarColor(rgbaColor);
                        }
                        this.selectedPowerbarsSet.delete(missingLeaf);
                        this.selectedPowerbarsSet.add(missingLeafToUpdate);
                    });
                }
            });
        }
        if (this.level > 1) {
            throw new Error('Not implemented : Only level 1 is supported');
        }
        if (!this.unit) {
            this.unit = '';
        }
        if (this.groupSelections === undefined) {
            this.groupSelections = true;
        }
    }
    ngAfterViewInit() {
        if (!this.filterOperator) {
            this.filterOperator = {
                value: 'Eq',
                display: true
            };
        }
    }
    ngOnChanges(changes) {
        if (changes.inputData) {
            if (this.inputData !== undefined && this.inputData !== null) {
                this.populatePowerbars();
                this.populateSelectedPowerbars();
                this.calculateAllPowerBarsProgression();
            }
            else {
                this.inputData = { id: 'root', fieldName: 'root', fieldValue: 'root', isOther: false, children: [] };
                this.powerBarsList = [];
            }
        }
        if (changes.selectedPaths && this.selectedPaths !== undefined && this.selectedPaths !== null) {
            this.setSelectedPowerbars(this.selectedPaths);
        }
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    /**
     * @description Select or deselect a PowerBar and emits the terms list of selected bars
     */
    // Select or deselect a PowerBar from the view
    clickOnPowerbar(powerBar) {
        const selectedPaths = new Array();
        if (this.selectedPowerbarsTerms.has(powerBar.term)) {
            powerBar.isSelected = false;
            this.selectedPowerbarsTerms.delete(powerBar.term);
            this.selectedPowerbarsSet.delete(powerBar);
            if (this.selectedPowerbarsTerms.size === 0) {
                this.clearSelection();
            }
            else {
                powerBar.classSuffix = this.UNSELECTED_BAR;
            }
        }
        else {
            if (this.selectedPaths) {
                Object.assign(selectedPaths, this.selectedPaths);
            }
            powerBar.isSelected = true;
            powerBar.classSuffix = this.SELECTED_BAR;
            this.selectedPowerbarsTerms.add(powerBar.term);
            this.addSelectedPowerbarToList(powerBar, this.selectedPowerbarsSet);
            this.unselectAllButNotSelectedBars();
        }
        this.selectedPowerbarsSet.forEach(pb => {
            selectedPaths.push(pb.path);
        });
        this.selectedPowerbarsSet = this.sortSelectedPowerBars(this.selectedPowerbarsSet);
        this.selectedPowerBarEvent.next(selectedPaths);
    }
    /**
     * @description Set selected powerbars from outside of the component
     * @param selectedPaths selects the powerbars whose terms are in the selected paths
     */
    setSelectedPowerbars(selectedPaths) {
        const selectedPowerbarsTerms = new Set();
        const selectedPowerbarsList = new Set();
        selectedPaths.forEach(path => {
            const currentPath = path.length <= this.level ? path : path.slice(path.length - this.level);
            let powerBar = currentPath.length > 1 ? this.getPowerbar(currentPath[0].fieldValue, currentPath[1].fieldValue) :
                this.getPowerbar(currentPath[0].fieldValue, 'root');
            if (powerBar !== null) {
                powerBar.isSelected = true;
                powerBar.classSuffix = this.SELECTED_BAR;
                if (this.useColorService) {
                    const rgbaColor = tinycolor__default(this.colorService.getColor(powerBar.term, this.keysToColors, this.colorsSaturationWeight)).toRgb();
                    powerBar.color = this.getPowerbarColor(rgbaColor);
                }
            }
            else {
                powerBar = currentPath.length > 1 ? new PowerBar(currentPath[0].fieldValue, currentPath[1].fieldValue, 0) :
                    new PowerBar(currentPath[0].fieldValue, 'root', 0);
                powerBar.path = currentPath;
                powerBar.progression = 0;
                powerBar.isSelected = true;
                powerBar.classSuffix = this.SELECTED_NO_MOUNTED_BAR;
            }
            selectedPowerbarsTerms.add(powerBar.term);
            this.addSelectedPowerbarToList(powerBar, selectedPowerbarsList);
        });
        this.selectedPowerbarsTerms = selectedPowerbarsTerms;
        this.selectedPowerbarsSet = this.sortSelectedPowerBars(selectedPowerbarsList);
        this.unselectAllButNotSelectedBars();
    }
    onKeyUp(searchText) {
        this.searchedTerm.next(searchText);
    }
    setOperator(op) {
        if (this.filterOperator.value !== op) {
            this.filterOperator.value = op;
            this.filterOperatorEvent.next(op);
        }
    }
    clearSelection() {
        this.powerBarsList.forEach(powerBar => {
            powerBar.classSuffix = this.NEUTRAL_STATE;
            powerBar.isSelected = false;
        });
    }
    addSelectedPowerbarToList(powerBar, selectedPowerbarsList) {
        // add powerbar to selectedPowerbarsList
        this.removePowerbarFromSelectedOnes(powerBar, selectedPowerbarsList);
        selectedPowerbarsList.add(powerBar);
    }
    populatePowerbars() {
        this.powerBarsList = this.fetchPowerbarsList(this.level, this.inputData);
    }
    fetchPowerbarsList(level, data, powerBarsList, recursivityCount, path) {
        if (recursivityCount === undefined) {
            recursivityCount = 0;
        }
        if (!powerBarsList) {
            powerBarsList = new Array();
        }
        // Each powerbar has a path attribute to the parrent node
        if (!path) {
            path = new Array();
        }
        if (recursivityCount < level - 1) {
            data.children.forEach(child => {
                const currentPath = [];
                Object.assign(currentPath, path);
                currentPath.push({ fieldName: child.fieldName, fieldValue: child.fieldValue });
                this.fetchPowerbarsList(level, child, powerBarsList, ++recursivityCount, currentPath);
            });
        }
        else {
            data.children.forEach(child => {
                const currentPath = [];
                Object.assign(currentPath, path);
                currentPath.push({ fieldName: child.fieldName, fieldValue: child.fieldValue });
                if (!child.isOther) {
                    const powerBar = new PowerBar(child.fieldValue, data.fieldValue, child.metricValue);
                    currentPath.reverse();
                    powerBar.path = currentPath;
                    if (this.useColorService) {
                        const rgbaColor = tinycolor__default(this.colorService.getColor(powerBar.term, this.keysToColors, this.colorsSaturationWeight)).toRgb();
                        powerBar.color = this.getPowerbarColor(rgbaColor);
                    }
                    if (this.useColorFromData) {
                        powerBar.color = child.color.toString().startsWith('#') ? child.color.toString() : '#'.concat(child.color.toString());
                    }
                    powerBarsList.push(powerBar);
                }
            });
            return powerBarsList;
        }
    }
    populateSelectedPowerbars() {
        if (this.selectedPowerbarsTerms !== undefined && this.selectedPowerbarsTerms.size > 0) {
            this.setSelectedPowerbars(this.selectedPaths);
        }
    }
    calculateAllPowerBarsProgression() {
        // TODO : Manage correctly when count == NaN
        let sum = 0;
        // calculate the sum
        this.powerBarsList.forEach(powerBar => {
            if (powerBar.count.toString() === 'NaN') {
                powerBar.count = 0;
            }
            sum += powerBar.count;
        });
        this.selectedPowerbarsSet.forEach(selectedPowerBar => {
            if (selectedPowerBar.count.toString() === 'NaN') {
                selectedPowerBar.count = 0;
            }
            if (this.getPowerbar(selectedPowerBar.term, selectedPowerBar.parentTerm) === null) {
                sum += selectedPowerBar.count;
            }
        });
        // calculate progression
        this.powerBarsList.forEach(powerBar => {
            powerBar.progression = powerBar.count / sum * 100;
            if (powerBar.progression !== 0 && powerBar.progression !== 100) {
                powerBar.progression += 1;
            }
            powerBar.progression = Math.min(powerBar.progression, 100);
        });
        this.selectedPowerbarsSet.forEach(selectedPowerBar => {
            selectedPowerBar.progression = selectedPowerBar.count / sum * 100;
            if (selectedPowerBar.progression !== 0 && selectedPowerBar.progression !== 100) {
                selectedPowerBar.progression += 1;
            }
            selectedPowerBar.progression = Math.min(selectedPowerBar.progression, 100);
        });
    }
    unselectAllButNotSelectedBars() {
        if (this.selectedPowerbarsTerms.size === 0) {
            this.selectedPowerbarsSet = new Set();
            this.clearSelection();
        }
        else {
            this.powerBarsList.forEach(powerBar => {
                if (!this.selectedPowerbarsTerms.has(powerBar.term)) {
                    powerBar.classSuffix = this.UNSELECTED_BAR;
                    powerBar.isSelected = false;
                }
            });
        }
    }
    // Sort the selected PowerBars decreasingly. And recalculate the progression of the bars in this array.
    sortSelectedPowerBars(selectedPowerbarsList) {
        const selectedPowerbarsArray = Array.from(selectedPowerbarsList);
        const sortedSelectedPowerbarsList = new Set();
        selectedPowerbarsArray.forEach(powerBar => {
            sortedSelectedPowerbarsList.add(powerBar);
        });
        return sortedSelectedPowerbarsList;
    }
    // removes the powerbar that has the same term in selectedPowerbarsList but not the same instance
    removePowerbarFromSelectedOnes(powerBar, selectedPowerbarsList) {
        let powerbarToRemove;
        selectedPowerbarsList.forEach(selectedPowerbar => {
            if (selectedPowerbar.term === powerBar.term) {
                powerbarToRemove = selectedPowerbar;
            }
        });
        selectedPowerbarsList.delete(powerbarToRemove);
    }
    /**
     * @description Gets the powerbar by its term and the term of it's parent node
     *
     */
    getPowerbar(powerbarTerm, powerbarParentTerm) {
        let foundPowerbar = null;
        this.powerBarsList.forEach(powerbar => {
            if (powerbar.term === powerbarTerm && powerbar.parentTerm === powerbarParentTerm) {
                foundPowerbar = powerbar;
            }
        });
        return foundPowerbar;
    }
    getPowerbarColor(rgbaColor) {
        return 'rgba(' + [rgbaColor.r, rgbaColor.g, rgbaColor.b, 0.7].join(',') + ')';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarsComponent, deps: [{ token: ArlasColorService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: PowerbarsComponent, selector: "arlas-powerbars", inputs: { inputData: "inputData", level: "level", powerbarTitle: "powerbarTitle", unit: "unit", customizedCssClass: "customizedCssClass", selectedPaths: "selectedPaths", displayFilterField: "displayFilterField", keysToColors: "keysToColors", colorsSaturationWeight: "colorsSaturationWeight", useColorService: "useColorService", useColorFromData: "useColorFromData", chartWidth: "chartWidth", scrollable: "scrollable", filterOperator: "filterOperator", missingLeafEvent: "missingLeafEvent", numberShorteningPrecision: "numberShorteningPrecision", groupSelections: "groupSelections", selectWithCheckbox: "selectWithCheckbox" }, outputs: { filterOperatorEvent: "filterOperatorEvent", selectedPowerBarEvent: "selectedPowerBarEvent", searchedTerm: "searchedTerm" }, usesOnChanges: true, ngImport: i0, template: "<div [style.width.px]=\"!!chartWidth ? chartWidth : 'unset'\">\n  <div class=\"tools\">\n    <div *ngIf=\"!displayFilterField\" class=\"powerbars--title\">{{powerbarTitle | translate}}</div>\n    <div class=\"powerbars--search\" *ngIf=\"displayFilterField\">\n      <form (keydown.enter)=\"$event.preventDefault()\">\n        <mat-form-field class=\"powerbars--search-field\">\n          <input #searchText type=\"text\" autocomplete=\"off\" placeholder=\"{{powerbarTitle | translate}}\" matInput\n            class=\"powerbars--search-input\" (keyup)=\"onKeyUp(searchText.value)\" name=\"search\">\n        </mat-form-field>\n      </form>\n    </div>\n    <ng-container *ngIf=\"filterOperator\">\n      <div *ngIf=\"filterOperator?.display\" class=\"include_exclude\">\n        <div class=\"operation\" [class.operation--selected]=\"filterOperator?.value === 'Eq'\" (click)=\"setOperator('Eq')\">{{'include' | translate}}</div> <!-- //NOSONAR -->\n        <div class=\"operation\" [class.operation--selected]=\"filterOperator?.value === 'Neq'\" (click)=\"setOperator('Neq')\">{{'exclude' | translate}}</div> <!-- //NOSONAR -->\n      </div>\n      <div *ngIf=\"!filterOperator?.display && filterOperator?.value === 'Neq'\" class=\"include_exclude\">\n        <div class=\"operation exclude\">{{'exclude' | translate}}</div>\n      </div>\n    </ng-container>\n  </div>\n\n  <div class=\"powerbars--container\" [class.powerbars--container__scrollable]=\"scrollable\" [ngClass]=\"customizedCssClass\">\n    <ng-container *ngIf=\"groupSelections\">\n      <div *ngIf=\"selectedPowerbarsSet.size !== 0\" [class.powerbar-selected-scrollable]=\"scrollable\"\n        [style.min-height.px]=\"selectedPowerbarsSet.size > 5 ? 131 : selectedPowerbarsSet.size * 26\">\n        <div *ngFor=\"let selectedPowerbar of selectedPowerbarsSet\">\n          <arlas-powerbar\n            [unit]=\"unit\"\n            [powerbar]=\"selectedPowerbar\"\n            [useColorFromData]=\"useColorFromData\"\n            [useColorService]=\"useColorService\"\n            [hideSelected]=\"false\"\n            [selectWithCheckbox]=\"selectWithCheckbox\"\n            [numberShorteningPrecision]=\"numberShorteningPrecision\"\n            (onCheckEvent)=\"clickOnPowerbar(selectedPowerbar)\"\n            (onClickEvent)=\"clickOnPowerbar(selectedPowerbar)\"\n          ></arlas-powerbar>\n        </div>\n      </div>\n    </ng-container>\n\n    <div [class.powerbar-list-scrollable]=\"scrollable\">\n      <div *ngFor=\"let powerbar of powerBarsList\">\n        <arlas-powerbar\n          [unit]=\"unit\"\n          [powerbar]=\"powerbar\"\n          [useColorFromData]=\"useColorFromData\"\n          [useColorService]=\"useColorService\"\n          [numberShorteningPrecision]=\"numberShorteningPrecision\"\n          [selectWithCheckbox]=\"selectWithCheckbox\"\n          [hideSelected]=\"groupSelections\"\n          (onCheckEvent)=\"clickOnPowerbar(powerbar)\"\n          (onClickEvent)=\"clickOnPowerbar(powerbar)\"\n        ></arlas-powerbar>\n      </div>\n    </div>\n  </div>\n</div>", styles: ["@charset \"UTF-8\";.tools .powerbars--search .mat-mdc-form-field{width:100%}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mdc-text-field--filled{background-color:unset}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mat-mdc-form-field-focus-overlay{opacity:0}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mdc-text-field{padding:unset}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mat-mdc-form-field-infix{font-size:14px;min-height:unset;padding-top:0!important;padding-bottom:0!important}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}.tools .include_exclude{display:flex;align-items:baseline}.tools .include_exclude .operation{font-size:10px;color:#aaa;border-radius:3px;margin-right:5px;cursor:pointer;padding-bottom:5px}.tools .include_exclude .operation--selected{color:#555;font-weight:700}.tools .include_exclude .exclude{color:#555;cursor:unset}.powerbars--container{height:100%;overflow-y:auto;overflow-x:hidden;padding-bottom:8px}.powerbars--container__scrollable{display:flex;flex-direction:column;max-height:255px}.powerbars--container .powerbar-selected-scrollable{max-height:131px;border-bottom:1px solid rgb(209,209,209);overflow-y:auto;overflow-x:clip;padding-bottom:2px;padding-right:5px}.powerbars--container .powerbar-list-scrollable{overflow-y:auto;overflow-x:clip;padding-right:5px;padding-bottom:5px}::-webkit-scrollbar{width:6px;background-color:#f5f5f5}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}\n"], dependencies: [{ kind: "directive", type: i2$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$1.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i4$2.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "component", type: PowerbarComponent, selector: "arlas-powerbar", inputs: ["powerbar", "numberShorteningPrecision", "unit", "useColorService", "useColorFromData", "hideSelected", "selectWithCheckbox"], outputs: ["onCheckEvent", "onClickEvent"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-powerbars', template: "<div [style.width.px]=\"!!chartWidth ? chartWidth : 'unset'\">\n  <div class=\"tools\">\n    <div *ngIf=\"!displayFilterField\" class=\"powerbars--title\">{{powerbarTitle | translate}}</div>\n    <div class=\"powerbars--search\" *ngIf=\"displayFilterField\">\n      <form (keydown.enter)=\"$event.preventDefault()\">\n        <mat-form-field class=\"powerbars--search-field\">\n          <input #searchText type=\"text\" autocomplete=\"off\" placeholder=\"{{powerbarTitle | translate}}\" matInput\n            class=\"powerbars--search-input\" (keyup)=\"onKeyUp(searchText.value)\" name=\"search\">\n        </mat-form-field>\n      </form>\n    </div>\n    <ng-container *ngIf=\"filterOperator\">\n      <div *ngIf=\"filterOperator?.display\" class=\"include_exclude\">\n        <div class=\"operation\" [class.operation--selected]=\"filterOperator?.value === 'Eq'\" (click)=\"setOperator('Eq')\">{{'include' | translate}}</div> <!-- //NOSONAR -->\n        <div class=\"operation\" [class.operation--selected]=\"filterOperator?.value === 'Neq'\" (click)=\"setOperator('Neq')\">{{'exclude' | translate}}</div> <!-- //NOSONAR -->\n      </div>\n      <div *ngIf=\"!filterOperator?.display && filterOperator?.value === 'Neq'\" class=\"include_exclude\">\n        <div class=\"operation exclude\">{{'exclude' | translate}}</div>\n      </div>\n    </ng-container>\n  </div>\n\n  <div class=\"powerbars--container\" [class.powerbars--container__scrollable]=\"scrollable\" [ngClass]=\"customizedCssClass\">\n    <ng-container *ngIf=\"groupSelections\">\n      <div *ngIf=\"selectedPowerbarsSet.size !== 0\" [class.powerbar-selected-scrollable]=\"scrollable\"\n        [style.min-height.px]=\"selectedPowerbarsSet.size > 5 ? 131 : selectedPowerbarsSet.size * 26\">\n        <div *ngFor=\"let selectedPowerbar of selectedPowerbarsSet\">\n          <arlas-powerbar\n            [unit]=\"unit\"\n            [powerbar]=\"selectedPowerbar\"\n            [useColorFromData]=\"useColorFromData\"\n            [useColorService]=\"useColorService\"\n            [hideSelected]=\"false\"\n            [selectWithCheckbox]=\"selectWithCheckbox\"\n            [numberShorteningPrecision]=\"numberShorteningPrecision\"\n            (onCheckEvent)=\"clickOnPowerbar(selectedPowerbar)\"\n            (onClickEvent)=\"clickOnPowerbar(selectedPowerbar)\"\n          ></arlas-powerbar>\n        </div>\n      </div>\n    </ng-container>\n\n    <div [class.powerbar-list-scrollable]=\"scrollable\">\n      <div *ngFor=\"let powerbar of powerBarsList\">\n        <arlas-powerbar\n          [unit]=\"unit\"\n          [powerbar]=\"powerbar\"\n          [useColorFromData]=\"useColorFromData\"\n          [useColorService]=\"useColorService\"\n          [numberShorteningPrecision]=\"numberShorteningPrecision\"\n          [selectWithCheckbox]=\"selectWithCheckbox\"\n          [hideSelected]=\"groupSelections\"\n          (onCheckEvent)=\"clickOnPowerbar(powerbar)\"\n          (onClickEvent)=\"clickOnPowerbar(powerbar)\"\n        ></arlas-powerbar>\n      </div>\n    </div>\n  </div>\n</div>", styles: ["@charset \"UTF-8\";.tools .powerbars--search .mat-mdc-form-field{width:100%}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mdc-text-field--filled{background-color:unset}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mat-mdc-form-field-focus-overlay{opacity:0}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mdc-text-field{padding:unset}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mat-mdc-form-field-infix{font-size:14px;min-height:unset;padding-top:0!important;padding-bottom:0!important}.tools .powerbars--search .mat-mdc-form-field ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}.tools .include_exclude{display:flex;align-items:baseline}.tools .include_exclude .operation{font-size:10px;color:#aaa;border-radius:3px;margin-right:5px;cursor:pointer;padding-bottom:5px}.tools .include_exclude .operation--selected{color:#555;font-weight:700}.tools .include_exclude .exclude{color:#555;cursor:unset}.powerbars--container{height:100%;overflow-y:auto;overflow-x:hidden;padding-bottom:8px}.powerbars--container__scrollable{display:flex;flex-direction:column;max-height:255px}.powerbars--container .powerbar-selected-scrollable{max-height:131px;border-bottom:1px solid rgb(209,209,209);overflow-y:auto;overflow-x:clip;padding-bottom:2px;padding-right:5px}.powerbars--container .powerbar-list-scrollable{overflow-y:auto;overflow-x:clip;padding-right:5px;padding-bottom:5px}::-webkit-scrollbar{width:6px;background-color:#f5f5f5}::-webkit-scrollbar-track{-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}\n"] }]
        }], ctorParameters: () => [{ type: ArlasColorService }], propDecorators: { inputData: [{
                type: Input
            }], level: [{
                type: Input
            }], powerbarTitle: [{
                type: Input
            }], unit: [{
                type: Input
            }], customizedCssClass: [{
                type: Input
            }], selectedPaths: [{
                type: Input
            }], displayFilterField: [{
                type: Input
            }], keysToColors: [{
                type: Input
            }], colorsSaturationWeight: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], useColorFromData: [{
                type: Input
            }], chartWidth: [{
                type: Input
            }], scrollable: [{
                type: Input
            }], filterOperator: [{
                type: Input
            }], missingLeafEvent: [{
                type: Input
            }], numberShorteningPrecision: [{
                type: Input
            }], groupSelections: [{
                type: Input
            }], selectWithCheckbox: [{
                type: Input
            }], filterOperatorEvent: [{
                type: Output
            }], selectedPowerBarEvent: [{
                type: Output
            }], searchedTerm: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class ShortenNumberModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberModule, declarations: [ShortenNumberPipe], exports: [ShortenNumberPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ShortenNumberModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [
                        ShortenNumberPipe
                    ],
                    exports: [
                        ShortenNumberPipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class PowerbarModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: PowerbarModule, declarations: [PowerbarComponent], imports: [CommonModule,
            MatTooltipModule,
            MatCheckboxModule,
            TranslateModule,
            ShortenNumberModule,
            FormatNumberModule], exports: [PowerbarComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarModule, imports: [CommonModule,
            MatTooltipModule,
            MatCheckboxModule,
            TranslateModule,
            ShortenNumberModule,
            FormatNumberModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatTooltipModule,
                        MatCheckboxModule,
                        TranslateModule,
                        ShortenNumberModule,
                        FormatNumberModule
                    ],
                    declarations: [PowerbarComponent],
                    exports: [PowerbarComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class PowerbarsModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: PowerbarsModule, declarations: [PowerbarsComponent], imports: [CommonModule,
            MatCardModule,
            MatIconModule,
            MatTooltipModule,
            MatMenuModule,
            MatInputModule,
            MatButtonModule,
            MatButtonToggleModule, ColorGeneratorModule, TranslateModule,
            PowerbarModule,
            FormatNumberModule], exports: [PowerbarsComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarsModule, imports: [CommonModule,
            MatCardModule,
            MatIconModule,
            MatTooltipModule,
            MatMenuModule,
            MatInputModule,
            MatButtonModule,
            MatButtonToggleModule,
            ColorGeneratorModule.forRoot(),
            TranslateModule,
            PowerbarModule,
            FormatNumberModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PowerbarsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatCardModule,
                        MatIconModule,
                        MatTooltipModule,
                        MatMenuModule,
                        MatInputModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        ColorGeneratorModule.forRoot(),
                        TranslateModule,
                        PowerbarModule,
                        FormatNumberModule
                    ],
                    declarations: [PowerbarsComponent],
                    exports: [PowerbarsComponent]
                }]
        }] });

var $schema = "http://json-schema.org/draft-06/schema#";
var title = "Metric Table inputs configuration";
var description = "The inputs configuration input of a metrics table.";
var type = "object";
var $id = "metrics-table.schema.json";
var properties = {
	filterOperator: {
		description: "Options about how to apply filters on the metric table.",
		type: "object",
		properties: {
			value: {
				description: "The default operator value. \n if 'Eq', the selected line of the table is included in the ARLAS filter. \n if 'Neq', the selected line is marked as excluded in the ARLAS filter.",
				type: "string",
				"enum": [
					"Eq",
					"Neq"
				]
			},
			display: {
				description: "Whether to display a switcher between 'Eq' and 'Neq' or keep the default operator all the time",
				type: "boolean"
			}
		}
	},
	useColorService: {
		description: "Whether to allow colorizing the bars according to its term or not using the ArlasColorService",
		type: "boolean"
	},
	applyColorTo: {
		description: "Choose how to apply colors to the table. By column : all the bars in same column will have the same color. By row : all the bars in the same row, will have the same color.",
		type: "string",
		"enum": [
			"column",
			"row"
		]
	},
	headerDisplayMode: {
		description: "Allows to choose what level of details to display in headers. 'chip' only displays a circular chip. 'title' only displays the title. 'full' displays both.",
		type: "string",
		"enum": [
			"chip",
			"title",
			"full"
		]
	},
	normaliseBy: {
		description: "Normalise bars progression based on the maximum value of each column OR of the whole table",
		type: "string",
		"enum": [
			"table",
			"column"
		]
	},
	selectWithCheckbox: {
		description: "Display a checkbox next to the terms that allows to select the row.",
		type: "boolean"
	},
	showRowField: {
		description: "Display the name of the field use to retrieve row values for each sub table.",
		type: "boolean"
	}
};
var required = [
];
var metricsTable_schema = {
	$schema: $schema,
	title: title,
	description: description,
	type: type,
	$id: $id,
	properties: properties,
	required: required
};

var metricTableJsonSchema = /*#__PURE__*/Object.freeze({
   __proto__: null,
   $id: $id,
   $schema: $schema,
   default: metricsTable_schema,
   description: description,
   properties: properties,
   required: required,
   title: title,
   type: type
});

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MetricsTableRowComponent {
    constructor() {
        this.useColorService = false;
        this.useColorFromData = false;
        this.pendingMode = false;
        this.powerBars = [];
        this.rowSelected = new EventEmitter();
    }
    selectRow() {
        this.updateRowState();
    }
    onCheck() {
        this.updateRowState();
    }
    updateRowState() {
        this.metricsTableRow.selected = !this.metricsTableRow.selected;
        this.rowSelected.emit(this.metricsTableRow.term);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableRowComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MetricsTableRowComponent, selector: "arlas-multi-bars-row", inputs: { displayCheckBox: "displayCheckBox", hideSelection: "hideSelection", metricsTableRow: "metricsTableRow", useColorService: "useColorService", useColorFromData: "useColorFromData", colors: "colors", selected: "selected", pendingMode: "pendingMode", powerBars: "powerBars" }, outputs: { rowSelected: "rowSelected" }, ngImport: i0, template: "<tr *ngIf=\"!metricsTableRow?.selected || !hideSelection\" [ngClass]=\"{\n'multi-bar-row--unselected': !metricsTableRow?.selected,\n'multi-bar-row--selected': metricsTableRow?.selected,\n'multi-bar-row--pending': !metricsTableRow?.selected && pendingMode\n}\" (click)=\"selectRow()\" class=\"multi-bar-row\">\n  <th class=\"terms-head\" scope=\"row\" class=\"multi-bar-row__header\">\n    <div class=\"header\">\n      <section *ngIf=\"displayCheckBox\"  (click)=\"$event.stopPropagation()\">\n        <mat-checkbox [checked]=\"metricsTableRow?.selected\" (change)=\"onCheck()\"></mat-checkbox>\n      </section>\n      <span class=\"header-title\" [matTooltip]=\"metricsTableRow?.term\">\n           {{metricsTableRow?.term | uppercase}}\n      </span>\n    </div>\n  </th>\n  <td  class=\"column-head\" class=\"multi-bar-row__data\" *ngFor=\"let powerBar of powerBars\">\n    <div>\n    <arlas-powerbar [useColorFromData]=\"useColorFromData\"\n                      [useColorService]=\"useColorService\"\n                      *ngIf=\"powerBar.count !== null && powerBar.count !== undefined; else noData\"\n                      [powerbar]=\"powerBar\"></arlas-powerbar>\n      <ng-template #noData>\n        <div class=\"empty-cell\">\n          <span class=\"empty\"></span>\n          <span class=\"empty\"></span>\n        </div>\n      </ng-template>\n    </div>\n  </td>\n</tr>\n", styles: ["@charset \"UTF-8\";:host{display:table-row-group}:host ::ng-deep{--mdc-checkbox-state-layer-size: 10px}:host ::ng-deep arlas-powerbar .powerbars__powerbar--count{text-align:left}:host ::ng-deep arlas-powerbar .powerbars__powerbar--term{display:none}:host ::ng-deep arlas-powerbar .powerbars__powerbar--neutral-state:hover,:host ::ng-deep arlas-powerbar .powerbars__powerbar--selected-bar:hover,:host ::ng-deep arlas-powerbar .powerbars__powerbar--unselected-bar:hover{opacity:1;cursor:pointer}:host ::ng-deep ::ng-deep .mdc-checkbox__native-control{top:0!important;right:0!important;left:0!important}:host ::ng-deep ::ng-deep .mdc-checkbox,:host ::ng-deep ::ng-deep .mdc-checkbox__background,:host ::ng-deep ::ng-deep .mat-mdc-checkbox-touch-target,:host ::ng-deep ::ng-deep .mdc-checkbox__ripple,:host ::ng-deep ::ng-deep .mat-mdc-checkbox-ripple{width:10px;height:10px;top:0!important;left:0!important}:host ::ng-deep ::ng-deep .mat-mdc-checkbox-touch-target{transform:unset}:host ::ng-deep .checkbox{margin-right:5px;padding-bottom:5px}:host ::ng-deep .checkbox-unselected-bar ::ng-deep .mat-checkbox-frame{border-color:#0000000a!important}.multi-bar-row{height:25px;cursor:pointer}.multi-bar-row--selected{font-weight:700;opacity:1}.multi-bar-row--selected .header{font-weight:700!important}.multi-bar-row--unselected:hover{opacity:.8}.multi-bar-row--pending{opacity:.5}.multi-bar-row__header{padding:0 6px;font-size:12px;vertical-align:middle}.multi-bar-row__header .header{display:flex;align-items:center;gap:5px;font-weight:400}.multi-bar-row__header .header-title{text-overflow:ellipsis;overflow:hidden;padding:0 3px}.multi-bar-row__data{padding:0 6px;vertical-align:middle}.multi-bar-row td,.multi-bar-row th{white-space:nowrap}.empty-cell{height:10px;display:flex;gap:4px;align-items:center}.empty{display:inline-block;width:5px;border:solid 1px rgba(0,0,0,.2)}.terms-head{width:80px}.column-head{width:70px}\n"], dependencies: [{ kind: "component", type: i8.MatCheckbox, selector: "mat-checkbox", inputs: ["aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "disableRipple", "tabIndex", "color", "disabledInteractive", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }, { kind: "directive", type: i2$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: PowerbarComponent, selector: "arlas-powerbar", inputs: ["powerbar", "numberShorteningPrecision", "unit", "useColorService", "useColorFromData", "hideSelected", "selectWithCheckbox"], outputs: ["onCheckEvent", "onClickEvent"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "pipe", type: i2$1.UpperCasePipe, name: "uppercase" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableRowComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-multi-bars-row', template: "<tr *ngIf=\"!metricsTableRow?.selected || !hideSelection\" [ngClass]=\"{\n'multi-bar-row--unselected': !metricsTableRow?.selected,\n'multi-bar-row--selected': metricsTableRow?.selected,\n'multi-bar-row--pending': !metricsTableRow?.selected && pendingMode\n}\" (click)=\"selectRow()\" class=\"multi-bar-row\">\n  <th class=\"terms-head\" scope=\"row\" class=\"multi-bar-row__header\">\n    <div class=\"header\">\n      <section *ngIf=\"displayCheckBox\"  (click)=\"$event.stopPropagation()\">\n        <mat-checkbox [checked]=\"metricsTableRow?.selected\" (change)=\"onCheck()\"></mat-checkbox>\n      </section>\n      <span class=\"header-title\" [matTooltip]=\"metricsTableRow?.term\">\n           {{metricsTableRow?.term | uppercase}}\n      </span>\n    </div>\n  </th>\n  <td  class=\"column-head\" class=\"multi-bar-row__data\" *ngFor=\"let powerBar of powerBars\">\n    <div>\n    <arlas-powerbar [useColorFromData]=\"useColorFromData\"\n                      [useColorService]=\"useColorService\"\n                      *ngIf=\"powerBar.count !== null && powerBar.count !== undefined; else noData\"\n                      [powerbar]=\"powerBar\"></arlas-powerbar>\n      <ng-template #noData>\n        <div class=\"empty-cell\">\n          <span class=\"empty\"></span>\n          <span class=\"empty\"></span>\n        </div>\n      </ng-template>\n    </div>\n  </td>\n</tr>\n", styles: ["@charset \"UTF-8\";:host{display:table-row-group}:host ::ng-deep{--mdc-checkbox-state-layer-size: 10px}:host ::ng-deep arlas-powerbar .powerbars__powerbar--count{text-align:left}:host ::ng-deep arlas-powerbar .powerbars__powerbar--term{display:none}:host ::ng-deep arlas-powerbar .powerbars__powerbar--neutral-state:hover,:host ::ng-deep arlas-powerbar .powerbars__powerbar--selected-bar:hover,:host ::ng-deep arlas-powerbar .powerbars__powerbar--unselected-bar:hover{opacity:1;cursor:pointer}:host ::ng-deep ::ng-deep .mdc-checkbox__native-control{top:0!important;right:0!important;left:0!important}:host ::ng-deep ::ng-deep .mdc-checkbox,:host ::ng-deep ::ng-deep .mdc-checkbox__background,:host ::ng-deep ::ng-deep .mat-mdc-checkbox-touch-target,:host ::ng-deep ::ng-deep .mdc-checkbox__ripple,:host ::ng-deep ::ng-deep .mat-mdc-checkbox-ripple{width:10px;height:10px;top:0!important;left:0!important}:host ::ng-deep ::ng-deep .mat-mdc-checkbox-touch-target{transform:unset}:host ::ng-deep .checkbox{margin-right:5px;padding-bottom:5px}:host ::ng-deep .checkbox-unselected-bar ::ng-deep .mat-checkbox-frame{border-color:#0000000a!important}.multi-bar-row{height:25px;cursor:pointer}.multi-bar-row--selected{font-weight:700;opacity:1}.multi-bar-row--selected .header{font-weight:700!important}.multi-bar-row--unselected:hover{opacity:.8}.multi-bar-row--pending{opacity:.5}.multi-bar-row__header{padding:0 6px;font-size:12px;vertical-align:middle}.multi-bar-row__header .header{display:flex;align-items:center;gap:5px;font-weight:400}.multi-bar-row__header .header-title{text-overflow:ellipsis;overflow:hidden;padding:0 3px}.multi-bar-row__data{padding:0 6px;vertical-align:middle}.multi-bar-row td,.multi-bar-row th{white-space:nowrap}.empty-cell{height:10px;display:flex;gap:4px;align-items:center}.empty{display:inline-block;width:5px;border:solid 1px rgba(0,0,0,.2)}.terms-head{width:80px}.column-head{width:70px}\n"] }]
        }], ctorParameters: () => [], propDecorators: { displayCheckBox: [{
                type: Input
            }], hideSelection: [{
                type: Input
            }], metricsTableRow: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], useColorFromData: [{
                type: Input
            }], colors: [{
                type: Input
            }], selected: [{
                type: Input
            }], pendingMode: [{
                type: Input
            }], powerBars: [{
                type: Input
            }], rowSelected: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetCollectionDisplayNamePipe {
    constructor(collectionService) {
        this.collectionService = collectionService;
    }
    transform(value, ...args) {
        if (!value) {
            return '';
        }
        return this.collectionService.getDisplayName(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionDisplayNamePipe, deps: [{ token: CollectionService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionDisplayNamePipe, name: "getCollectionDisplayName" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionDisplayNamePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'getCollectionDisplayName'
                }]
        }], ctorParameters: () => [{ type: CollectionService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetFieldDisplayNamePipe {
    constructor(collectionService) {
        this.collectionService = collectionService;
    }
    transform(value) {
        if (!value) {
            return '';
        }
        return this.collectionService.getDisplayFieldName(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetFieldDisplayNamePipe, deps: [{ token: CollectionService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetFieldDisplayNamePipe, name: "getFieldDisplayName" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetFieldDisplayNamePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'getFieldDisplayName'
                }]
        }], ctorParameters: () => [{ type: CollectionService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MetricsTableComponent {
    constructor(colorService, cdr) {
        this.colorService = colorService;
        this.cdr = cdr;
        /**
           * @Input : Angular
           * @description Options about how to apply filters on metrics table
           * - value : The default value.
           *           if 'Eq', the selected line is included in the ARLAS filter.
           *           if 'Neq', the selected line is excluded in the ARLAS filter.
           * - display: Whether to display a switcher between 'Eq' and 'Neq' or keep the default operator all the time
           */
        this.filterOperator = {
            value: 'Eq',
            display: true
        };
        /**
         * @Output : Angular
         * @description Emits the filter operator
         */
        this.filterOperatorEvent = new EventEmitter();
        /**
         * @Input : Angular
         * @description Whether to allow colorizing the bar according to its term or not using keysToColors
         */
        this.useColorService = false;
        /**
         * @Input : Angular
         * @description Choose how to apply colors to the table. By column : all the bars in same column will have the same color.
         * By row : all the bars in the same row, will have the same color.
         */
        this.applyColorTo = 'column';
        /**
         * @description Allow to select a row by a checkbox
         */
        this.selectWithCheckbox = true;
        /**
         * @description Allow to select display mode for headers.
         */
        this.headerDisplayMode = 'chip';
        /**
         * @description Normalise bars progression based on the maximum value of each column OR of the whole table
         */
        this.normaliseBy = 'table';
        this.showRowField = true;
        this.onSelect = new EventEmitter();
        // keep it time complexity o(1) with get.
        /** Map of <term-list.of.powerbars.corresponding.to.this.term.> */
        this.powerBarsMap = new Map();
        this.selectedKeys = new Set();
        this.selectedRows = new Map();
        this.pendingMode = false;
        this.titleAreDifferent = true;
        // preserve order of insertion
        this.originalOrder = (a, b) => 0;
        this.colorService.changekeysToColors$.subscribe(() => {
            this.powerBarsMap.forEach(powerbarsRow => {
                powerbarsRow.forEach(p => {
                    if (this.useColorService) {
                        this.defineColor(p.term);
                    }
                });
            });
        });
    }
    ngOnInit() {
        if (this.metricsTable) {
            this.updateSelectedTermWithDefaultValue();
            this.buildPowerBars();
            this.buildHeaders();
        }
    }
    ngOnChanges(changes) {
        if (changes.metricsTable) {
            if (this.metricsTable !== undefined && this.metricsTable !== null) {
                this.ngOnInit();
            }
        }
        if (changes.selectedTerms) {
            this.updateSelection(this.selectedTerms);
        }
    }
    buildHeaders() {
        this.uniqueTitles = [];
        let previousId = '';
        let nextIndex = 0;
        this.metricsTable.header.forEach((header, i) => {
            header.color = this.defineColor(header.title);
            const currentId = header.title + header.rowfield;
            if (currentId !== previousId) {
                header.span = 1;
                this.uniqueTitles.push(header);
                nextIndex++;
                previousId = currentId;
            }
            else {
                this.uniqueTitles[nextIndex - 1].span++;
            }
        });
        this.titleAreDifferent = this.uniqueTitles.length === this.metricsTable?.data[0]?.data.length;
    }
    updateSelectedTermWithDefaultValue() {
        if (this.selectedTerms && this.selectedTerms.length > 0) {
            this.selectedTerms.forEach(selectedTerm => {
                this.selectedKeys.add(selectedTerm);
            });
        }
        this.togglePendingMode();
    }
    buildPowerBars() {
        this.powerBarsMap.clear();
        this.clearAll();
        this.metricsTable.data?.forEach((merticsRow, rowIndex) => {
            this.powerBarsMap.set(merticsRow.term, []);
            merticsRow.data.forEach((item, i) => {
                let powerBar;
                if (this.applyColorTo === 'row') {
                    powerBar = new PowerBar(merticsRow.term, merticsRow.term, item?.value);
                }
                else {
                    const header = this.metricsTable.header[i];
                    powerBar = new PowerBar(header.title, header.title, item?.value);
                }
                if (item) {
                    let maxValue;
                    if (this.normaliseBy === 'table') {
                        maxValue = item.maxTableValue;
                    }
                    else {
                        maxValue = item.maxColumnValue;
                    }
                    powerBar.progression = (item.value / maxValue) * 100;
                }
                if (this.useColorService) {
                    powerBar.color = this.defineColor(powerBar.term);
                }
                if (this.selectedKeys.has(merticsRow.term)) {
                    merticsRow.selected = true;
                    this.selectedRows.set(merticsRow.term, merticsRow);
                }
                this.powerBarsMap.get(merticsRow.term).push(powerBar);
            });
        });
    }
    updateSelection(keys) {
        this.selectedKeys = new Set(keys);
        this.clearAll();
        keys.forEach(key => this.updateSelectedRow(key));
        this.togglePendingMode();
    }
    clearAll() {
        this.metricsTable?.data?.forEach(row => row.selected = false);
        this.selectedRows.clear();
    }
    addTermToSelectedList(key) {
        this.updateSelectedRow(key);
        this.updateSelectedTerm(key);
        this.togglePendingMode();
    }
    updateSelectedTerm(key) {
        if (this.selectedKeys.has(key)) {
            this.selectedKeys.delete(key);
        }
        else {
            this.selectedKeys.add(key);
        }
        this.onSelect.emit(this.selectedKeys);
    }
    updateSelectedRow(key) {
        const row = this.metricsTable.data.find(row => row.term === key);
        if (this.selectedRows.has(key)) {
            row.selected = false;
            this.selectedRows.delete(key);
        }
        else if (row) {
            row.selected = true;
            this.selectedRows.set(key, row);
        }
        else {
            /** If we select a row that does not exists, it means we data is not  */
        }
    }
    togglePendingMode() {
        this.pendingMode = this.selectedKeys.size !== 0;
    }
    trackByFn(index, item) {
        return item.term; // Use the 'id' property as the unique identifier
    }
    defineColor(key) {
        const rgbaColor = tinycolor.default(this.colorService.getColor(key, this.keysToColors, this.colorsSaturationWeight)).toRgb();
        return this.getPowerbarColor(rgbaColor);
    }
    getPowerbarColor(rgbaColor) {
        return 'rgba(' + [rgbaColor.r, rgbaColor.g, rgbaColor.b, 0.7].join(',') + ')';
    }
    static getJsonSchema() {
        return metricTableJsonSchema;
    }
    setOperator(op) {
        if (this.filterOperator.value !== op) {
            this.filterOperator.value = op;
            this.filterOperatorEvent.next(op);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableComponent, deps: [{ token: ArlasColorService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MetricsTableComponent, selector: "arlas-metrics-table", inputs: { metricsTable: "metricsTable", filterOperator: "filterOperator", selectedTerms: "selectedTerms", keysToColors: "keysToColors", useColorService: "useColorService", applyColorTo: "applyColorTo", colorsSaturationWeight: "colorsSaturationWeight", selectWithCheckbox: "selectWithCheckbox", headerDisplayMode: "headerDisplayMode", normaliseBy: "normaliseBy", showRowField: "showRowField" }, outputs: { filterOperatorEvent: "filterOperatorEvent", onSelect: "onSelect" }, viewQueries: [{ propertyName: "header", first: true, predicate: ["tableHeader"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"tools\">\n  <div *ngIf=\"filterOperator && filterOperator?.display\" class=\"include_exclude\">\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Eq'\" (click)=\"setOperator('Eq')\">\n      {{'include' | translate}}</div>\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Neq'\" (click)=\"setOperator('Neq')\">\n      {{'exclude' | translate}}</div>\n  </div>\n  <div *ngIf=\"filterOperator && !filterOperator?.display && filterOperator?.value === 'Neq'\" class=\"include_exclude\">\n    <div class=\"operation\" [class.exclude]=\"filterOperator?.value === 'Neq'\">{{'exclude' | translate}}</div>\n  </div>\n</div>\n<div class=\"table-overflow-wrapper\">\n  <table class=\"multi-bar\">\n    <thead #tableHeader>\n      <!-- Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <ng-container *ngIf=\"titleAreDifferent; else displayOneTitle\">\n          <th class=\"multi-bar__header-indicator\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n            <div>\n              <div class=\"container\">\n                <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                  [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"></div>\n                <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n                <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"\n                  *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n                </div>\n              </div>\n              <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">{{\n                header.rowfield | getFieldDisplayName | translate }}</div>\n\n            </div>\n          </th>\n        </ng-container>\n        <ng-template #displayOneTitle>\n          <th *ngFor=\"let header of uniqueTitles\" class=\"multi-bar__header-indicator\"\n            [style.width.px]=\"header.span * 70\" [attr.colspan]=\"header.span\">\n            <div class=\"container\">\n              <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"></div>\n              <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n              <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"\n                *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n              </div>\n            </div>\n            <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">\n              {{header.rowfield | getFieldDisplayName | translate}}</div>\n          </th>\n        </ng-template>\n      </tr>\n      <!-- Sub Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <th class=\"column-head multi-bar__header\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n          <div *ngIf=\"header.metric !== 'count'\"\n            [matTooltip]=\"'METRIC_COLUMN_TITLE' | translate:  { metric: 'METRIC_COLUMN_' + header.metric | translate, field : header.subTitle | getFieldDisplayName | translate }\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'METRIC_COLUMN_TITLE' | translate: { metric: 'METRIC_COLUMN_' + header.metric | translate, field :\n            header.subTitle | getFieldDisplayName |\n            translate } }}\n          </div>\n          <div *ngIf=\"header.metric === 'count'\" [matTooltip]=\"'COUNT_COLUMN_TITLE' | translate\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'COUNT_COLUMN_TITLE' | translate }}\n          </div>\n        </th>\n      </tr>\n    </thead>\n    <ng-container *ngFor=\"let item of metricsTable?.data; let index = index;trackBy: trackByFn\">\n      <arlas-multi-bars-row *ngIf=\"item?.selected\" [metricsTableRow]=\"item\" [useColorFromData]=\"false\"\n        [hideSelection]=\"false\" [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(item.term)\"\n        [displayCheckBox]=\"selectWithCheckbox\" (rowSelected)=\"addTermToSelectedList($event)\">\n      </arlas-multi-bars-row>\n    </ng-container>\n    <arlas-multi-bars-row *ngFor=\"let row of metricsTable?.data; let index = index;trackBy: trackByFn\"\n      [metricsTableRow]=\"row\" [selected]=\"row.selected\" [hideSelection]=\"true\" [useColorFromData]=\"false\"\n      [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(row.term)\"\n      [displayCheckBox]=\"selectWithCheckbox\" [pendingMode]=\"pendingMode\" (rowSelected)=\"addTermToSelectedList($event)\">\n    </arlas-multi-bars-row>\n  </table>\n</div>", styles: ["@charset \"UTF-8\";:host{min-width:200px;display:block;height:100%}.tools .include_exclude{display:flex;align-items:baseline}.tools .include_exclude .operation{font-size:12px;color:#aaa;border-radius:3px;font-weight:700;margin-right:5px;cursor:pointer;padding-bottom:3px}.tools .include_exclude .selected_operation{color:#555;font-weight:700}.tools .include_exclude .exclude{color:#555;font-weight:700;cursor:unset}.table-overflow-wrapper{overflow-x:auto;overflow-y:auto;height:100%;max-width:100%}.container{display:flex;align-items:center}.header-indicator{height:10px;width:10px;display:inline-block;border-radius:10px;margin-left:2px}.separator{margin:0 2px;display:inline-block}.multi-bar{font-size:12px;border-spacing:0;width:100%;table-layout:fixed;max-height:100%;position:relative;border-collapse:collapse}.multi-bar thead{position:sticky;background:#fff;top:0;z-index:1}.multi-bar thead .terms-head{width:80px}.multi-bar thead .column-head{width:70px}.multi-bar td,.multi-bar th{white-space:nowrap}.multi-bar__header{font-size:12px;padding:0 6px 6px;text-align:center;vertical-align:bottom;border-bottom:1px solid #dadada;cursor:pointer}.multi-bar__header-indicator{padding:6px 0;text-align:center;line-height:12px;border-right:2px solid white;background:#e5e5e554;box-sizing:border-box}.multi-bar__header-title{font-size:12px;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-title-with-indicator{font-size:12px;overflow:hidden;text-overflow:ellipsis;width:calc(100% - 20px)}.multi-bar__header-rowfield{font-weight:200;margin:2px auto auto;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-item{font-weight:400;margin:0 auto;word-wrap:break-word;text-align:center}.multi-bar__header-item-title{max-height:50px;overflow:hidden;text-overflow:ellipsis}::-webkit-scrollbar{width:3px!important;height:4px!important;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}\n"], dependencies: [{ kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", inputs: ["matTooltipPosition", "matTooltipPositionAtOrigin", "matTooltipDisabled", "matTooltipShowDelay", "matTooltipHideDelay", "matTooltipTouchGestures", "matTooltip", "matTooltipClass"], exportAs: ["matTooltip"] }, { kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: MetricsTableRowComponent, selector: "arlas-multi-bars-row", inputs: ["displayCheckBox", "hideSelection", "metricsTableRow", "useColorService", "useColorFromData", "colors", "selected", "pendingMode", "powerBars"], outputs: ["rowSelected"] }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }, { kind: "pipe", type: GetCollectionDisplayNamePipe, name: "getCollectionDisplayName" }, { kind: "pipe", type: GetFieldDisplayNamePipe, name: "getFieldDisplayName" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-metrics-table', template: "<div class=\"tools\">\n  <div *ngIf=\"filterOperator && filterOperator?.display\" class=\"include_exclude\">\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Eq'\" (click)=\"setOperator('Eq')\">\n      {{'include' | translate}}</div>\n    <div class=\"operation\" [class.selected_operation]=\"filterOperator?.value === 'Neq'\" (click)=\"setOperator('Neq')\">\n      {{'exclude' | translate}}</div>\n  </div>\n  <div *ngIf=\"filterOperator && !filterOperator?.display && filterOperator?.value === 'Neq'\" class=\"include_exclude\">\n    <div class=\"operation\" [class.exclude]=\"filterOperator?.value === 'Neq'\">{{'exclude' | translate}}</div>\n  </div>\n</div>\n<div class=\"table-overflow-wrapper\">\n  <table class=\"multi-bar\">\n    <thead #tableHeader>\n      <!-- Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <ng-container *ngIf=\"titleAreDifferent; else displayOneTitle\">\n          <th class=\"multi-bar__header-indicator\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n            <div>\n              <div class=\"container\">\n                <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                  [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"></div>\n                <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n                <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName |  translate\"\n                  *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n                </div>\n              </div>\n              <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">{{\n                header.rowfield | getFieldDisplayName | translate }}</div>\n\n            </div>\n          </th>\n        </ng-container>\n        <ng-template #displayOneTitle>\n          <th *ngFor=\"let header of uniqueTitles\" class=\"multi-bar__header-indicator\"\n            [style.width.px]=\"header.span * 70\" [attr.colspan]=\"header.span\">\n            <div class=\"container\">\n              <div *ngIf=\"headerDisplayMode === 'chip' || headerDisplayMode === 'full'\" class=\"header-indicator\"\n                [style]=\"{'background': header.color}\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"></div>\n              <div class=\"separator\" *ngIf=\"headerDisplayMode === 'full'\"></div>\n              <div class=\"multi-bar__header-title-with-indicator\" [matTooltip]=\"header.title | getCollectionDisplayName | translate\"\n                *ngIf=\"headerDisplayMode === 'title' || headerDisplayMode === 'full'\">{{ header.title | getCollectionDisplayName | translate }}\n              </div>\n            </div>\n            <div class=\"multi-bar__header-rowfield\" [matTooltip]=\"header.rowfield | translate\" *ngIf=\"showRowField\">\n              {{header.rowfield | getFieldDisplayName | translate}}</div>\n          </th>\n        </ng-template>\n      </tr>\n      <!-- Sub Title area -->\n      <tr>\n        <th class=\"terms-head\"></th>\n        <th class=\"column-head multi-bar__header\" *ngFor=\"let header of metricsTable?.header; let i = index\">\n          <div *ngIf=\"header.metric !== 'count'\"\n            [matTooltip]=\"'METRIC_COLUMN_TITLE' | translate:  { metric: 'METRIC_COLUMN_' + header.metric | translate, field : header.subTitle | getFieldDisplayName | translate }\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'METRIC_COLUMN_TITLE' | translate: { metric: 'METRIC_COLUMN_' + header.metric | translate, field :\n            header.subTitle | getFieldDisplayName |\n            translate } }}\n          </div>\n          <div *ngIf=\"header.metric === 'count'\" [matTooltip]=\"'COUNT_COLUMN_TITLE' | translate\"\n            class=\"multi-bar__header-item multi-bar__header-item-title\">\n            {{'COUNT_COLUMN_TITLE' | translate }}\n          </div>\n        </th>\n      </tr>\n    </thead>\n    <ng-container *ngFor=\"let item of metricsTable?.data; let index = index;trackBy: trackByFn\">\n      <arlas-multi-bars-row *ngIf=\"item?.selected\" [metricsTableRow]=\"item\" [useColorFromData]=\"false\"\n        [hideSelection]=\"false\" [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(item.term)\"\n        [displayCheckBox]=\"selectWithCheckbox\" (rowSelected)=\"addTermToSelectedList($event)\">\n      </arlas-multi-bars-row>\n    </ng-container>\n    <arlas-multi-bars-row *ngFor=\"let row of metricsTable?.data; let index = index;trackBy: trackByFn\"\n      [metricsTableRow]=\"row\" [selected]=\"row.selected\" [hideSelection]=\"true\" [useColorFromData]=\"false\"\n      [useColorService]=\"useColorService\" [powerBars]=\"powerBarsMap.get(row.term)\"\n      [displayCheckBox]=\"selectWithCheckbox\" [pendingMode]=\"pendingMode\" (rowSelected)=\"addTermToSelectedList($event)\">\n    </arlas-multi-bars-row>\n  </table>\n</div>", styles: ["@charset \"UTF-8\";:host{min-width:200px;display:block;height:100%}.tools .include_exclude{display:flex;align-items:baseline}.tools .include_exclude .operation{font-size:12px;color:#aaa;border-radius:3px;font-weight:700;margin-right:5px;cursor:pointer;padding-bottom:3px}.tools .include_exclude .selected_operation{color:#555;font-weight:700}.tools .include_exclude .exclude{color:#555;font-weight:700;cursor:unset}.table-overflow-wrapper{overflow-x:auto;overflow-y:auto;height:100%;max-width:100%}.container{display:flex;align-items:center}.header-indicator{height:10px;width:10px;display:inline-block;border-radius:10px;margin-left:2px}.separator{margin:0 2px;display:inline-block}.multi-bar{font-size:12px;border-spacing:0;width:100%;table-layout:fixed;max-height:100%;position:relative;border-collapse:collapse}.multi-bar thead{position:sticky;background:#fff;top:0;z-index:1}.multi-bar thead .terms-head{width:80px}.multi-bar thead .column-head{width:70px}.multi-bar td,.multi-bar th{white-space:nowrap}.multi-bar__header{font-size:12px;padding:0 6px 6px;text-align:center;vertical-align:bottom;border-bottom:1px solid #dadada;cursor:pointer}.multi-bar__header-indicator{padding:6px 0;text-align:center;line-height:12px;border-right:2px solid white;background:#e5e5e554;box-sizing:border-box}.multi-bar__header-title{font-size:12px;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-title-with-indicator{font-size:12px;overflow:hidden;text-overflow:ellipsis;width:calc(100% - 20px)}.multi-bar__header-rowfield{font-weight:200;margin:2px auto auto;overflow:hidden;text-overflow:ellipsis}.multi-bar__header-item{font-weight:400;margin:0 auto;word-wrap:break-word;text-align:center}.multi-bar__header-item-title{max-height:50px;overflow:hidden;text-overflow:ellipsis}::-webkit-scrollbar{width:3px!important;height:4px!important;background-color:#f5f5f5}::-webkit-scrollbar-track{box-shadow:inset 0 0 6px #0000004d;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);background-color:#f5f5f5}::-webkit-scrollbar-thumb{background-color:#555}\n"] }]
        }], ctorParameters: () => [{ type: ArlasColorService }, { type: i0.ChangeDetectorRef }], propDecorators: { metricsTable: [{
                type: Input
            }], filterOperator: [{
                type: Input
            }], filterOperatorEvent: [{
                type: Output
            }], selectedTerms: [{
                type: Input
            }], keysToColors: [{
                type: Input
            }], useColorService: [{
                type: Input
            }], applyColorTo: [{
                type: Input
            }], colorsSaturationWeight: [{
                type: Input
            }], selectWithCheckbox: [{
                type: Input
            }], headerDisplayMode: [{
                type: Input
            }], normaliseBy: [{
                type: Input
            }], showRowField: [{
                type: Input
            }], onSelect: [{
                type: Output
            }], header: [{
                type: ViewChild,
                args: ['tableHeader']
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class FormatLongTitlePipe {
    transform(value, maxLength) {
        if (!value) {
            return '';
        }
        if (value.trim().length <= maxLength) {
            return value;
        }
        return `${value.substring(0, maxLength - 3)}...`;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatLongTitlePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: FormatLongTitlePipe, isStandalone: true, name: "formatLongTitle" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: FormatLongTitlePipe, decorators: [{
            type: Pipe,
            args: [{
                    standalone: true,
                    name: 'formatLongTitle'
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MetricsTableRowModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableRowModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableRowModule, declarations: [MetricsTableRowComponent], imports: [MatCheckboxModule,
            NgClass,
            PowerbarModule,
            UpperCasePipe,
            NgIf,
            NgForOf], exports: [MetricsTableRowComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableRowModule, imports: [MatCheckboxModule,
            PowerbarModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableRowModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        MatCheckboxModule,
                        NgClass,
                        PowerbarModule,
                        UpperCasePipe,
                        NgIf,
                        NgForOf
                    ],
                    declarations: [MetricsTableRowComponent],
                    exports: [MetricsTableRowComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetCollectionDisplayModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionDisplayModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionDisplayModule, declarations: [GetCollectionDisplayNamePipe], exports: [GetCollectionDisplayNamePipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionDisplayModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetCollectionDisplayModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [
                        GetCollectionDisplayNamePipe
                    ],
                    exports: [
                        GetCollectionDisplayNamePipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetFieldDisplayModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetFieldDisplayModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetFieldDisplayModule, declarations: [GetFieldDisplayNamePipe], exports: [GetFieldDisplayNamePipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetFieldDisplayModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetFieldDisplayModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [
                        GetFieldDisplayNamePipe
                    ],
                    exports: [
                        GetFieldDisplayNamePipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class MetricsTableModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableModule, declarations: [MetricsTableComponent], imports: [PowerbarModule,
            MatTooltipModule,
            NgForOf,
            NgClass,
            NgIf,
            UpperCasePipe,
            MatCheckboxModule,
            TranslateModule,
            MetricsTableRowModule,
            FormatLongTitlePipe,
            AsyncPipe,
            KeyValuePipe,
            GetCollectionDisplayModule,
            GetFieldDisplayModule], exports: [MetricsTableComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableModule, imports: [PowerbarModule,
            MatTooltipModule,
            MatCheckboxModule,
            TranslateModule,
            MetricsTableRowModule,
            GetCollectionDisplayModule,
            GetFieldDisplayModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricsTableModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PowerbarModule,
                        MatTooltipModule,
                        NgForOf,
                        NgClass,
                        NgIf,
                        UpperCasePipe,
                        MatCheckboxModule,
                        TranslateModule,
                        MetricsTableRowModule,
                        FormatLongTitlePipe,
                        AsyncPipe,
                        KeyValuePipe,
                        GetCollectionDisplayModule,
                        GetFieldDisplayModule
                    ],
                    declarations: [MetricsTableComponent],
                    exports: [MetricsTableComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class WmtsLayerManagertDialogComponent {
    constructor(dialogRef, http) {
        this.dialogRef = dialogRef;
        this.http = http;
        this.isImageLoading = false;
        this.showError = false;
        this.previewLoading = false;
        this.launchPreview = false;
        this.clickTopreview = new Subject();
    }
    ngOnInit() {
        const l = new Array();
        this.data.forEach((value, key) => {
            l.push(key);
        });
        this.layers = l;
        this.formGroup = new UntypedFormGroup({
            layer: new UntypedFormControl(),
            style: new UntypedFormControl(),
        });
    }
    selectionChange(event) {
        this.style = undefined;
        this.styles = new Array();
        this.styles = this.data.get(event.value).styles;
        this.dimensions = this.data.get(event.value).dimensions;
        this.dimensions.forEach(d => {
            this.formGroup.addControl(d.identifier, new UntypedFormControl);
        });
    }
    clickOnPreview() {
        this.previewLoading = true;
        this.launchPreview = true;
        this.clickTopreview.next(this.formGroup.value);
    }
    previewUrl(url) {
        this.isImageLoading = true;
        this.getImage(url).subscribe(data => {
            this.createImageFromBlob(data);
            this.isImageLoading = false;
        }, error => {
            this.isImageLoading = false;
            this.showError = true;
        });
    }
    getImage(imageUrl) {
        return this.http.get(imageUrl, { responseType: 'blob' });
    }
    createImageFromBlob(image) {
        const reader = new FileReader();
        reader.addEventListener('load', () => {
            this.imageToShow = reader.result;
        }, false);
        if (image) {
            reader.readAsDataURL(image);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagertDialogComponent, deps: [{ token: i1.MatDialogRef }, { token: i2$2.HttpClient }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: WmtsLayerManagertDialogComponent, selector: "arlas-wmts-layer-manager-dialog", inputs: { layers: "layers", styles: "styles", metadata: "metadata", dimensions: "dimensions", data: "data", isDimension: "isDimension" }, outputs: { clickTopreview: "clickTopreview" }, ngImport: i0, template: "<h2 mat-dialog-title class=\"wmts-layer-manager-title\">{{'Layers and style' | translate}}</h2>\n<mat-dialog-content class=\"wmts-layer-manager-content\">\n    <mat-card appearance=\"outlined\" class=\"wmts-layer-manager-metadata-card\" *ngIf=\"metadata\">\n        <div class=\"wmts-layer-manager-metadata\">\n            <mat-list>\n                <h3 mat-subheader>{{'Informations' | translate}}</h3>\n                <mat-list-item class=\"wmts-layer-manager-metadata-list\" *ngFor=\"let item of metadata | keyvalue\">\n                    <h4 mat-line class=\"wmts-layer-manager-metadata-title\">{{item.key}}</h4>\n                    <p mat-line class=\"wmts-layer-manager-metadata-value\"> {{item?.value}} </p>\n                </mat-list-item>\n            </mat-list>\n        </div>\n    </mat-card>\n    <form class=\"wmts-layer-manager-form\" [formGroup]=\"formGroup\">\n        <mat-form-field class=\"wmts-layer-manager-field\">\n            <mat-select [(value)]=\"layer\" placeholder=\"{{'Choose layer'| translate}}...\" (selectionChange)=\"selectionChange($event)\"\n                formControlName=\"layer\">\n                <mat-option *ngFor=\"let layer of layers\" [value]=\"layer\">\n                    {{layer}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n        <mat-form-field class=\"wmts-layer-manager-field\">\n            <mat-select placeholder=\"{{'Choose style'| translate}}...\" [(value)]=\"style\" formControlName=\"style\">\n                <mat-option *ngFor=\"let style of styles\" [value]=\"style\">\n                    {{style}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n        <div *ngFor=\"let dimension of dimensions\">\n            <div *ngIf=\"dimension.identifier==='time'\">\n                <mat-form-field class=\"wmts-layer-manager-field\">\n                    <input matInput autocomplete=\"off\" [matDatepicker]=\"picker\" placeholder=\"{{'Choose date'| translate}}\" formControlName={{dimension.identifier}}\n                        [max]=dimension.endDate [min]=dimension.startDate>\n                    <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n                    <mat-datepicker #picker></mat-datepicker>\n                </mat-form-field>\n            </div>\n            <div *ngIf=\"dimension.identifier !=='time'\">\n                <mat-form-field class=\"wmts-layer-manager-field\">\n                    <mat-select formControlName={{dimension.identifier}} placeholder=\"{{'Choose' | translate}} {{dimension.identifier}}\">\n                        <mat-option *ngFor=\"let v of dimension.values\" [value]=\"v\">\n                            {{v}}\n                        </mat-option>\n                    </mat-select>\n                </mat-form-field>\n            </div>\n        </div>\n    </form>\n    <div *ngIf=\"launchPreview\" class=\"wmts-layer-manager-preview\" style=\"height: 256px;\">\n        <img class=\"wmts-layer-manager-image\" [src]=\"imageToShow\" alt=\"Preview of WMTS service\" *ngIf=\"imageToShow&&!isImageLoading&&!showError\">\n        <mat-progress-spinner class=\"wmts-layer-manager-spinner\" *ngIf=\"isImageLoading\" [diameter]=\"128\" [strokeWidth]=\"2\" mode=\"indeterminate\"></mat-progress-spinner>\n    </div>\n    <div class=\"wmts-layer-manager-error\" *ngIf=\"launchPreview && showError\">\n        <span>{{'Unable to preview this style for this layer'| translate}}</span>\n    </div>\n</mat-dialog-content>\n\n<div mat-dialog-actions>\n    <button mat-raised-button class=\"wmts-layer-manager-preview-button\" [disabled]=\"style==undefined||layer==undefined\" (click)=\"clickOnPreview()\">{{'Preview'| translate}}</button>\n    <button mat-raised-button class=\"wmts-layer-manager-view-button\" [disabled]=\"style==undefined||layer==undefined\" [mat-dialog-close]=\"formGroup.value\"\n        cdkFocusInitial>{{'View' | translate}}</button>\n</div>", styles: [".wmts-layer-manager-metadata-list{height:48px!important}.wmts-layer-manager-form{padding-top:16px!important;display:flex;flex-flow:wrap;max-width:440px}.wmts-layer-manager-preview,.wmts-layer-manager-image,.wmts-layer-manager-spinner{margin-left:auto!important;margin-right:auto!important;display:block!important}.wmts-layer-manager-content{max-height:80vh!important}.wmts-layer-manager-field{padding-right:5px;padding-left:5px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.MatDialogClose, selector: "[mat-dialog-close], [matDialogClose]", inputs: ["aria-label", "type", "mat-dialog-close", "matDialogClose"], exportAs: ["matDialogClose"] }, { kind: "directive", type: i1.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i1.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "component", type: i4$2.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i4$2.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i3$1.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i10.MatSelect, selector: "mat-select", inputs: ["aria-describedby", "panelClass", "disabled", "disableRipple", "tabIndex", "hideSingleSelectionIndicator", "placeholder", "required", "multiple", "disableOptionCentering", "compareWith", "value", "aria-label", "aria-labelledby", "errorStateMatcher", "typeaheadDebounceInterval", "sortComparator", "id", "panelWidth"], outputs: ["openedChange", "opened", "closed", "selectionChange", "valueChange"], exportAs: ["matSelect"] }, { kind: "component", type: i4$3.MatOption, selector: "mat-option", inputs: ["value", "id", "disabled"], outputs: ["onSelectionChange"], exportAs: ["matOption"] }, { kind: "component", type: i8$1.MatDatepicker, selector: "mat-datepicker", exportAs: ["matDatepicker"] }, { kind: "directive", type: i8$1.MatDatepickerInput, selector: "input[matDatepicker]", inputs: ["matDatepicker", "min", "max", "matDatepickerFilter"], exportAs: ["matDatepickerInput"] }, { kind: "component", type: i8$1.MatDatepickerToggle, selector: "mat-datepicker-toggle", inputs: ["for", "tabIndex", "aria-label", "disabled", "disableRipple"], exportAs: ["matDatepickerToggle"] }, { kind: "directive", type: i9.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i9.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i9.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i9.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i9.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i9.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: i6.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "mode", "value", "diameter", "strokeWidth"], exportAs: ["matProgressSpinner"] }, { kind: "component", type: i11.MatCard, selector: "mat-card", inputs: ["appearance"], exportAs: ["matCard"] }, { kind: "component", type: i12$1.MatList, selector: "mat-list", exportAs: ["matList"] }, { kind: "component", type: i12$1.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i12$1.MatListSubheaderCssMatStyler, selector: "[mat-subheader], [matSubheader]" }, { kind: "pipe", type: i2$1.KeyValuePipe, name: "keyvalue" }, { kind: "pipe", type: i2.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagertDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-wmts-layer-manager-dialog', template: "<h2 mat-dialog-title class=\"wmts-layer-manager-title\">{{'Layers and style' | translate}}</h2>\n<mat-dialog-content class=\"wmts-layer-manager-content\">\n    <mat-card appearance=\"outlined\" class=\"wmts-layer-manager-metadata-card\" *ngIf=\"metadata\">\n        <div class=\"wmts-layer-manager-metadata\">\n            <mat-list>\n                <h3 mat-subheader>{{'Informations' | translate}}</h3>\n                <mat-list-item class=\"wmts-layer-manager-metadata-list\" *ngFor=\"let item of metadata | keyvalue\">\n                    <h4 mat-line class=\"wmts-layer-manager-metadata-title\">{{item.key}}</h4>\n                    <p mat-line class=\"wmts-layer-manager-metadata-value\"> {{item?.value}} </p>\n                </mat-list-item>\n            </mat-list>\n        </div>\n    </mat-card>\n    <form class=\"wmts-layer-manager-form\" [formGroup]=\"formGroup\">\n        <mat-form-field class=\"wmts-layer-manager-field\">\n            <mat-select [(value)]=\"layer\" placeholder=\"{{'Choose layer'| translate}}...\" (selectionChange)=\"selectionChange($event)\"\n                formControlName=\"layer\">\n                <mat-option *ngFor=\"let layer of layers\" [value]=\"layer\">\n                    {{layer}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n        <mat-form-field class=\"wmts-layer-manager-field\">\n            <mat-select placeholder=\"{{'Choose style'| translate}}...\" [(value)]=\"style\" formControlName=\"style\">\n                <mat-option *ngFor=\"let style of styles\" [value]=\"style\">\n                    {{style}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n        <div *ngFor=\"let dimension of dimensions\">\n            <div *ngIf=\"dimension.identifier==='time'\">\n                <mat-form-field class=\"wmts-layer-manager-field\">\n                    <input matInput autocomplete=\"off\" [matDatepicker]=\"picker\" placeholder=\"{{'Choose date'| translate}}\" formControlName={{dimension.identifier}}\n                        [max]=dimension.endDate [min]=dimension.startDate>\n                    <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n                    <mat-datepicker #picker></mat-datepicker>\n                </mat-form-field>\n            </div>\n            <div *ngIf=\"dimension.identifier !=='time'\">\n                <mat-form-field class=\"wmts-layer-manager-field\">\n                    <mat-select formControlName={{dimension.identifier}} placeholder=\"{{'Choose' | translate}} {{dimension.identifier}}\">\n                        <mat-option *ngFor=\"let v of dimension.values\" [value]=\"v\">\n                            {{v}}\n                        </mat-option>\n                    </mat-select>\n                </mat-form-field>\n            </div>\n        </div>\n    </form>\n    <div *ngIf=\"launchPreview\" class=\"wmts-layer-manager-preview\" style=\"height: 256px;\">\n        <img class=\"wmts-layer-manager-image\" [src]=\"imageToShow\" alt=\"Preview of WMTS service\" *ngIf=\"imageToShow&&!isImageLoading&&!showError\">\n        <mat-progress-spinner class=\"wmts-layer-manager-spinner\" *ngIf=\"isImageLoading\" [diameter]=\"128\" [strokeWidth]=\"2\" mode=\"indeterminate\"></mat-progress-spinner>\n    </div>\n    <div class=\"wmts-layer-manager-error\" *ngIf=\"launchPreview && showError\">\n        <span>{{'Unable to preview this style for this layer'| translate}}</span>\n    </div>\n</mat-dialog-content>\n\n<div mat-dialog-actions>\n    <button mat-raised-button class=\"wmts-layer-manager-preview-button\" [disabled]=\"style==undefined||layer==undefined\" (click)=\"clickOnPreview()\">{{'Preview'| translate}}</button>\n    <button mat-raised-button class=\"wmts-layer-manager-view-button\" [disabled]=\"style==undefined||layer==undefined\" [mat-dialog-close]=\"formGroup.value\"\n        cdkFocusInitial>{{'View' | translate}}</button>\n</div>", styles: [".wmts-layer-manager-metadata-list{height:48px!important}.wmts-layer-manager-form{padding-top:16px!important;display:flex;flex-flow:wrap;max-width:440px}.wmts-layer-manager-preview,.wmts-layer-manager-image,.wmts-layer-manager-spinner{margin-left:auto!important;margin-right:auto!important;display:block!important}.wmts-layer-manager-content{max-height:80vh!important}.wmts-layer-manager-field{padding-right:5px;padding-left:5px}\n"] }]
        }], ctorParameters: () => [{ type: i1.MatDialogRef }, { type: i2$2.HttpClient }], propDecorators: { layers: [{
                type: Input
            }], styles: [{
                type: Input
            }], metadata: [{
                type: Input
            }], dimensions: [{
                type: Input
            }], data: [{
                type: Input
            }], isDimension: [{
                type: Input
            }], clickTopreview: [{
                type: Output
            }] } });
class WmtsLayerManagerComponent {
    constructor(dialog, http) {
        this.dialog = dialog;
        this.http = http;
        /**
        * @Input : Angular
        * @description Supported CRS code of WMTS service
        */
        this.supportedCRSCode = new Array('3857', '900913');
        /**
      * @Input : Angular
      * @description String date Format for time input
      */
        this.dateFormat = 'YYYY-MM-DDT00:00:00';
        /**
         * @Output : Angular
         * @description Emit the information needed by a wmts client to view a product
         */
        this.getTilesInfoBus = new Subject();
        /**
         * @Output : Angular
         * @description Emit all errors of the component
         */
        this.onError = new Subject();
        this.errorInRun = false;
        this.isGetCapaLoading = false;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (changes['getCapaUrl'] !== undefined) {
            this.getCapaUrl = changes['getCapaUrl'].currentValue;
        }
    }
    run(header, md = {}, timeoutDuration = 100000, numberOfRetry = 0) {
        // Call the gatCapabilities services
        this.errorInRun = false;
        this.isGetCapaLoading = true;
        const httpCall = this.http.get(this.getCapaUrl, { headers: header, responseType: 'text' });
        httpCall
            .pipe(timeout(timeoutDuration), retry(numberOfRetry))
            .subscribe(response => {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(response, 'text/xml');
                const data = this.geLayerToData(xmlDoc);
                // if getCapa contains juste one layer and one style we just build the url and send it to the bus
                const mapSize = data.size;
                if (mapSize === 0) {
                    const nonDataError = new Error('NoStyle-NoLayer');
                    this.errorInRun = true;
                    this.onError.next(nonDataError);
                }
                if (mapSize === 1 && data.values().next().value.styles.length === 1) {
                    // update layer and style
                    this.getTilesInfoBus.next(this.buildGetTileInfo(xmlDoc, data.keys().next().value, data.values().next().value.styles[0], md));
                }
                else {
                    this.dialogRef = this.dialog.open(WmtsLayerManagertDialogComponent, { data: response });
                    this.isGetCapaLoading = false;
                    this.dialogRef.componentInstance.data = data;
                    this.dialogRef.componentInstance.metadata = this.metadata;
                    this.dialogRef.afterClosed().subscribe(formGroupValue => {
                        if (formGroupValue) {
                            const getTileInfo = this.buildGetTileInfo(xmlDoc, formGroupValue.layer, formGroupValue.style, md, this.getDimensionsFromGroupValues(formGroupValue));
                            if (!this.errorInRun) {
                                this.getTilesInfoBus.next(getTileInfo);
                            }
                        }
                    });
                    this.dialogRef.componentInstance.clickTopreview.subscribe(formGroupValue => {
                        const getTileInfo = this.buildGetTileInfo(xmlDoc, formGroupValue.layer, formGroupValue.style, md, this.getDimensionsFromGroupValues(formGroupValue));
                        if (!this.errorInRun) {
                            // bounds[[west,south][east,north]]
                            const bounds = getTileInfo.bbox;
                            const previewURL = getTileInfo.url
                                .replace('{x}', '0')
                                .replace('{y}', '0')
                                .replace('{z}', '0');
                            this.dialogRef.componentInstance.previewUrl(previewURL);
                        }
                    });
                }
            }
            catch (e) {
                this.onError.next(e);
                this.isGetCapaLoading = false;
            }
        }, error => {
            this.isGetCapaLoading = false;
            this.onError.next(error);
        });
    }
    geLayerToData(xmlDoc) {
        const layerToData = new Map();
        const layers = Array.from(xmlDoc.getElementsByTagName('Layer'));
        layers.forEach(l => {
            const identifier = l.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, '');
            const styles = Array.from(l.getElementsByTagName('Style'))
                .map(s => s.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, ''));
            const data = {
                styles: styles,
                dimensions: this.getDimension(l)
            };
            layerToData.set(identifier, data);
        });
        return layerToData;
    }
    getDimension(layerElement) {
        const dimensionElements = layerElement.getElementsByTagName('Dimension');
        const allDimension = Array.from(dimensionElements).map(e => {
            const abstracts = e.getElementsByTagName('ows:Abstract');
            let abstract;
            if (abstracts && abstracts.length > 0) {
                abstract = abstracts[0].textContent.replace(/\n/g, '');
            }
            return {
                identifier: e.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, ''),
                abstract: abstract,
                values: Array.from(e.getElementsByTagName('Value')).map(el => el.textContent.replace(/\n/g, ''))
            };
        });
        const timeDimension = allDimension.filter(r => r.identifier === 'time').map(r => {
            let startDate = null;
            let endDate = null;
            if (r.abstract && r.abstract.indexOf('/') > 0) {
                startDate = new Date(r.abstract.split('/')[0]);
                endDate = new Date(r.abstract.split('/')[1]);
                r.startDate = startDate;
                r.endDate = endDate;
            }
            return r;
        })[0];
        const result = allDimension.filter(r => r.identifier !== 'time').concat(timeDimension);
        return result.filter(data => data !== undefined);
    }
    getFormat(xmlDoc, layer) {
        const layerElement = Array.from(xmlDoc.getElementsByTagName('Layer'))
            .filter(l => l.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, '') === layer)[0];
        if (!this.format) {
            const format = Array.from(layerElement.getElementsByTagName('Format'))
                .map(e => e.textContent);
            return format[0];
        }
        else {
            const format = Array.from(layerElement.getElementsByTagName('Format'))
                .filter(f => f.textContent === this.format).map(e => e.textContent);
            if (new Set(format).has(this.format)) {
                return this.format;
            }
            else {
                const formatError = new Error(this.format.concat(' does not exist for layer ').concat(layer));
                this.errorInRun = true;
                this.onError.next(formatError);
            }
        }
    }
    getVersion(xmlDoc) {
        if (this.version === undefined) {
            try {
                return xmlDoc.getElementsByTagName('ows:ServiceTypeVersion')[0].textContent;
            }
            catch (e) {
                this.onError.next(new Error(e));
            }
        }
        else {
            return this.version;
        }
    }
    getKVPBaseUrl(xmlDoc) {
        if (this.getTilesBaseUrl === undefined) {
            try {
                const getCapaOperationNode = Array.from(xmlDoc
                    .getElementsByTagName('ows:OperationsMetadata')[0]
                    .getElementsByTagName('ows:Operation'))
                    .filter(element => element.getAttribute('name') === 'GetCapabilities')[0];
                const getKvpNode = Array.from(getCapaOperationNode.
                    getElementsByTagName('ows:Get'))
                    .filter(element => Array.from(element.getElementsByTagName('ows:Value'))
                    .filter(e => e.textContent === 'KVP').length > 0)[0];
                return getKvpNode.getAttribute('xlink:href');
            }
            catch (e) {
                this.onError.next(e);
            }
        }
        else {
            return this.getTilesBaseUrl;
        }
    }
    getTileMatrixSet(xmlDoc, layer) {
        if (this.tileMatrixSetIdenttifier === undefined) {
            const layerElement = Array.from(xmlDoc.getElementsByTagName('Layer'))
                .filter(l => l.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, '') === layer)[0];
            const tileMatrixSetForLayer = Array.from(layerElement
                .getElementsByTagName('TileMatrixSetLink'))
                .map(t => t.getElementsByTagName('TileMatrixSet'))
                .map(t => t[0].textContent);
            const tileMatrixSet = Array.from(xmlDoc.getElementsByTagName('TileMatrixSet'))
                .filter(l => l.children.length > 0)
                .filter(l => tileMatrixSetForLayer.indexOf(l.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, '')) >= 0)
                .filter(l => {
                const codeArray = [];
                this.supportedCRSCode.forEach(code => {
                    if (l.getElementsByTagName('ows:SupportedCRS')[0].textContent.replace(/\n/g, '').indexOf(code) >= 0) {
                        codeArray.push(code);
                    }
                });
                return codeArray.length > 0;
            }).map(l => l.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, ''));
            return tileMatrixSet[0];
        }
        else {
            return this.tileMatrixSetIdenttifier;
        }
    }
    getBbox(xmlDoc, layer) {
        const layerElement = Array.from(xmlDoc.getElementsByTagName('Layer'))
            .filter(l => l.getElementsByTagName('ows:Identifier')[0].textContent.replace(/\n/g, '') === layer)[0];
        const lowerCornerText = layerElement
            .getElementsByTagName('ows:WGS84BoundingBox')[0]
            .getElementsByTagName('ows:LowerCorner')[0]
            .textContent;
        const upperCornerText = layerElement
            .getElementsByTagName('ows:WGS84BoundingBox')[0]
            .getElementsByTagName('ows:UpperCorner')[0]
            .textContent;
        const bounds = new Array();
        // west
        bounds.push(parseFloat(lowerCornerText.split(' ')[0]));
        // south
        bounds.push(parseFloat(lowerCornerText.split(' ')[1]));
        // east
        bounds.push(parseFloat(upperCornerText.split(' ')[0]));
        // north
        bounds.push(parseFloat(upperCornerText.split(' ')[1]));
        return bounds;
    }
    getZoomMinMax(xmlDoc) {
        const numberOfTileMatrixSetTag = xmlDoc.getElementsByTagName('TileMatrixSet').length;
        const numberOfTileMatrixTag = xmlDoc
            .getElementsByTagName('TileMatrixSet')[numberOfTileMatrixSetTag - 1]
            .getElementsByTagName('TileMatrix').length;
        const maxZoom = xmlDoc
            .getElementsByTagName('TileMatrixSet')[numberOfTileMatrixSetTag - 1]
            .getElementsByTagName('TileMatrix')[numberOfTileMatrixTag - 1].children[0].textContent;
        const minZoom = parseInt(maxZoom, 10) - numberOfTileMatrixTag + 1;
        return [minZoom, parseInt(maxZoom, 10)];
    }
    buildGetTileUrl(xmlDoc, layer, style, dimensions) {
        let baseURL = this.getKVPBaseUrl(xmlDoc);
        if (baseURL[baseURL.length - 1] === '?') {
            baseURL = baseURL.substring(0, baseURL.length - 1);
        }
        const version = this.getVersion(xmlDoc);
        const tileMatrixSet = this.getTileMatrixSet(xmlDoc, layer);
        const format = this.getFormat(xmlDoc, layer);
        let url = '';
        url = url.concat(baseURL)
            .concat('?')
            .concat('SERVICE=WMTS&')
            .concat('REQUEST=GetTile&')
            .concat('VERSION=').concat(version).concat('&')
            .concat('LAYER=').concat(layer).concat('&')
            .concat('STYLE=').concat(style).concat('&')
            .concat('FORMAT=').concat(format).concat('&')
            .concat('TileMatrixSet=').concat(tileMatrixSet).concat('&')
            .concat('TileMatrix=').concat('{z}').concat('&')
            .concat('TileRow=').concat('{y}').concat('&')
            .concat('TileCol=').concat('{x}');
        if (dimensions) {
            Object
                .keys(dimensions)
                .forEach(e => url = url.concat('&').concat(e).concat('=').concat(dimensions[e]));
        }
        return url;
    }
    buildGetTileInfo(xmlDoc, layer, style, md, dimensions) {
        const getTilesInfo = {
            url: this.buildGetTileUrl(xmlDoc, layer, style, dimensions),
            zoomMax: this.getZoomMinMax(xmlDoc)[1],
            zoomMin: this.getZoomMinMax(xmlDoc)[0],
            bbox: this.getBbox(xmlDoc, layer),
            md: md
        };
        return getTilesInfo;
    }
    getDimensionsFromGroupValues(formGroup) {
        const dimensions = {};
        Object.keys(formGroup).filter(e => e !== 'style').filter(e => e !== 'layer')
            .forEach(e => dimensions[e] = formGroup[e]);
        if (dimensions['time']) {
            dimensions['time'] = moment(dimensions['time']).format(this.dateFormat);
        }
        return dimensions;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagerComponent, deps: [{ token: i1.MatDialog }, { token: i2$2.HttpClient }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: WmtsLayerManagerComponent, selector: "arlas-wmts-layer-manager", inputs: { getCapaUrl: "getCapaUrl", metadata: "metadata", getTilesBaseUrl: "getTilesBaseUrl", version: "version", format: "format", supportedCRSCode: "supportedCRSCode", dateFormat: "dateFormat", tileMatrixSetIdenttifier: "tileMatrixSetIdenttifier" }, outputs: { getTilesInfoBus: "getTilesInfoBus", onError: "onError" }, usesOnChanges: true, ngImport: i0, template: "\n", styles: [""] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-wmts-layer-manager', template: "\n" }]
        }], ctorParameters: () => [{ type: i1.MatDialog }, { type: i2$2.HttpClient }], propDecorators: { getCapaUrl: [{
                type: Input
            }], metadata: [{
                type: Input
            }], getTilesBaseUrl: [{
                type: Input
            }], version: [{
                type: Input
            }], format: [{
                type: Input
            }], supportedCRSCode: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], tileMatrixSetIdenttifier: [{
                type: Input
            }], getTilesInfoBus: [{
                type: Output
            }], onError: [{
                type: Output
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class WmtsLayerManagerModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagerModule, declarations: [WmtsLayerManagerComponent, WmtsLayerManagertDialogComponent], imports: [CommonModule,
            MatDialogModule,
            MatFormFieldModule,
            MatInputModule,
            MatSelectModule,
            MatDatepickerModule,
            MatNativeDateModule,
            FormsModule,
            ReactiveFormsModule,
            MatProgressSpinnerModule,
            MatCardModule,
            TranslateModule,
            MatListModule], exports: [WmtsLayerManagerComponent, WmtsLayerManagertDialogComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagerModule, imports: [CommonModule,
            MatDialogModule,
            MatFormFieldModule,
            MatInputModule,
            MatSelectModule,
            MatDatepickerModule,
            MatNativeDateModule,
            FormsModule,
            ReactiveFormsModule,
            MatProgressSpinnerModule,
            MatCardModule,
            TranslateModule,
            MatListModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: WmtsLayerManagerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatDialogModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatSelectModule,
                        MatDatepickerModule,
                        MatNativeDateModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatProgressSpinnerModule,
                        MatCardModule,
                        TranslateModule,
                        MatListModule
                    ],
                    declarations: [WmtsLayerManagerComponent, WmtsLayerManagertDialogComponent],
                    exports: [WmtsLayerManagerComponent, WmtsLayerManagertDialogComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var TranslationDirection;
(function (TranslationDirection) {
    TranslationDirection["past"] = "past";
    TranslationDirection["future"] = "future";
})(TranslationDirection || (TranslationDirection = {}));
/**
 * todo : documentation of the component
 */
class CalendarTimelineComponent {
    constructor() {
        this.boundDates = [];
        this.data = [];
        this.selectedData = new Subject();
        this.hoveredData = new Subject();
        this.translate = new Subject();
        this._onDestroy$ = new Subject();
        fromEvent(window, 'resize')
            .pipe(debounceTime$1(500), takeUntil$1(this._onDestroy$))
            .subscribe((event) => {
            const element = this.timelineContainer.nativeElement;
            const margins = (new Margins()).setBottom(5).setTop(5).setRight(5).setLeft(5);
            this.width = element.offsetWidth;
            this.height = 90;
            const dimensions = (new Dimensions(this.width, this.height)).setMargins(margins);
            if (this.timeline) {
                this.timeline.setDimensions(dimensions);
                this.timeline.plot();
            }
        });
    }
    ngOnChanges(changes) {
        if (changes.data && this.timeline) {
            this.timeline.setData(this.data);
            if (this.timeline.boundDates && this.timeline.boundDates.length === 2) {
                this.timeline.plot(true);
            }
        }
        if (changes.boundDates && this.timeline) {
            this.timeline.setBoundDates(this.boundDates);
            this.timeline.plot();
        }
        if (changes.granularity && this.timeline) {
            this.timeline.setGranularity(this.granularity);
        }
        if (changes.climatological && this.timeline) {
            this.timeline.setClimatological(this.climatological);
        }
        if (changes.cursorPosition && this.timeline) {
            this.timeline.moveCursor(this.cursorPosition);
        }
    }
    ngAfterViewInit() {
        const element = this.timelineContainer.nativeElement;
        const svg = element.querySelector('svg');
        const margins = (new Margins()).setBottom(5).setTop(5).setRight(5).setLeft(5);
        this.width = element.offsetWidth;
        this.height = 90;
        const dimensions = (new Dimensions(this.width, this.height)).setMargins(margins);
        this.timeline = (new Timeline(svg));
        this.timeline.setDimensions(dimensions);
        this.timeline.setBoundDates(this.boundDates);
        this.timeline.hoveredData
            .pipe(takeUntil$1(this._onDestroy$))
            .subscribe(r => {
            this.hoveredData.next(r);
        });
        this.timeline.selectedData
            .pipe(takeUntil$1(this._onDestroy$))
            .subscribe(r => {
            this.selectedData.next(r);
        });
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    plot() {
        if (this.timeline) {
            this.timeline.plot();
        }
    }
    translateFuture() {
        this.translate.next(TranslationDirection.future);
    }
    translatePast() {
        this.translate.next(TranslationDirection.past);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CalendarTimelineComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: CalendarTimelineComponent, selector: "arlas-calendar-timeline", inputs: { id: "id", granularity: "granularity", climatological: "climatological", boundDates: "boundDates", data: "data", cursorPosition: "cursorPosition", hideLeftButton: "hideLeftButton", hideRightButton: "hideRightButton" }, outputs: { selectedData: "selectedData", hoveredData: "hoveredData", translate: "translate" }, viewQueries: [{ propertyName: "timelineContainer", first: true, predicate: ["timeline_container"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div id=\"{{id}}\" #calendar_timeline class=\"calendar-timeline\">\n    <div class=\"container\">\n        <div class=\"move_button past\" [class.hide_left_button]=\"hideLeftButton\" (click)=\"translatePast()\" *ngIf=\"!climatological\">\n            <mat-icon class=\"chevron\">chevron_left</mat-icon>\n        </div>\n        <div class=\"svg_container\" \n            [class.svg_container_buttons_hidden]=\"hideLeftButton && hideRightButton\"\n            [class.svg_container_one_button_hidden]=\"(hideLeftButton && !hideRightButton) || (!hideLeftButton && hideRightButton)\"\n\n             #timeline_container>\n            <svg id=\"calendar-svg\" [style.width.px]=\"width\" [style.height.px]=\"height\" ></svg>\n        </div>\n        <div class=\"move_button future\" [class.hide_right_button]=\"hideRightButton\" (click)=\"translateFuture()\" *ngIf=\"!climatological\">\n            <mat-icon class=\"chevron\">chevron_right</mat-icon>\n        </div>\n    </div>\n\n</div>", styles: ["@charset \"UTF-8\";.calendar-timeline{width:100%}.calendar-timeline .container{display:flex;width:100%;border:1px solid #b7b7b7;border-radius:4px}.calendar-timeline .container .move_button{width:15px;background-color:#b7b7b7;display:flex;flex-direction:column;align-items:center;cursor:pointer;justify-content:center}.calendar-timeline .container .move_button .past{border-top-left-radius:2px;border-bottom-left-radius:2px}.calendar-timeline .container .move_button .past .hide_left_button{display:none}.calendar-timeline .container .move_button .future{border-top-right-radius:2px;border-bottom-right-radius:2px}.calendar-timeline .container .move_button .future .hide_right_button{display:none}.calendar-timeline .container .move_button .past .chevron,.calendar-timeline .container .move_button .future .chevron{font-size:20px;width:20px;height:20px}.calendar-timeline .container .svg_container{width:calc(100% - 30px)}.calendar-timeline .container .svg_container_one_button_hidden{width:calc(100% - 15px)}.calendar-timeline .container .svg_container_buttons_hidden{width:100%}\n"], dependencies: [{ kind: "directive", type: i2$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CalendarTimelineComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-calendar-timeline', template: "<div id=\"{{id}}\" #calendar_timeline class=\"calendar-timeline\">\n    <div class=\"container\">\n        <div class=\"move_button past\" [class.hide_left_button]=\"hideLeftButton\" (click)=\"translatePast()\" *ngIf=\"!climatological\">\n            <mat-icon class=\"chevron\">chevron_left</mat-icon>\n        </div>\n        <div class=\"svg_container\" \n            [class.svg_container_buttons_hidden]=\"hideLeftButton && hideRightButton\"\n            [class.svg_container_one_button_hidden]=\"(hideLeftButton && !hideRightButton) || (!hideLeftButton && hideRightButton)\"\n\n             #timeline_container>\n            <svg id=\"calendar-svg\" [style.width.px]=\"width\" [style.height.px]=\"height\" ></svg>\n        </div>\n        <div class=\"move_button future\" [class.hide_right_button]=\"hideRightButton\" (click)=\"translateFuture()\" *ngIf=\"!climatological\">\n            <mat-icon class=\"chevron\">chevron_right</mat-icon>\n        </div>\n    </div>\n\n</div>", styles: ["@charset \"UTF-8\";.calendar-timeline{width:100%}.calendar-timeline .container{display:flex;width:100%;border:1px solid #b7b7b7;border-radius:4px}.calendar-timeline .container .move_button{width:15px;background-color:#b7b7b7;display:flex;flex-direction:column;align-items:center;cursor:pointer;justify-content:center}.calendar-timeline .container .move_button .past{border-top-left-radius:2px;border-bottom-left-radius:2px}.calendar-timeline .container .move_button .past .hide_left_button{display:none}.calendar-timeline .container .move_button .future{border-top-right-radius:2px;border-bottom-right-radius:2px}.calendar-timeline .container .move_button .future .hide_right_button{display:none}.calendar-timeline .container .move_button .past .chevron,.calendar-timeline .container .move_button .future .chevron{font-size:20px;width:20px;height:20px}.calendar-timeline .container .svg_container{width:calc(100% - 30px)}.calendar-timeline .container .svg_container_one_button_hidden{width:calc(100% - 15px)}.calendar-timeline .container .svg_container_buttons_hidden{width:100%}\n"] }]
        }], ctorParameters: () => [], propDecorators: { id: [{
                type: Input
            }], granularity: [{
                type: Input
            }], climatological: [{
                type: Input
            }], boundDates: [{
                type: Input
            }], data: [{
                type: Input
            }], cursorPosition: [{
                type: Input
            }], hideLeftButton: [{
                type: Input
            }], hideRightButton: [{
                type: Input
            }], selectedData: [{
                type: Output
            }], hoveredData: [{
                type: Output
            }], translate: [{
                type: Output
            }], timelineContainer: [{
                type: ViewChild,
                args: ['timeline_container', { static: false }]
            }] } });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class CalendarTimelineModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CalendarTimelineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: CalendarTimelineModule, declarations: [CalendarTimelineComponent], imports: [CommonModule,
            TranslateModule,
            MatIconModule], exports: [CalendarTimelineComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CalendarTimelineModule, imports: [CommonModule,
            TranslateModule,
            MatIconModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: CalendarTimelineModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        TranslateModule,
                        MatIconModule
                    ],
                    declarations: [CalendarTimelineComponent],
                    exports: [CalendarTimelineComponent]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetValuePipe {
    transform(value, map) {
        return !!map ? map.get(value) : undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetValuePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetValuePipe, name: "getValue" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetValuePipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetValuePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'getValue'
                }]
        }, {
            type: Injectable
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetValueModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetValueModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetValueModule, declarations: [GetValuePipe], imports: [CommonModule], exports: [GetValuePipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetValueModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetValueModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        GetValuePipe
                    ],
                    exports: [
                        GetValuePipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetColorPipe {
    constructor(colorService) {
        this.colorService = colorService;
    }
    transform(key) {
        return this.colorService.getColor(key);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetColorPipe, deps: [{ token: ArlasColorService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetColorPipe, name: "getColor" }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetColorPipe }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetColorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'getColor'
                }]
        }, {
            type: Injectable
        }], ctorParameters: () => [{ type: ArlasColorService }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
class GetColorModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetColorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.13", ngImport: i0, type: GetColorModule, declarations: [GetColorPipe], imports: [ColorGeneratorModule], exports: [GetColorPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetColorModule, imports: [ColorGeneratorModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: GetColorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ColorGeneratorModule
                    ],
                    declarations: [
                        GetColorPipe
                    ],
                    exports: [
                        GetColorPipe
                    ]
                }]
        }] });

/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/*
 * Public API Surface of arlas-web-components
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ActionDisplayerPipe, ActionHandler, ArlasColorService, AwcCollectionService, AwcColorGeneratorLoader, BaseCollectionService, CalendarTimelineComponent, CalendarTimelineModule, CellBackgroundStyleEnum, CollectionModule, CollectionService, ColorGeneratorLoader, ColorGeneratorModule, Column, DonutComponent, DonutModule, FormatNumberModule, FormatNumberPipe, GetCollectionDisplayModule, GetCollectionDisplayNamePipe, GetCollectionUnitModule, GetCollectionUnitPipe, GetColorModule, GetColorPipe, GetFieldDisplayModule, GetFieldDisplayNamePipe, GetValueModule, GetValuePipe, HistogramComponent, HistogramModule, Item, MetricComponent, MetricModule, MetricsTableComponent, MetricsTableModule, ModeEnum, PROTECTED_IMAGE_HEADER, PageEnum, PowerBar, PowerbarComponent, PowerbarModule, PowerbarsComponent, PowerbarsModule, ResultActionsComponent, ResultDetailedGridComponent, ResultDetailedItemComponent, ResultFilterComponent, ResultGridTileComponent, ResultItemComponent, ResultListComponent, ResultListOptions, ResultScrollDirective, ResultsModule, ShortenNumberModule, ShortenNumberPipe, SortEnum, ThumbnailFitEnum, TranslationDirection, WmtsLayerManagerComponent, WmtsLayerManagerModule, WmtsLayerManagertDialogComponent, numberToShortValue };
//# sourceMappingURL=arlas-web-components.mjs.map
