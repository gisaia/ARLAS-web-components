/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { UntypedFormControl, Validators } from '@angular/forms';
import { Subject } from 'rxjs';
import tinycolor from 'tinycolor2';
export function formatNumber(x, formatChar = ' ') {
    if (formatChar === NUMBER_FORMAT_CHAR) {
        formatChar = ' ';
    }
    if (+x + '' !== 'NaN' && typeof +x === 'number') {
        const num = +x;
        const trunc = Math.trunc(num);
        const decimal = (num + '').split('.');
        const spacedNumber = Math.abs(trunc).toString().replace(/\B(?=(\d{3})+(?!\d))/g, formatChar);
        const spacedNumberString = trunc < 0 ? '-' + spacedNumber : spacedNumber;
        if (num < 0.09 && num > -0.09 && num !== 0) {
            return Number.parseFloat(x).toExponential(3);
        }
        return decimal.length === 2 ? spacedNumberString + '.' + decimal[1] : spacedNumberString;
    }
    return x;
}
export const NUMBER_FORMAT_CHAR = 'NUMBER_FORMAT_CHAR';
export function numberToShortValue(number, p) {
    if (Math.abs(number) < 1000) {
        if (Math.round(number) === number) {
            return number.toFixed(0);
        }
        return number.toFixed(p);
    }
    // what tier? (determines SI symbol)
    const suffixes = ['', 'k', 'M', 'b', 't'];
    const suffixNum = Math.log10(Math.abs(number)) / 3 | 0;
    if (suffixNum === 0) {
        return number.toString();
    }
    // get suffix and determine scale
    const suffix = suffixes[suffixNum];
    const scale = Math.pow(10, suffixNum * 3);
    // scale the number
    const scaled = number / scale;
    // format number and add suffix
    return scaled.toFixed(p) + ' ' + suffix;
}
export const DEFAULT_SHORTENING_PRECISION = 2;
export function getKeys(map) {
    return Array.from(map.keys());
}
export function getValues(map) {
    return Array.from(map.values());
}
export class ColorGeneratorLoader {
}
export class AwcColorGeneratorLoader extends ColorGeneratorLoader {
    constructor() {
        super(...arguments);
        this.changekeysToColors$ = new Subject().asObservable();
        this.colorsSaturationWeight = 0.5;
    }
    /**
     * This method generates a determistic color from the given key, a list of [key, color] and a saturation weight.
     * - First the method checks if the [key,color] is defined in externalkeysToColors and returns the correspondant color.
     *
     * - If externalkeysToColors parameter is undefined, then the method checks if the [key,color] is defined in
     * keysToColors attribute of the loader
     *
     * - If neither `externalkeysToColors` parameter nor `keysToColors` attribute are defined, then the color is generated using a determist
     * method.
     * - For this determinist method, the generated colors saturation scale can be tightened using `externalColorsSaturationWeight` parameter
     * - If the parameter `externalColorsSaturationWeight` is undefined, the attribute `colorsSaturationWeight` is used instead.
     * @param key The text from which the color is generated
     * @param externalkeysToColors List of [key, color] couples that associates a hex color to each key.
     * @param colorsSaturationWeight Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a factor (between 0 and 1) that
     * tightens this scale to [(1-colorsSaturationWeight), 1]. Therefore all generated colors saturation will be within this scale.
     */
    getColor(key, externalKeysToColors, externalColorsSaturationWeight) {
        let colorHex = null;
        const keysToColors = externalKeysToColors ? externalKeysToColors : this.keysToColors;
        const saturationWeight = (externalColorsSaturationWeight !== undefined && externalColorsSaturationWeight !== null) ?
            externalColorsSaturationWeight : this.colorsSaturationWeight;
        if (keysToColors) {
            for (let i = 0; i < keysToColors.length; i++) {
                const keyToColor = keysToColors[i];
                if (keyToColor[0] === key) {
                    colorHex = keyToColor[1];
                    break;
                }
            }
            if (!colorHex) {
                colorHex = this.getHexColor(key, saturationWeight);
            }
        }
        else {
            colorHex = this.getHexColor(key, saturationWeight);
        }
        return colorHex;
    }
    getTextColor(color) {
        return '#000000';
    }
    getHexColor(key, saturationWeight) {
        const text = key + ':' + key;
        // string to int
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
            hash = text.charCodeAt(i) + ((hash << 5) - hash);
        }
        // int to rgb
        let hex = (hash & 0x00FFFFFF).toString(16).toUpperCase();
        hex = '00000'.substring(0, 6 - hex.length) + hex;
        const color = tinycolor.mix(hex, hex);
        color.saturate(color.toHsv().s * saturationWeight + ((1 - saturationWeight) * 100));
        return color.toHexString();
    }
}
export class SelectFormControl extends UntypedFormControl {
    constructor(formState, label, options) {
        super(formState, Validators.required);
        this.syncOptions = [];
        this.setValue(formState);
        this.setSyncOptions(options);
    }
    setSyncOptions(newOptions) {
        this.syncOptions = newOptions;
        this.filteredOptions = newOptions;
    }
}
const ARLAS_ID = 'arlas_id:';
/** FROM V15.0.0 layer ids look like 'arlas_id:NAME:timestamp
   * This pipe extracts the 'NAME' in that id
   */
export function getLayerName(id) {
    if (!!id && id.startsWith(ARLAS_ID)) {
        const datedName = id.split(ARLAS_ID)[1];
        const undatedName = datedName.split(':')[0];
        return undatedName;
    }
    return id;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50c1V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYXJsYXMtY29tcG9uZW50cy9zcmMvbGliL2NvbXBvbmVudHMvY29tcG9uZW50c1V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUVILE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNoRSxPQUFPLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sU0FBUyxNQUFNLFlBQVksQ0FBQztBQUVuQyxNQUFNLFVBQVUsWUFBWSxDQUFDLENBQUMsRUFBRSxVQUFVLEdBQUcsR0FBRztJQUM5QyxJQUFJLFVBQVUsS0FBSyxrQkFBa0IsRUFBRSxDQUFDO1FBQ3RDLFVBQVUsR0FBRyxHQUFHLENBQUM7SUFDbkIsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLEtBQUssSUFBSSxPQUFPLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQ2hELE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2YsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5QixNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDN0YsTUFBTSxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7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QUM7Q0FDRjtBQUNELE1BQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQztBQUU3Qjs7S0FFSztBQUNMLE1BQU0sVUFBVSxZQUFZLENBQUMsRUFBVTtJQUNyQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBQ3BDLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEMsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QyxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDO0lBQ0QsT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIExpY2Vuc2VkIHRvIEdpc2HDr2EgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UudHh0IGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gR2lzYcOvYSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFVudHlwZWRGb3JtQ29udHJvbCwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB0aW55Y29sb3IgZnJvbSAndGlueWNvbG9yMic7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIoeCwgZm9ybWF0Q2hhciA9ICcgJyk6IHN0cmluZyB7XG4gIGlmIChmb3JtYXRDaGFyID09PSBOVU1CRVJfRk9STUFUX0NIQVIpIHtcbiAgICBmb3JtYXRDaGFyID0gJyAnO1xuICB9XG4gIGlmICgreCArICcnICE9PSAnTmFOJyAmJiB0eXBlb2YgK3ggPT09ICdudW1iZXInKSB7XG4gICAgY29uc3QgbnVtID0gK3g7XG4gICAgY29uc3QgdHJ1bmMgPSBNYXRoLnRydW5jKG51bSk7XG4gICAgY29uc3QgZGVjaW1hbCA9IChudW0gKyAnJykuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzcGFjZWROdW1iZXIgPSBNYXRoLmFicyh0cnVuYykudG9TdHJpbmcoKS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBmb3JtYXRDaGFyKTtcbiAgICBjb25zdCBzcGFjZWROdW1iZXJTdHJpbmcgPSB0cnVuYyA8IDAgPyAnLScgKyBzcGFjZWROdW1iZXIgOiBzcGFjZWROdW1iZXI7XG4gICAgaWYgKG51bSA8IDAuMDkgJiYgbnVtID4gLTAuMDkgJiYgbnVtICE9PSAwKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlRmxvYXQoeCkudG9FeHBvbmVudGlhbCgzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYWwubGVuZ3RoID09PSAyID8gc3BhY2VkTnVtYmVyU3RyaW5nICsgJy4nICsgZGVjaW1hbFsxXSA6IHNwYWNlZE51bWJlclN0cmluZztcbiAgfVxuICByZXR1cm4geDtcbn1cbmV4cG9ydCBjb25zdCBOVU1CRVJfRk9STUFUX0NIQVIgPSAnTlVNQkVSX0ZPUk1BVF9DSEFSJztcblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvU2hvcnRWYWx1ZShudW1iZXI6IG51bWJlciwgcD86IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChNYXRoLmFicyhudW1iZXIpIDwgMTAwMCkge1xuICAgIGlmIChNYXRoLnJvdW5kKG51bWJlcikgPT09IG51bWJlcikge1xuICAgICAgcmV0dXJuIG51bWJlci50b0ZpeGVkKDApO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyLnRvRml4ZWQocCk7XG4gIH1cblxuICAvLyB3aGF0IHRpZXI/IChkZXRlcm1pbmVzIFNJIHN5bWJvbClcbiAgY29uc3Qgc3VmZml4ZXMgPSBbJycsICdrJywgJ00nLCAnYicsICd0J107XG4gIGNvbnN0IHN1ZmZpeE51bSA9IE1hdGgubG9nMTAoTWF0aC5hYnMobnVtYmVyKSkgLyAzIHwgMDtcblxuICBpZiAoc3VmZml4TnVtID09PSAwKSB7XG4gICAgcmV0dXJuIG51bWJlci50b1N0cmluZygpO1xuICB9XG4gIC8vIGdldCBzdWZmaXggYW5kIGRldGVybWluZSBzY2FsZVxuICBjb25zdCBzdWZmaXggPSBzdWZmaXhlc1tzdWZmaXhOdW1dO1xuICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDEwLCBzdWZmaXhOdW0gKiAzKTtcbiAgLy8gc2NhbGUgdGhlIG51bWJlclxuICBjb25zdCBzY2FsZWQgPSBudW1iZXIgLyBzY2FsZTtcbiAgLy8gZm9ybWF0IG51bWJlciBhbmQgYWRkIHN1ZmZpeFxuICByZXR1cm4gc2NhbGVkLnRvRml4ZWQocCkgKyAnICcgKyBzdWZmaXg7XG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9TSE9SVEVOSU5HX1BSRUNJU0lPTiA9IDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlzKG1hcCk6IEFycmF5PHN0cmluZz4ge1xuICByZXR1cm4gQXJyYXkuZnJvbShtYXAua2V5cygpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlcyhtYXApOiBBcnJheTxhbnk+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20obWFwLnZhbHVlcygpKTtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbG9yR2VuZXJhdG9yTG9hZGVyIHtcbiAgcHVibGljIGFic3RyYWN0IGtleXNUb0NvbG9yczogQXJyYXk8W3N0cmluZywgc3RyaW5nXT47XG4gIHB1YmxpYyBhYnN0cmFjdCBjb2xvcnNTYXR1cmF0aW9uV2VpZ2h0OiBudW1iZXI7XG4gIHB1YmxpYyBhYnN0cmFjdCBjaGFuZ2VrZXlzVG9Db2xvcnMkOiBPYnNlcnZhYmxlPHZvaWQ+O1xuICAvKipcbiAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgZGV0ZXJtaXN0aWMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4ga2V5LCBhIGxpc3Qgb2YgW2tleSwgY29sb3JdIGFuZCBhIHNhdHVyYXRpb24gd2VpZ2h0LlxuICAgKiBAcGFyYW0ga2V5IFRoZSB0ZXh0IGZyb20gd2hpY2ggdGhlIGNvbG9yIGlzIGdlbmVyYXRlZFxuICAgKiBAcGFyYW0gZXh0ZXJuYWxrZXlzVG9Db2xvcnMgTGlzdCBvZiBba2V5LCBjb2xvcl0gY291cGxlcyB0aGF0IGFzc29jaWF0ZXMgYSBoZXggY29sb3IgdG8gZWFjaCBrZXkuXG4gICAqIEBwYXJhbSBjb2xvcnNTYXR1cmF0aW9uV2VpZ2h0IEtub3dpbmcgdGhhdCBzYXR1cmF0aW9uIHNjYWxlIGlzIFswLCAxXSwgYGNvbG9yc1NhdHVyYXRpb25XZWlnaHRgIGlzIGEgZmFjdG9yIChiZXR3ZWVuIDAgYW5kIDEpIHRoYXRcbiAgICogdGlnaHRlbnMgdGhpcyBzY2FsZSB0byBbKDEtY29sb3JzU2F0dXJhdGlvbldlaWdodCksIDFdLiBUaGVyZWZvcmUgYWxsIGdlbmVyYXRlZCBjb2xvcnMgc2F0dXJhdGlvbiB3aWxsIGJlIHdpdGhpbiB0aGlzIHNjYWxlLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IGdldENvbG9yKGtleTogc3RyaW5nLCBleHRlcm5hbGtleXNUb0NvbG9yczogQXJyYXk8W3N0cmluZywgc3RyaW5nXT4sIGV4dGVybmFsQ29sb3JzU2F0dXJhdGlvbldlaWdodDogbnVtYmVyKTogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0VGV4dENvbG9yKGNvbG9yKTogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQXdjQ29sb3JHZW5lcmF0b3JMb2FkZXIgZXh0ZW5kcyBDb2xvckdlbmVyYXRvckxvYWRlciB7XG4gIHB1YmxpYyBjaGFuZ2VrZXlzVG9Db2xvcnMkOiBPYnNlcnZhYmxlPHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKS5hc09ic2VydmFibGUoKTtcbiAgcHVibGljIGtleXNUb0NvbG9yczogQXJyYXk8W3N0cmluZywgc3RyaW5nXT47XG4gIHB1YmxpYyBjb2xvcnNTYXR1cmF0aW9uV2VpZ2h0ID0gMC41O1xuICAvKipcbiAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgZGV0ZXJtaXN0aWMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4ga2V5LCBhIGxpc3Qgb2YgW2tleSwgY29sb3JdIGFuZCBhIHNhdHVyYXRpb24gd2VpZ2h0LlxuICAgKiAtIEZpcnN0IHRoZSBtZXRob2QgY2hlY2tzIGlmIHRoZSBba2V5LGNvbG9yXSBpcyBkZWZpbmVkIGluIGV4dGVybmFsa2V5c1RvQ29sb3JzIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kYW50IGNvbG9yLlxuICAgKlxuICAgKiAtIElmIGV4dGVybmFsa2V5c1RvQ29sb3JzIHBhcmFtZXRlciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIG1ldGhvZCBjaGVja3MgaWYgdGhlIFtrZXksY29sb3JdIGlzIGRlZmluZWQgaW5cbiAgICoga2V5c1RvQ29sb3JzIGF0dHJpYnV0ZSBvZiB0aGUgbG9hZGVyXG4gICAqXG4gICAqIC0gSWYgbmVpdGhlciBgZXh0ZXJuYWxrZXlzVG9Db2xvcnNgIHBhcmFtZXRlciBub3IgYGtleXNUb0NvbG9yc2AgYXR0cmlidXRlIGFyZSBkZWZpbmVkLCB0aGVuIHRoZSBjb2xvciBpcyBnZW5lcmF0ZWQgdXNpbmcgYSBkZXRlcm1pc3RcbiAgICogbWV0aG9kLlxuICAgKiAtIEZvciB0aGlzIGRldGVybWluaXN0IG1ldGhvZCwgdGhlIGdlbmVyYXRlZCBjb2xvcnMgc2F0dXJhdGlvbiBzY2FsZSBjYW4gYmUgdGlnaHRlbmVkIHVzaW5nIGBleHRlcm5hbENvbG9yc1NhdHVyYXRpb25XZWlnaHRgIHBhcmFtZXRlclxuICAgKiAtIElmIHRoZSBwYXJhbWV0ZXIgYGV4dGVybmFsQ29sb3JzU2F0dXJhdGlvbldlaWdodGAgaXMgdW5kZWZpbmVkLCB0aGUgYXR0cmlidXRlIGBjb2xvcnNTYXR1cmF0aW9uV2VpZ2h0YCBpcyB1c2VkIGluc3RlYWQuXG4gICAqIEBwYXJhbSBrZXkgVGhlIHRleHQgZnJvbSB3aGljaCB0aGUgY29sb3IgaXMgZ2VuZXJhdGVkXG4gICAqIEBwYXJhbSBleHRlcm5hbGtleXNUb0NvbG9ycyBMaXN0IG9mIFtrZXksIGNvbG9yXSBjb3VwbGVzIHRoYXQgYXNzb2NpYXRlcyBhIGhleCBjb2xvciB0byBlYWNoIGtleS5cbiAgICogQHBhcmFtIGNvbG9yc1NhdHVyYXRpb25XZWlnaHQgS25vd2luZyB0aGF0IHNhdHVyYXRpb24gc2NhbGUgaXMgWzAsIDFdLCBgY29sb3JzU2F0dXJhdGlvbldlaWdodGAgaXMgYSBmYWN0b3IgKGJldHdlZW4gMCBhbmQgMSkgdGhhdFxuICAgKiB0aWdodGVucyB0aGlzIHNjYWxlIHRvIFsoMS1jb2xvcnNTYXR1cmF0aW9uV2VpZ2h0KSwgMV0uIFRoZXJlZm9yZSBhbGwgZ2VuZXJhdGVkIGNvbG9ycyBzYXR1cmF0aW9uIHdpbGwgYmUgd2l0aGluIHRoaXMgc2NhbGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29sb3Ioa2V5OiBzdHJpbmcsIGV4dGVybmFsS2V5c1RvQ29sb3JzOiBBcnJheTxbc3RyaW5nLCBzdHJpbmddPiwgZXh0ZXJuYWxDb2xvcnNTYXR1cmF0aW9uV2VpZ2h0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGxldCBjb2xvckhleCA9IG51bGw7XG4gICAgY29uc3Qga2V5c1RvQ29sb3JzID0gZXh0ZXJuYWxLZXlzVG9Db2xvcnMgPyBleHRlcm5hbEtleXNUb0NvbG9ycyA6IHRoaXMua2V5c1RvQ29sb3JzO1xuICAgIGNvbnN0IHNhdHVyYXRpb25XZWlnaHQgPSAoZXh0ZXJuYWxDb2xvcnNTYXR1cmF0aW9uV2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgZXh0ZXJuYWxDb2xvcnNTYXR1cmF0aW9uV2VpZ2h0ICE9PSBudWxsKSA/XG4gICAgICBleHRlcm5hbENvbG9yc1NhdHVyYXRpb25XZWlnaHQgOiB0aGlzLmNvbG9yc1NhdHVyYXRpb25XZWlnaHQ7XG4gICAgaWYgKGtleXNUb0NvbG9ycykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzVG9Db2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5VG9Db2xvciA9IGtleXNUb0NvbG9yc1tpXTtcbiAgICAgICAgaWYgKGtleVRvQ29sb3JbMF0gPT09IGtleSkge1xuICAgICAgICAgIGNvbG9ySGV4ID0ga2V5VG9Db2xvclsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjb2xvckhleCkge1xuICAgICAgICBjb2xvckhleCA9IHRoaXMuZ2V0SGV4Q29sb3Ioa2V5LCBzYXR1cmF0aW9uV2VpZ2h0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3JIZXggPSB0aGlzLmdldEhleENvbG9yKGtleSwgc2F0dXJhdGlvbldlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvckhleDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUZXh0Q29sb3IoY29sb3IpOiBzdHJpbmcge1xuICAgIHJldHVybiAnIzAwMDAwMCc7XG4gIH1cblxuICBwcml2YXRlIGdldEhleENvbG9yKGtleTogc3RyaW5nLCBzYXR1cmF0aW9uV2VpZ2h0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHRleHQgPSBrZXkgKyAnOicgKyBrZXk7XG4gICAgLy8gc3RyaW5nIHRvIGludFxuICAgIGxldCBoYXNoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSkgKyAoKGhhc2ggPDwgNSkgLSBoYXNoKTtcbiAgICB9XG4gICAgLy8gaW50IHRvIHJnYlxuICAgIGxldCBoZXggPSAoaGFzaCAmIDB4MDBGRkZGRkYpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIGhleCA9ICcwMDAwMCcuc3Vic3RyaW5nKDAsIDYgLSBoZXgubGVuZ3RoKSArIGhleDtcbiAgICBjb25zdCBjb2xvciA9IHRpbnljb2xvci5taXgoaGV4LCBoZXgpO1xuICAgIGNvbG9yLnNhdHVyYXRlKGNvbG9yLnRvSHN2KCkucyAqIHNhdHVyYXRpb25XZWlnaHQgKyAoKDEgLSBzYXR1cmF0aW9uV2VpZ2h0KSAqIDEwMCkpO1xuICAgIHJldHVybiBjb2xvci50b0hleFN0cmluZygpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3RGb3JtQ29udHJvbCBleHRlbmRzIFVudHlwZWRGb3JtQ29udHJvbCB7XG5cbiAgLy8gdXNlZCBvbmx5IGZvciBhdXRvY29tcGxldGU6IGxpc3Qgb2YgZmlsdGVyZWQgb3B0aW9uc1xuICBwdWJsaWMgZmlsdGVyZWRPcHRpb25zOiBBcnJheTxzdHJpbmc+O1xuICBwdWJsaWMgc3luY09wdGlvbnM6IEFycmF5PHN0cmluZz4gPSBbXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgZm9ybVN0YXRlOiBhbnksXG4gICAgbGFiZWw6IHN0cmluZyxcbiAgICBvcHRpb25zOiBBcnJheTxzdHJpbmc+KSB7XG5cbiAgICBzdXBlcihmb3JtU3RhdGUsIFZhbGlkYXRvcnMucmVxdWlyZWQpO1xuICAgIHRoaXMuc2V0VmFsdWUoZm9ybVN0YXRlKTtcbiAgICB0aGlzLnNldFN5bmNPcHRpb25zKG9wdGlvbnMpO1xuXG4gIH1cblxuICBwdWJsaWMgc2V0U3luY09wdGlvbnMobmV3T3B0aW9uczogQXJyYXk8c3RyaW5nPikge1xuICAgIHRoaXMuc3luY09wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHRoaXMuZmlsdGVyZWRPcHRpb25zID0gbmV3T3B0aW9ucztcbiAgfVxufVxuY29uc3QgQVJMQVNfSUQgPSAnYXJsYXNfaWQ6JztcblxuLyoqIEZST00gVjE1LjAuMCBsYXllciBpZHMgbG9vayBsaWtlICdhcmxhc19pZDpOQU1FOnRpbWVzdGFtcFxuICAgKiBUaGlzIHBpcGUgZXh0cmFjdHMgdGhlICdOQU1FJyBpbiB0aGF0IGlkXG4gICAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExheWVyTmFtZShpZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCEhaWQgJiYgaWQuc3RhcnRzV2l0aChBUkxBU19JRCkpIHtcbiAgICBjb25zdCBkYXRlZE5hbWUgPSBpZC5zcGxpdChBUkxBU19JRClbMV07XG4gICAgY29uc3QgdW5kYXRlZE5hbWUgPSBkYXRlZE5hbWUuc3BsaXQoJzonKVswXTtcbiAgICByZXR1cm4gdW5kYXRlZE5hbWU7XG4gIH1cbiAgcmV0dXJuIGlkO1xufVxuIl19