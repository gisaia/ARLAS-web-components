/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { Component, Input } from '@angular/core';
import { NUMBER_FORMAT_CHAR, numberToShortValue } from '../componentsUtils';
import * as metricJsonSchema from './metric.schema.json';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../../pipes/format-number/format-number.pipe";
import * as i3 from "@ngx-translate/core";
/**
 * This component will contain a phrase composed of 3 parts
 * - beforeValue = `Speed average : `
 * - value = `25`
 * - afterValue = ` km/h`.
 * The phrase that will be represented in this card is : **Speed average : 25 km/h**
 *
 */
export class MetricComponent {
    constructor() {
        this.beforeValue = '';
        this.afterValue = '';
        this.valuePrecision = 2;
        /**
         * Whether to shorten the metric value
         */
        this.shortValue = false;
        /**
         * Whether to display a '~' before the metric value
         */
        this.approximateValue = false;
        /**
         * @Input : Angular
         * @description Chart's width. If not specified, the chart takes the component's container width.
         */
        this.chartWidth = null;
        this.displayedValue = '0';
        this.NUMBER_FORMAT_CHAR = NUMBER_FORMAT_CHAR;
    }
    ngOnInit() {
        if (this.value) {
            this.setDisplayedValue();
        }
    }
    ngOnChanges(changes) {
        if (changes['value']) {
            if (this.value !== undefined && !Number.isNaN(this.value)) {
                this.setDisplayedValue();
            }
            else {
                /** '-' will be set when `value` is undefined or not a number */
                this.displayedValue = '-';
            }
        }
    }
    /**
     * @returns Json schema of the donut component for configuration
     */
    static getMetricJsonSchema() {
        return metricJsonSchema;
    }
    static round(value, precision) {
        if (precision === 0 || precision === undefined) {
            return Math.round(value);
        }
        else {
            const multiplier = Math.pow(10, precision * 10 || 0);
            return +(Math.round(value * multiplier) / multiplier).toFixed(precision);
        }
    }
    /**
     * Sets the value displayed in html
     */
    setDisplayedValue() {
        if (this.shortValue) {
            this.displayedValue = numberToShortValue(this.value, this.valuePrecision);
        }
        else {
            this.displayedValue = MetricComponent.round(this.value, this.valuePrecision);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: MetricComponent, selector: "arlas-metric", inputs: { beforeValue: "beforeValue", value: "value", afterValue: "afterValue", customizedCssClass: "customizedCssClass", valuePrecision: "valuePrecision", shortValue: "shortValue", approximateValue: "approximateValue", chartWidth: "chartWidth" }, usesOnChanges: true, ngImport: i0, template: "<div [style.width.px]=\"!!chartWidth ? chartWidth : 'unset'\" class=\"arlas-metric\" [ngClass]=\"customizedCssClass\" >\n  <div class=\"arlas-metric__title\">\n    {{beforeValue | translate}}\n  </div>\n  <div class=\"arlas-metric__value\">\n    <span class=\"arlas-metric__value--approximmate\" *ngIf=\"approximateValue\"> ~ </span>\n    {{this.displayedValue | formatNumber:NUMBER_FORMAT_CHAR}}\n  </div>\n  <div class=\"arlas-metric__description\">\n    {{afterValue | translate}}\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.arlas-metric{line-height:normal;padding-top:10px;padding-bottom:10px}.arlas-metric__title{text-align:center;white-space:nowrap;display:flex;justify-content:center;font-size:16px}.arlas-metric__value{font-weight:400;font-size:25px;padding:5px 0;white-space:nowrap;display:flex;justify-content:center}.arlas-metric__description{font-size:16px;font-weight:300;display:flex;justify-content:center}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i2.FormatNumberPipe, name: "formatNumber" }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: MetricComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-metric', template: "<div [style.width.px]=\"!!chartWidth ? chartWidth : 'unset'\" class=\"arlas-metric\" [ngClass]=\"customizedCssClass\" >\n  <div class=\"arlas-metric__title\">\n    {{beforeValue | translate}}\n  </div>\n  <div class=\"arlas-metric__value\">\n    <span class=\"arlas-metric__value--approximmate\" *ngIf=\"approximateValue\"> ~ </span>\n    {{this.displayedValue | formatNumber:NUMBER_FORMAT_CHAR}}\n  </div>\n  <div class=\"arlas-metric__description\">\n    {{afterValue | translate}}\n  </div>\n</div>\n", styles: ["@charset \"UTF-8\";.arlas-metric{line-height:normal;padding-top:10px;padding-bottom:10px}.arlas-metric__title{text-align:center;white-space:nowrap;display:flex;justify-content:center;font-size:16px}.arlas-metric__value{font-weight:400;font-size:25px;padding:5px 0;white-space:nowrap;display:flex;justify-content:center}.arlas-metric__description{font-size:16px;font-weight:300;display:flex;justify-content:center}\n"] }]
        }], ctorParameters: () => [], propDecorators: { beforeValue: [{
                type: Input
            }], value: [{
                type: Input
            }], afterValue: [{
                type: Input
            }], customizedCssClass: [{
                type: Input
            }], valuePrecision: [{
                type: Input
            }], shortValue: [{
                type: Input
            }], approximateValue: [{
                type: Input
            }], chartWidth: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0cmljLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FybGFzLWNvbXBvbmVudHMvc3JjL2xpYi9jb21wb25lbnRzL21ldHJpYy9tZXRyaWMuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYXJsYXMtY29tcG9uZW50cy9zcmMvbGliL2NvbXBvbmVudHMvbWV0cmljL21ldHJpYy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFFSCxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBb0MsTUFBTSxlQUFlLENBQUM7QUFDbkYsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDNUUsT0FBTyxLQUFLLGdCQUFnQixNQUFNLHNCQUFzQixDQUFDOzs7OztBQVF6RDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxPQUFPLGVBQWU7SUEwQjFCO1FBdkJnQixnQkFBVyxHQUFHLEVBQUUsQ0FBQztRQUVqQixlQUFVLEdBQUcsRUFBRSxDQUFDO1FBRWhCLG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBQ25DOztXQUVHO1FBQ2EsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUNuQzs7V0FFRztRQUNhLHFCQUFnQixHQUFHLEtBQUssQ0FBQztRQUV6Qzs7O1dBR0c7UUFDYSxlQUFVLEdBQUcsSUFBSSxDQUFDO1FBRTNCLG1CQUFjLEdBQW9CLEdBQUcsQ0FBQztRQUN0Qyx1QkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztJQUV4QixDQUFDO0lBRWpCLFFBQVE7UUFDYixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzNCLENBQUM7SUFDSCxDQUFDO0lBRU0sV0FBVyxDQUFDLE9BQXNCO1FBQ3ZDLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFDckIsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQzFELElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBQzNCLENBQUM7aUJBQU0sQ0FBQztnQkFDTixnRUFBZ0U7Z0JBQ2hFLElBQUksQ0FBQyxjQUFjLEdBQUcsR0FBRyxDQUFDO1lBQzVCLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLG1CQUFtQjtRQUMvQixPQUFPLGdCQUFnQixDQUFDO0lBQzFCLENBQUM7SUFFTSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQWEsRUFBRSxTQUFpQjtRQUNsRCxJQUFJLFNBQVMsS0FBSyxDQUFDLElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQy9DLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQixDQUFDO2FBQU0sQ0FBQztZQUNOLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLFNBQVMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDckQsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNFLENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxpQkFBaUI7UUFDdkIsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDcEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUM1RSxDQUFDO2FBQU0sQ0FBQztZQUNOLElBQUksQ0FBQyxjQUFjLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUMvRSxDQUFDO0lBQ0gsQ0FBQzsrR0F0RVUsZUFBZTttR0FBZixlQUFlLGlVQ3JDNUIseWZBWUE7OzRGRHlCYSxlQUFlO2tCQWIzQixTQUFTOytCQUNFLGNBQWM7d0RBZVIsV0FBVztzQkFBMUIsS0FBSztnQkFDVSxLQUFLO3NCQUFwQixLQUFLO2dCQUNVLFVBQVU7c0JBQXpCLEtBQUs7Z0JBQ1Usa0JBQWtCO3NCQUFqQyxLQUFLO2dCQUNVLGNBQWM7c0JBQTdCLEtBQUs7Z0JBSVUsVUFBVTtzQkFBekIsS0FBSztnQkFJVSxnQkFBZ0I7c0JBQS9CLEtBQUs7Z0JBTVUsVUFBVTtzQkFBekIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBMaWNlbnNlZCB0byBHaXNhw69hIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFLnR4dCBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEdpc2HDr2EgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTlVNQkVSX0ZPUk1BVF9DSEFSLCBudW1iZXJUb1Nob3J0VmFsdWUgfSBmcm9tICcuLi9jb21wb25lbnRzVXRpbHMnO1xuaW1wb3J0ICogYXMgbWV0cmljSnNvblNjaGVtYSBmcm9tICcuL21ldHJpYy5zY2hlbWEuanNvbic7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYXJsYXMtbWV0cmljJyxcbiAgdGVtcGxhdGVVcmw6ICcuL21ldHJpYy5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL21ldHJpYy5jb21wb25lbnQuc2NzcyddXG59KVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGNvbnRhaW4gYSBwaHJhc2UgY29tcG9zZWQgb2YgMyBwYXJ0c1xuICogLSBiZWZvcmVWYWx1ZSA9IGBTcGVlZCBhdmVyYWdlIDogYFxuICogLSB2YWx1ZSA9IGAyNWBcbiAqIC0gYWZ0ZXJWYWx1ZSA9IGAga20vaGAuXG4gKiBUaGUgcGhyYXNlIHRoYXQgd2lsbCBiZSByZXByZXNlbnRlZCBpbiB0aGlzIGNhcmQgaXMgOiAqKlNwZWVkIGF2ZXJhZ2UgOiAyNSBrbS9oKipcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXRyaWNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG5cblxuICBASW5wdXQoKSBwdWJsaWMgYmVmb3JlVmFsdWUgPSAnJztcbiAgQElucHV0KCkgcHVibGljIHZhbHVlOiBudW1iZXI7XG4gIEBJbnB1dCgpIHB1YmxpYyBhZnRlclZhbHVlID0gJyc7XG4gIEBJbnB1dCgpIHB1YmxpYyBjdXN0b21pemVkQ3NzQ2xhc3M6IHN0cmluZztcbiAgQElucHV0KCkgcHVibGljIHZhbHVlUHJlY2lzaW9uID0gMjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2hvcnRlbiB0aGUgbWV0cmljIHZhbHVlXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgc2hvcnRWYWx1ZSA9IGZhbHNlO1xuICAvKipcbiAgICogV2hldGhlciB0byBkaXNwbGF5IGEgJ34nIGJlZm9yZSB0aGUgbWV0cmljIHZhbHVlXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgYXBwcm94aW1hdGVWYWx1ZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBASW5wdXQgOiBBbmd1bGFyXG4gICAqIEBkZXNjcmlwdGlvbiBDaGFydCdzIHdpZHRoLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgY2hhcnQgdGFrZXMgdGhlIGNvbXBvbmVudCdzIGNvbnRhaW5lciB3aWR0aC5cbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBjaGFydFdpZHRoID0gbnVsbDtcblxuICBwdWJsaWMgZGlzcGxheWVkVmFsdWU6IHN0cmluZyB8IG51bWJlciA9ICcwJztcbiAgcHVibGljIE5VTUJFUl9GT1JNQVRfQ0hBUiA9IE5VTUJFUl9GT1JNQVRfQ0hBUjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7IH1cblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0RGlzcGxheWVkVmFsdWUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzWyd2YWx1ZSddKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFOdW1iZXIuaXNOYU4odGhpcy52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zZXREaXNwbGF5ZWRWYWx1ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqICctJyB3aWxsIGJlIHNldCB3aGVuIGB2YWx1ZWAgaXMgdW5kZWZpbmVkIG9yIG5vdCBhIG51bWJlciAqL1xuICAgICAgICB0aGlzLmRpc3BsYXllZFZhbHVlID0gJy0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBKc29uIHNjaGVtYSBvZiB0aGUgZG9udXQgY29tcG9uZW50IGZvciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldE1ldHJpY0pzb25TY2hlbWEoKTogT2JqZWN0IHtcbiAgICByZXR1cm4gbWV0cmljSnNvblNjaGVtYTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcm91bmQodmFsdWU6IG51bWJlciwgcHJlY2lzaW9uOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChwcmVjaXNpb24gPT09IDAgfHwgcHJlY2lzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24gKiAxMCB8fCAwKTtcbiAgICAgIHJldHVybiArKE1hdGgucm91bmQodmFsdWUgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXIpLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZGlzcGxheWVkIGluIGh0bWxcbiAgICovXG4gIHByaXZhdGUgc2V0RGlzcGxheWVkVmFsdWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2hvcnRWYWx1ZSkge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRWYWx1ZSA9IG51bWJlclRvU2hvcnRWYWx1ZSh0aGlzLnZhbHVlLCB0aGlzLnZhbHVlUHJlY2lzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRWYWx1ZSA9IE1ldHJpY0NvbXBvbmVudC5yb3VuZCh0aGlzLnZhbHVlLCB0aGlzLnZhbHVlUHJlY2lzaW9uKTtcbiAgICB9XG4gIH1cbn1cbiIsIjxkaXYgW3N0eWxlLndpZHRoLnB4XT1cIiEhY2hhcnRXaWR0aCA/IGNoYXJ0V2lkdGggOiAndW5zZXQnXCIgY2xhc3M9XCJhcmxhcy1tZXRyaWNcIiBbbmdDbGFzc109XCJjdXN0b21pemVkQ3NzQ2xhc3NcIiA+XG4gIDxkaXYgY2xhc3M9XCJhcmxhcy1tZXRyaWNfX3RpdGxlXCI+XG4gICAge3tiZWZvcmVWYWx1ZSB8IHRyYW5zbGF0ZX19XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiYXJsYXMtbWV0cmljX192YWx1ZVwiPlxuICAgIDxzcGFuIGNsYXNzPVwiYXJsYXMtbWV0cmljX192YWx1ZS0tYXBwcm94aW1tYXRlXCIgKm5nSWY9XCJhcHByb3hpbWF0ZVZhbHVlXCI+IH4gPC9zcGFuPlxuICAgIHt7dGhpcy5kaXNwbGF5ZWRWYWx1ZSB8IGZvcm1hdE51bWJlcjpOVU1CRVJfRk9STUFUX0NIQVJ9fVxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImFybGFzLW1ldHJpY19fZGVzY3JpcHRpb25cIj5cbiAgICB7e2FmdGVyVmFsdWUgfCB0cmFuc2xhdGV9fVxuICA8L2Rpdj5cbjwvZGl2PlxuIl19