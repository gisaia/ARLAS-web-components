/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { Directive, ElementRef, HostListener, Input, Output } from '@angular/core';
import { Subject } from 'rxjs';
import { ModeEnum } from '../utils/enumerations/modeEnum';
import * as i0 from "@angular/core";
export class ResultScrollDirective {
    constructor(el) {
        this.el = el;
        this.nextDataEvent = new Subject();
        this.previousDataEvent = new Subject();
        this.visibleItems = new Subject();
        this.lastScrollTop = 0;
        this.previousFirstId = null;
        this.previousLastId = null;
        this.scrolledProgramatically = false;
    }
    ngOnChanges(changes) {
        if (changes['items']) {
            /** New data is loaded : we reset all the variables */
            this.lastScrollTop = 0;
            this.previousFirstId = null;
            this.previousLastId = null;
            /** Repositioning the scroll bar to the top*/
            this.el.nativeElement.scrollTop = 0;
        }
        if (changes['resultMode']) {
            this.adjustScrollToMode();
        }
        if (changes['scrollOptions']) {
            if (this.scrollOptions.maintainScrollUpPosition === true && this.items) {
                /**
                 * Maintains the scroll position after loading rows in the top of the list
                 */
                this.el.nativeElement.scrollTop = this.el.nativeElement.scrollHeight * this.scrollOptions.nbLines / this.items.length;
            }
            if (this.scrollOptions.maintainScrollDownPosition === true && this.items) {
                /**
                 * Maintains the scroll position after loading rows in the bottom of the list
                 */
                this.el.nativeElement.scrollTop = this.el.nativeElement.scrollHeight -
                    this.el.nativeElement.scrollHeight * this.scrollOptions.nbLines / this.items.length - this.tbodyHeight / 2;
            }
        }
    }
    /** This method allows to stay around the same items when switching the mode grid/list */
    adjustScrollToMode() {
        if (this.items) {
            if (this.resultMode === ModeEnum.grid) {
                this.nbScrolledLines = Math.round(this.top / this.height * this.items.length);
                if (this.nbScrolledLines % this.nbGridColumns !== 0) {
                    this.nbScrolledLines = Math.max(this.nbScrolledLines - this.nbScrolledLines % this.nbGridColumns, 0);
                }
            }
            else {
                this.nbScrolledLines = Math.round(this.top / this.height * this.items.length);
            }
            this.triggerScrollEvent();
        }
    }
    // When scrolling, the position of the scroll bar is calculated
    // Loading the previous/next data is triggered when [nbEndScrollItems] items are left while scrolling up/down respectively
    onScroll(event) {
        this.tbodyHeight = this.el.nativeElement.offsetHeight;
        const scrollTop = this.el.nativeElement.scrollTop;
        const scrollHeight = this.el.nativeElement.scrollHeight;
        const nLastLines = this.nbLinesBeforeFetch / ((this.nbGridColumns - 1) * this.resultMode + 1);
        const dataLength = this.items.length / ((this.nbGridColumns - 1) * this.resultMode + 1);
        const downPositionTrigger = scrollHeight * (1 - nLastLines / dataLength - this.tbodyHeight / scrollHeight);
        const upPositionTrigger = scrollHeight * nLastLines / dataLength;
        if (this.scrolledProgramatically) {
            this.el.nativeElement.scrollTop = scrollHeight * this.nbScrolledLines / this.items.length;
            this.scrolledProgramatically = false;
        }
        this.top = scrollTop;
        this.height = scrollHeight;
        if (this.previousFirstId) {
            if (this.previousFirstId !== this.items[0].identifier || (this.fetchState && this.fetchState.endListDown)) {
                this.previousFirstId = null;
            }
        }
        if (this.previousLastId) {
            if (this.previousLastId !== this.items[this.items.length - 1].identifier || (this.fetchState && this.fetchState.endListUp)) {
                this.previousLastId = null;
            }
        }
        if (scrollTop >= downPositionTrigger && this.isScrollingDown(scrollTop)) {
            /** The following condition answers the question : when should I stop emitting `nextDataEvent` even if i reach the end of the scroll?
             * The answer is: when `nextDataEvent` is emitted and there is no new items loaded.
             * In other words if `downPositionTrigger` is reached and the last identifier we remember
             * from the previous scoll is different from the actual last identifer,
             * it means `nextDataEvent` still can be emitted
            **/
            if (this.items.length > 0 && this.items[this.items.length - 1].identifier !== this.previousLastId && this.fetchState
                && !this.fetchState.endListDown) {
                this.previousLastId = this.items[this.items.length - 1].identifier;
                this.previousFirstId = this.items[0].identifier;
                this.nextDataEvent.next(this.items[this.items.length - 1].itemData);
            }
        }
        if (scrollTop <= upPositionTrigger && this.isScrollingUp(scrollTop)) {
            /** Same logic as the condition above but on the top of the list this time. */
            if (this.items.length > 0 && this.items[0].identifier !== this.previousFirstId && this.fetchState && !this.fetchState.endListUp) {
                this.previousFirstId = this.items[0].identifier;
                this.previousLastId = this.items[this.items.length - 1].identifier;
                this.previousDataEvent.next(this.items[0].itemData);
            }
        }
        this.lastScrollTop = this.el.nativeElement.scrollTop;
        this.visibleItems.next(this.items.filter(i => this.isElementInViewport(document.getElementById(i.identifier))));
    }
    isElementInViewport(el) {
        const rect = el.getBoundingClientRect();
        return (rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth));
    }
    isScrollingDown(scrollTop) {
        if (scrollTop > this.lastScrollTop) {
            return true;
        }
    }
    isScrollingUp(scrollTop) {
        if (scrollTop < this.lastScrollTop) {
            return true;
        }
    }
    triggerScrollEvent() {
        this.scrolledProgramatically = true;
        this.el.nativeElement.scrollTop = 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultScrollDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.13", type: ResultScrollDirective, selector: "[arlasResultScroll]", inputs: { items: "items", nbLinesBeforeFetch: "nbLinesBeforeFetch", nbGridColumns: "nbGridColumns", resultMode: "resultMode", fetchState: "fetchState", scrollOptions: "scrollOptions" }, outputs: { nextDataEvent: "nextDataEvent", previousDataEvent: "previousDataEvent", visibleItems: "visibleItems" }, host: { listeners: { "scroll": "onScroll($event)" } }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: ResultScrollDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[arlasResultScroll]',
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { items: [{
                type: Input
            }], nbLinesBeforeFetch: [{
                type: Input
            }], nbGridColumns: [{
                type: Input
            }], resultMode: [{
                type: Input
            }], fetchState: [{
                type: Input
            }], scrollOptions: [{
                type: Input
            }], nextDataEvent: [{
                type: Output
            }], previousDataEvent: [{
                type: Output
            }], visibleItems: [{
                type: Output
            }], onScroll: [{
                type: HostListener,
                args: ['scroll', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdWx0LXNjcm9sbC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hcmxhcy1jb21wb25lbnRzL3NyYy9saWIvY29tcG9uZW50cy9yZXN1bHRzL3Jlc3VsdC1kaXJlY3RpdmUvcmVzdWx0LXNjcm9sbC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQzdHLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFL0IsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGdDQUFnQyxDQUFDOztBQU8xRCxNQUFNLE9BQU8scUJBQXFCO0lBb0JoQyxZQUEyQixFQUFjO1FBQWQsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQVp4QixrQkFBYSxHQUF1QyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ2xFLHNCQUFpQixHQUF1QyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ3RFLGlCQUFZLEdBQXlCLElBQUksT0FBTyxFQUFlLENBQUM7UUFFekUsa0JBQWEsR0FBRyxDQUFDLENBQUM7UUFDbEIsb0JBQWUsR0FBVyxJQUFJLENBQUM7UUFDL0IsbUJBQWMsR0FBVyxJQUFJLENBQUM7UUFFOUIsNEJBQXVCLEdBQUcsS0FBSyxDQUFDO0lBSUssQ0FBQztJQUV2QyxXQUFXLENBQUMsT0FBc0I7UUFDdkMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNyQixzREFBc0Q7WUFDdEQsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7WUFDNUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7WUFD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QUFVLElBQUksUUFBUSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FDOUUsQ0FBQztJQUNKLENBQUM7SUFFTyxlQUFlLENBQUMsU0FBUztRQUMvQixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDbkMsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO0lBQ0gsQ0FBQztJQUNPLGFBQWEsQ0FBQyxTQUFTO1FBQzdCLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNuQyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRU8sa0JBQWtCO1FBQ3hCLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUM7UUFDcEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDOytHQWpKVSxxQkFBcUI7bUdBQXJCLHFCQUFxQjs7NEZBQXJCLHFCQUFxQjtrQkFKakMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUscUJBQXFCO2lCQUNoQzsrRUFHaUIsS0FBSztzQkFBcEIsS0FBSztnQkFDVSxrQkFBa0I7c0JBQWpDLEtBQUs7Z0JBQ1UsYUFBYTtzQkFBNUIsS0FBSztnQkFDVSxVQUFVO3NCQUF6QixLQUFLO2dCQUNVLFVBQVU7c0JBQXpCLEtBQUs7Z0JBQ1UsYUFBYTtzQkFBNUIsS0FBSztnQkFFVyxhQUFhO3NCQUE3QixNQUFNO2dCQUNVLGlCQUFpQjtzQkFBakMsTUFBTTtnQkFDVSxZQUFZO3NCQUE1QixNQUFNO2dCQTREQSxRQUFRO3NCQURkLFlBQVk7dUJBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIExpY2Vuc2VkIHRvIEdpc2HDr2EgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UudHh0IGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gR2lzYcOvYSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEl0ZW0gfSBmcm9tICcuLi9tb2RlbC9pdGVtJztcbmltcG9ydCB7IE1vZGVFbnVtIH0gZnJvbSAnLi4vdXRpbHMvZW51bWVyYXRpb25zL21vZGVFbnVtJztcbmltcG9ydCB7IEl0ZW1EYXRhVHlwZSB9IGZyb20gJy4uL3V0aWxzL3Jlc3VsdHMudXRpbHMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbYXJsYXNSZXN1bHRTY3JvbGxdJyxcbn0pXG5cbmV4cG9ydCBjbGFzcyBSZXN1bHRTY3JvbGxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBwdWJsaWMgaXRlbXM6IEFycmF5PEl0ZW0+O1xuICBASW5wdXQoKSBwdWJsaWMgbmJMaW5lc0JlZm9yZUZldGNoOiBudW1iZXI7XG4gIEBJbnB1dCgpIHB1YmxpYyBuYkdyaWRDb2x1bW5zOiBudW1iZXI7XG4gIEBJbnB1dCgpIHB1YmxpYyByZXN1bHRNb2RlOiBNb2RlRW51bTtcbiAgQElucHV0KCkgcHVibGljIGZldGNoU3RhdGU6IHsgZW5kTGlzdFVwOiB0cnVlOyBlbmRMaXN0RG93bjogZmFsc2U7IH07XG4gIEBJbnB1dCgpIHB1YmxpYyBzY3JvbGxPcHRpb25zOiB7IG1haW50YWluU2Nyb2xsVXBQb3NpdGlvbjogYm9vbGVhbjsgbWFpbnRhaW5TY3JvbGxEb3duUG9zaXRpb246IGJvb2xlYW47IG5iTGluZXM6IG51bWJlcjsgfTtcblxuICBAT3V0cHV0KCkgcHVibGljIG5leHREYXRhRXZlbnQ6IFN1YmplY3Q8TWFwPHN0cmluZywgSXRlbURhdGFUeXBlPj4gPSBuZXcgU3ViamVjdCgpO1xuICBAT3V0cHV0KCkgcHVibGljIHByZXZpb3VzRGF0YUV2ZW50OiBTdWJqZWN0PE1hcDxzdHJpbmcsIEl0ZW1EYXRhVHlwZT4+ID0gbmV3IFN1YmplY3QoKTtcbiAgQE91dHB1dCgpIHB1YmxpYyB2aXNpYmxlSXRlbXM6IFN1YmplY3Q8QXJyYXk8SXRlbT4+ID0gbmV3IFN1YmplY3Q8QXJyYXk8SXRlbT4+KCk7XG5cbiAgcHJpdmF0ZSBsYXN0U2Nyb2xsVG9wID0gMDtcbiAgcHJpdmF0ZSBwcmV2aW91c0ZpcnN0SWQ6IHN0cmluZyA9IG51bGw7XG4gIHByaXZhdGUgcHJldmlvdXNMYXN0SWQ6IHN0cmluZyA9IG51bGw7XG4gIHByaXZhdGUgdGJvZHlIZWlnaHQ7XG4gIHByaXZhdGUgc2Nyb2xsZWRQcm9ncmFtYXRpY2FsbHkgPSBmYWxzZTtcbiAgcHJpdmF0ZSBuYlNjcm9sbGVkTGluZXM7XG4gIHByaXZhdGUgdG9wO1xuICBwcml2YXRlIGhlaWdodDtcbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYpIHsgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXNbJ2l0ZW1zJ10pIHtcbiAgICAgIC8qKiBOZXcgZGF0YSBpcyBsb2FkZWQgOiB3ZSByZXNldCBhbGwgdGhlIHZhcmlhYmxlcyAqL1xuICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcbiAgICAgIHRoaXMucHJldmlvdXNGaXJzdElkID0gbnVsbDtcbiAgICAgIHRoaXMucHJldmlvdXNMYXN0SWQgPSBudWxsO1xuICAgICAgLyoqIFJlcG9zaXRpb25pbmcgdGhlIHNjcm9sbCBiYXIgdG8gdGhlIHRvcCovXG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICB9XG4gICAgaWYgKGNoYW5nZXNbJ3Jlc3VsdE1vZGUnXSkge1xuICAgICAgdGhpcy5hZGp1c3RTY3JvbGxUb01vZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlc1snc2Nyb2xsT3B0aW9ucyddKSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxPcHRpb25zLm1haW50YWluU2Nyb2xsVXBQb3NpdGlvbiA9PT0gdHJ1ZSAmJiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWludGFpbnMgdGhlIHNjcm9sbCBwb3NpdGlvbiBhZnRlciBsb2FkaW5nIHJvd3MgaW4gdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgKiB0aGlzLnNjcm9sbE9wdGlvbnMubmJMaW5lcyAvIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2Nyb2xsT3B0aW9ucy5tYWludGFpblNjcm9sbERvd25Qb3NpdGlvbiA9PT0gdHJ1ZSAmJiB0aGlzLml0ZW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWludGFpbnMgdGhlIHNjcm9sbCBwb3NpdGlvbiBhZnRlciBsb2FkaW5nIHJvd3MgaW4gdGhlIGJvdHRvbSBvZiB0aGUgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgLVxuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICogdGhpcy5zY3JvbGxPcHRpb25zLm5iTGluZXMgLyB0aGlzLml0ZW1zLmxlbmd0aCAtIHRoaXMudGJvZHlIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGlzIG1ldGhvZCBhbGxvd3MgdG8gc3RheSBhcm91bmQgdGhlIHNhbWUgaXRlbXMgd2hlbiBzd2l0Y2hpbmcgdGhlIG1vZGUgZ3JpZC9saXN0ICovXG4gIHB1YmxpYyBhZGp1c3RTY3JvbGxUb01vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIGlmICh0aGlzLnJlc3VsdE1vZGUgPT09IE1vZGVFbnVtLmdyaWQpIHtcbiAgICAgICAgdGhpcy5uYlNjcm9sbGVkTGluZXMgPSBNYXRoLnJvdW5kKHRoaXMudG9wIC8gdGhpcy5oZWlnaHQgKiB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLm5iU2Nyb2xsZWRMaW5lcyAlIHRoaXMubmJHcmlkQ29sdW1ucyAhPT0gMCkge1xuICAgICAgICAgIHRoaXMubmJTY3JvbGxlZExpbmVzID0gTWF0aC5tYXgodGhpcy5uYlNjcm9sbGVkTGluZXMgLSB0aGlzLm5iU2Nyb2xsZWRMaW5lcyAlIHRoaXMubmJHcmlkQ29sdW1ucywgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmJTY3JvbGxlZExpbmVzID0gTWF0aC5yb3VuZCh0aGlzLnRvcCAvIHRoaXMuaGVpZ2h0ICogdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyU2Nyb2xsRXZlbnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBXaGVuIHNjcm9sbGluZywgdGhlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgYmFyIGlzIGNhbGN1bGF0ZWRcbiAgLy8gTG9hZGluZyB0aGUgcHJldmlvdXMvbmV4dCBkYXRhIGlzIHRyaWdnZXJlZCB3aGVuIFtuYkVuZFNjcm9sbEl0ZW1zXSBpdGVtcyBhcmUgbGVmdCB3aGlsZSBzY3JvbGxpbmcgdXAvZG93biByZXNwZWN0aXZlbHlcbiAgQEhvc3RMaXN0ZW5lcignc2Nyb2xsJywgWyckZXZlbnQnXSlcbiAgcHVibGljIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgdGhpcy50Ym9keUhlaWdodCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuXG4gICAgY29uc3Qgbkxhc3RMaW5lcyA9IHRoaXMubmJMaW5lc0JlZm9yZUZldGNoIC8gKCh0aGlzLm5iR3JpZENvbHVtbnMgLSAxKSAqIHRoaXMucmVzdWx0TW9kZSArIDEpO1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSB0aGlzLml0ZW1zLmxlbmd0aCAvICgodGhpcy5uYkdyaWRDb2x1bW5zIC0gMSkgKiB0aGlzLnJlc3VsdE1vZGUgKyAxKTtcbiAgICBjb25zdCBkb3duUG9zaXRpb25UcmlnZ2VyID0gc2Nyb2xsSGVpZ2h0ICogKDEgLSBuTGFzdExpbmVzIC8gZGF0YUxlbmd0aCAtIHRoaXMudGJvZHlIZWlnaHQgLyBzY3JvbGxIZWlnaHQpO1xuICAgIGNvbnN0IHVwUG9zaXRpb25UcmlnZ2VyID0gc2Nyb2xsSGVpZ2h0ICogbkxhc3RMaW5lcyAvIGRhdGFMZW5ndGg7XG4gICAgaWYgKHRoaXMuc2Nyb2xsZWRQcm9ncmFtYXRpY2FsbHkpIHtcbiAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxIZWlnaHQgKiB0aGlzLm5iU2Nyb2xsZWRMaW5lcyAvIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgdGhpcy5zY3JvbGxlZFByb2dyYW1hdGljYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnRvcCA9IHNjcm9sbFRvcDtcbiAgICB0aGlzLmhlaWdodCA9IHNjcm9sbEhlaWdodDtcbiAgICBpZiAodGhpcy5wcmV2aW91c0ZpcnN0SWQpIHtcbiAgICAgIGlmICh0aGlzLnByZXZpb3VzRmlyc3RJZCAhPT0gdGhpcy5pdGVtc1swXS5pZGVudGlmaWVyIHx8ICh0aGlzLmZldGNoU3RhdGUgJiYgdGhpcy5mZXRjaFN0YXRlLmVuZExpc3REb3duKSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzRmlyc3RJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnByZXZpb3VzTGFzdElkKSB7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c0xhc3RJZCAhPT0gdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdLmlkZW50aWZpZXIgfHwgKHRoaXMuZmV0Y2hTdGF0ZSAmJiB0aGlzLmZldGNoU3RhdGUuZW5kTGlzdFVwKSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzTGFzdElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjcm9sbFRvcCA+PSBkb3duUG9zaXRpb25UcmlnZ2VyICYmIHRoaXMuaXNTY3JvbGxpbmdEb3duKHNjcm9sbFRvcCkpIHtcbiAgICAgIC8qKiBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbiBhbnN3ZXJzIHRoZSBxdWVzdGlvbiA6IHdoZW4gc2hvdWxkIEkgc3RvcCBlbWl0dGluZyBgbmV4dERhdGFFdmVudGAgZXZlbiBpZiBpIHJlYWNoIHRoZSBlbmQgb2YgdGhlIHNjcm9sbD9cbiAgICAgICAqIFRoZSBhbnN3ZXIgaXM6IHdoZW4gYG5leHREYXRhRXZlbnRgIGlzIGVtaXR0ZWQgYW5kIHRoZXJlIGlzIG5vIG5ldyBpdGVtcyBsb2FkZWQuXG4gICAgICAgKiBJbiBvdGhlciB3b3JkcyBpZiBgZG93blBvc2l0aW9uVHJpZ2dlcmAgaXMgcmVhY2hlZCBhbmQgdGhlIGxhc3QgaWRlbnRpZmllciB3ZSByZW1lbWJlclxuICAgICAgICogZnJvbSB0aGUgcHJldmlvdXMgc2NvbGwgaXMgZGlmZmVyZW50IGZyb20gdGhlIGFjdHVhbCBsYXN0IGlkZW50aWZlcixcbiAgICAgICAqIGl0IG1lYW5zIGBuZXh0RGF0YUV2ZW50YCBzdGlsbCBjYW4gYmUgZW1pdHRlZFxuICAgICAgKiovXG4gICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPiAwICYmIHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGggLSAxXS5pZGVudGlmaWVyICE9PSB0aGlzLnByZXZpb3VzTGFzdElkICYmIHRoaXMuZmV0Y2hTdGF0ZVxuICAgICAgICAgJiYgIXRoaXMuZmV0Y2hTdGF0ZS5lbmRMaXN0RG93bikge1xuICAgICAgICB0aGlzLnByZXZpb3VzTGFzdElkID0gdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdLmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMucHJldmlvdXNGaXJzdElkID0gdGhpcy5pdGVtc1swXS5pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLm5leHREYXRhRXZlbnQubmV4dCh0aGlzLml0ZW1zW3RoaXMuaXRlbXMubGVuZ3RoIC0gMV0uaXRlbURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Nyb2xsVG9wIDw9IHVwUG9zaXRpb25UcmlnZ2VyICYmIHRoaXMuaXNTY3JvbGxpbmdVcChzY3JvbGxUb3ApKSB7XG4gICAgICAvKiogU2FtZSBsb2dpYyBhcyB0aGUgY29uZGl0aW9uIGFib3ZlIGJ1dCBvbiB0aGUgdG9wIG9mIHRoZSBsaXN0IHRoaXMgdGltZS4gKi9cbiAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA+IDAgJiYgdGhpcy5pdGVtc1swXS5pZGVudGlmaWVyICE9PSB0aGlzLnByZXZpb3VzRmlyc3RJZCAmJiB0aGlzLmZldGNoU3RhdGUgJiYgIXRoaXMuZmV0Y2hTdGF0ZS5lbmRMaXN0VXApIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0ZpcnN0SWQgPSB0aGlzLml0ZW1zWzBdLmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMucHJldmlvdXNMYXN0SWQgPSB0aGlzLml0ZW1zW3RoaXMuaXRlbXMubGVuZ3RoIC0gMV0uaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5wcmV2aW91c0RhdGFFdmVudC5uZXh0KHRoaXMuaXRlbXNbMF0uaXRlbURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHRoaXMudmlzaWJsZUl0ZW1zLm5leHQodGhpcy5pdGVtcy5maWx0ZXIoaSA9PiB0aGlzLmlzRWxlbWVudEluVmlld3BvcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaS5pZGVudGlmaWVyKSkpKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNFbGVtZW50SW5WaWV3cG9ydChlbCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gKFxuICAgICAgcmVjdC50b3AgPj0gMCAmJlxuICAgICAgICAgIHJlY3QubGVmdCA+PSAwICYmXG4gICAgICAgICAgcmVjdC5ib3R0b20gPD0gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAmJlxuICAgICAgICAgIHJlY3QucmlnaHQgPD0gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1Njcm9sbGluZ0Rvd24oc2Nyb2xsVG9wKSB7XG4gICAgaWYgKHNjcm9sbFRvcCA+IHRoaXMubGFzdFNjcm9sbFRvcCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgaXNTY3JvbGxpbmdVcChzY3JvbGxUb3ApIHtcbiAgICBpZiAoc2Nyb2xsVG9wIDwgdGhpcy5sYXN0U2Nyb2xsVG9wKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJTY3JvbGxFdmVudCgpIHtcbiAgICB0aGlzLnNjcm9sbGVkUHJvZ3JhbWF0aWNhbGx5ID0gdHJ1ZTtcbiAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgfVxufVxuIl19