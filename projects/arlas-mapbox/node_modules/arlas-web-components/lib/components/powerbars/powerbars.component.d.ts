import { AfterViewInit, EventEmitter, OnChanges, OnInit, SimpleChanges } from '@angular/core';
import { SimpleNode, TreeNode } from 'arlas-d3';
import { Subject } from 'rxjs';
import { ArlasColorService } from '../../services/color.generator.service';
import { FilterOperator } from '../../tools/models/term-filters';
import { PowerBar } from './model/powerbar';
import * as i0 from "@angular/core";
/**
 * Powerbars component transforms a [term, occurence_count] map to a descreasingly sorted list of multiselectable bars.
 * A bar progression represents the term's occurence count.
 */
export declare class PowerbarsComponent implements OnInit, OnChanges, AfterViewInit {
    private readonly colorService;
    /**
     * @Input : Angular
     * @description Data formated as a tree to be plotted as powerbars
     */
    inputData: TreeNode;
    /**
     * @Input : Angular
     * @description Which level of the tree inputData to plot as powerbars
     */
    level: number;
    /**
     * @Input : Angular
     * @description Powerbar title
     */
    powerbarTitle: string;
    /**
     * @Input : Angular
     * @description Unit the a powerbar represents
     */
    unit: string;
    /**
     * @Input : Angular
     * @description Css class name to use to customize a specific powerbar's style.
     */
    customizedCssClass: string;
    /**
     * @Input : Angular
     * @description List of selected paths in `inputData` from which the powerbars to select
     * are determined
     */
    selectedPaths: Array<Array<SimpleNode>>;
    /**
     * @Input : Angular
     * @description Whether text input, to filter powerbars, is displayed
     */
    displayFilterField: boolean;
    /**
     * @Input : Angular
     * @description List of [key, color] couples that associates a hex color to each key
     */
    keysToColors: Array<[string, string]>;
    /**
     * @Input : Angular
     * @description Knowing that saturation scale is [0, 1], `colorsSaturationWeight` is a
     * factor (between 0 and 1) that tightens this scale to [(1-colorsSaturationWeight), 1].
     * Therefore saturation of generated colors will be within this tightened scale.
     */
    colorsSaturationWeight: number;
    /**
     * @Input : Angular
     * @description Whether to allow colorizing the bar according to its term or not using keysToColors
     */
    useColorService: boolean;
    /**
     * @Input : Angular
     * @description Whether to allow colorizing the bar according to its term or not using a field of the data
     */
    useColorFromData: boolean;
    /**
     * @Input : Angular
     * @description Chart's width. If not specified, the chart takes the component's container width.
     */
    chartWidth: any;
    /**
       * @Input : Angular
       * @description Whether the powerbar is scrollable or fully displayed
       */
    scrollable: boolean;
    /**
       * @Input : Angular
       * @description Options about how to apply filters on powerbars
       * - value : The default value.
       *           if 'Eq', the selected powerbar is included in the ARLAS filter.
       *           if 'Neq', the selected powerbar is excluded in the ARLAS filter.
       * - display: Whether to display a switcher between 'Eq' and 'Neq' or keep the default operator all the time
       */
    filterOperator: FilterOperator;
    missingLeafEvent: Subject<any[]>;
    /**
     * @Input : Angular
     * @description Precision when rounding numbers (ie the count next to the progress bar).
     * Default is 2.
     */
    numberShorteningPrecision: number;
    /**
     * @Input : Angular
     * @description Whether to group the selected powerbars in a dedicated list or not.
     */
    groupSelections: boolean;
    /**
     * @Input : Angular
     * @description Whether to have the option to select the powerbar using checkboxes.
     */
    selectWithCheckbox: boolean;
    /**
     * @Output : Angular
     * @description Emits the filter operator
     */
    filterOperatorEvent: EventEmitter<'Neq' | 'Eq'>;
    /**
     * @Output : Angular
     * @description Emits the list of selected paths in the tree inputData
     */
    selectedPowerBarEvent: Subject<SimpleNode[][]>;
    /**
     * @Output : Angular
     * @description Emits searched term
     */
    searchedTerm: Subject<string>;
    powerBarsList: Array<PowerBar>;
    selectedPowerbarsSet: Set<PowerBar>;
    selectedPowerbarsTerms: Set<string>;
    /**
     * @constant
     */
    SELECTED_BAR: string;
    /**
     * @constant
     */
    UNSELECTED_BAR: string;
    /**
     * @constant
     */
    NEUTRAL_STATE: string;
    /**
     * @constant
     */
    SELECTED_NO_MOUNTED_BAR: string;
    NUMBER_FORMAT_CHAR: string;
    private readonly _onDestroy$;
    constructor(colorService: ArlasColorService);
    static getPowerbarsJsonSchema(): Object;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    /**
     * @description Select or deselect a PowerBar and emits the terms list of selected bars
     */
    clickOnPowerbar(powerBar: PowerBar): void;
    /**
     * @description Set selected powerbars from outside of the component
     * @param selectedPaths selects the powerbars whose terms are in the selected paths
     */
    setSelectedPowerbars(selectedPaths: Array<Array<{
        fieldName: string;
        fieldValue: string;
    }>>): void;
    onKeyUp(searchText: any): void;
    setOperator(op: 'Eq' | 'Neq'): void;
    private clearSelection;
    private addSelectedPowerbarToList;
    private populatePowerbars;
    private fetchPowerbarsList;
    private populateSelectedPowerbars;
    private calculateAllPowerBarsProgression;
    private unselectAllButNotSelectedBars;
    private sortSelectedPowerBars;
    private removePowerbarFromSelectedOnes;
    /**
     * @description Gets the powerbar by its term and the term of it's parent node
     *
     */
    private getPowerbar;
    private getPowerbarColor;
    static ɵfac: i0.ɵɵFactoryDeclaration<PowerbarsComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<PowerbarsComponent, "arlas-powerbars", never, { "inputData": { "alias": "inputData"; "required": false; }; "level": { "alias": "level"; "required": false; }; "powerbarTitle": { "alias": "powerbarTitle"; "required": false; }; "unit": { "alias": "unit"; "required": false; }; "customizedCssClass": { "alias": "customizedCssClass"; "required": false; }; "selectedPaths": { "alias": "selectedPaths"; "required": false; }; "displayFilterField": { "alias": "displayFilterField"; "required": false; }; "keysToColors": { "alias": "keysToColors"; "required": false; }; "colorsSaturationWeight": { "alias": "colorsSaturationWeight"; "required": false; }; "useColorService": { "alias": "useColorService"; "required": false; }; "useColorFromData": { "alias": "useColorFromData"; "required": false; }; "chartWidth": { "alias": "chartWidth"; "required": false; }; "scrollable": { "alias": "scrollable"; "required": false; }; "filterOperator": { "alias": "filterOperator"; "required": false; }; "missingLeafEvent": { "alias": "missingLeafEvent"; "required": false; }; "numberShorteningPrecision": { "alias": "numberShorteningPrecision"; "required": false; }; "groupSelections": { "alias": "groupSelections"; "required": false; }; "selectWithCheckbox": { "alias": "selectWithCheckbox"; "required": false; }; }, { "filterOperatorEvent": "filterOperatorEvent"; "selectedPowerBarEvent": "selectedPowerBarEvent"; "searchedTerm": "searchedTerm"; }, never, never, false, never>;
}
