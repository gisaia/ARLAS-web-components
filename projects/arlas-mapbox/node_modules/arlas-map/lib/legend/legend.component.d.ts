import { AfterViewInit, OnChanges, OnInit, SimpleChanges, WritableSignal } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { HistogramData } from 'arlas-d3/histograms/utils/HistogramUtils';
import { ArlasColorService } from 'arlas-web-components';
import { Subject } from 'rxjs';
import { ArlasDataLayer } from '../map/model/layers';
import { Legend, LegendData, PROPERTY_SELECTOR_SOURCE } from './legend.config';
import { LegendService } from './legend.service';
import * as i0 from "@angular/core";
export declare class LegendComponent implements OnInit, AfterViewInit, OnChanges {
    translate: TranslateService;
    colorService: ArlasColorService;
    legendService: LegendService;
    /**
     * @Input : Angular
     * @description Layer object
     */
    layer: ArlasDataLayer;
    /**
     * @Input : Angular
     * @description Collection of the layer
     */
    collection: string;
    /**
     * @Input : Angular
     * @description Current zoom level of the map
     */
    zoom: number;
    /**
     * @Input : Angular
     * @description Whether the layer is enabled.
     */
    enabled: boolean;
    /**
     * @Input : Angular
     * @description Subject of [collection, [field, legendData]] map. The map subscribes to it to keep
     * the legend updated with the data displayed on the map.
     */
    legendUpdater: Subject<Map<string, Map<string, LegendData>>>;
    /**
     * @Input : Angular
     * @description Subject of [field, boolean] map. The map subscribes to it to keep
     * the legend updated with the visibility of the layer.
     */
    visibilityUpdater: Subject<Map<string, boolean>>;
    /**
     * @Output : Angular
     * @description Notifies the parent component that this layer is visible or not
     */
    visibilityStatus: Subject<boolean>;
    /**
     * @Output : Angular
     * @description Notifies the parent component that the user wants to download the layer
     */
    downloadSourceEmitter: Subject<{
        layer: any;
        downloadType: string;
    }>;
    lineWidthLegend: any;
    circleRadiusLegend: any;
    lineDasharray: Array<number>;
    colorLegend: WritableSignal<Legend>;
    hasColorLegend: import("@angular/core").Signal<boolean>;
    strokeColorLegend: WritableSignal<Legend>;
    hasStrokeLegend: import("@angular/core").Signal<boolean>;
    widthLegend: WritableSignal<Legend>;
    hasWidthLegend: import("@angular/core").Signal<boolean>;
    radiusLegend: WritableSignal<Legend>;
    hasRadiusLegend: import("@angular/core").Signal<boolean>;
    displayLegendDetailToggle: import("@angular/core").Signal<boolean>;
    detail: boolean;
    visibleMode: boolean;
    PROPERTY_SELECTOR_SOURCE: typeof PROPERTY_SELECTOR_SOURCE;
    private legendData;
    colorPalette: string;
    strokeColorPalette: string;
    private readonly MAX_CIRLE_RADIUS;
    private readonly LEGEND_WIDTH;
    private readonly _onDestroy$;
    constructor(translate: TranslateService, colorService: ArlasColorService, legendService: LegendService);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    downloadLayerSource(layer: any, downloadType: string): void;
    showDetail(event: Event): void;
    /** Parses the `paint` attribute of a layer and draws the legend elements such as
     * - color palette
     * - line width evolution
     * - circle radius evolution
     */
    private drawLegends;
    static ɵfac: i0.ɵɵFactoryDeclaration<LegendComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<LegendComponent, "arlas-legend", never, { "layer": { "alias": "layer"; "required": false; }; "collection": { "alias": "collection"; "required": false; }; "zoom": { "alias": "zoom"; "required": false; }; "enabled": { "alias": "enabled"; "required": false; }; "legendUpdater": { "alias": "legendUpdater"; "required": false; }; "visibilityUpdater": { "alias": "visibilityUpdater"; "required": false; }; }, { "visibilityStatus": "visibilityStatus"; "downloadSourceEmitter": "downloadSourceEmitter"; }, never, never, false, never>;
}
/**
 * draws the line width legend
 * @param svgNode SVG element on which we append the line using d3.
 * @param lineWidths List of {key, linewidth}
 * @param cLegend Color legend, to give the drawn legend lines the same color on the map
 * @param legendWidth The width that the svg will take to draw the legend
 * @param legendHeight The height that the svg will take to draw the legend
 */
export declare function drawLineWidth(svgNode: SVGElement, lineWidths: Array<HistogramData>, cLegend: Legend, legendWidth: number, legendHeight: number): void;
export declare function getMiddleColor(colorLegend: Legend): string;
/**
 * draws the circle radius legend
 * @param svgNode SVG element on which we append the circles using d3.
 * @param circlesRadiuses List of {key, circleradius}
 * @param cLegend Color legend, to give the drawn legend circles the same color on the map
 * @param legendWidth The width that the svg will take to draw the legend
 * @param legendHeight The height that the svg will take to draw the legend
 */
export declare function drawCircleSupportLine(svgNode: SVGElement, circlesRadiuses: Array<HistogramData>, cLegend: Legend, legendWidth: number, legendHeight: number): void;
export declare function getMax(data: Array<HistogramData>): number;
