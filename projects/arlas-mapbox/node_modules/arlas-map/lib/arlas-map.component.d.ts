import { CdkDragDrop } from '@angular/cdk/drag-drop';
import { EventEmitter, SimpleChanges } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { Feature, FeatureCollection } from '@turf/helpers';
import { ElementIdentifier } from 'arlas-web-components';
import { Subject } from 'rxjs';
import { ArlasMapFrameworkService } from './arlas-map-framework.service';
import { AbstractArlasMapService } from './arlas-map.service';
import { BasemapStyle } from './basemaps/basemap.config';
import { BasemapService } from './basemaps/basemap.service';
import { ArlasDrawComponent } from './draw/arlas-draw.component';
import { AoiDimensions } from './draw/draw.models';
import { MapboxAoiDrawService } from './draw/draw.service';
import { LegendData } from './legend/legend.config';
import { AbstractArlasMapGL, ArlasMapOffset } from './map/AbstractArlasMapGL';
import { ControlPosition, IconConfig } from './map/model/controls';
import { MapLayerMouseEvent, MapMouseEvent } from './map/model/events';
import { MapExtent } from './map/model/extent';
import { ArlasDataLayer, MapLayers } from './map/model/layers';
import { ArlasLngLatBounds, OnMoveResult } from './map/model/map';
import { ArlasMapSource } from './map/model/sources';
import { VisualisationSetConfig } from './map/model/visualisationsets';
import * as i0 from "@angular/core";
export declare class ArlasMapComponent<L, S, M> {
    private readonly drawService;
    private readonly basemapService;
    private readonly translate;
    protected mapFrameworkService: ArlasMapFrameworkService<L, S, M>;
    protected mapService: AbstractArlasMapService<L, S, M>;
    /** Map instance. */
    map: AbstractArlasMapGL;
    /** Whether the legend is visible (open) or not.*/
    legendOpen: boolean;
    /** Used to clear geojson sources. */
    emptyData: FeatureCollection<GeoJSON.Geometry>;
    /** Whether the list of basemaps is shown. */
    showBasemapList: boolean;
    /** Visibility status of each visualisation set*. */
    visibilityStatus: Map<string, boolean>;
    private readonly _onDestroy$;
    drawComponent: ArlasDrawComponent<ArlasDataLayer, S, M>;
    /** ANGULAR INPUTS */
    /** @description Html identifier given to the map container (it's a div ;))*/
    id: string;
    /** @description An object with north,east,south,west properies which represent an offset in pixels */
    /** Origin is top-left and x-axis is west to east and y-axis north to south.*/
    offset: ArlasMapOffset;
    /** --- LAYERS */
    /** @description List of configured (by the builder) layers. */
    mapLayers: MapLayers<ArlasDataLayer>;
    /** --- SCALE & COORDINATES */
    /** @description Whether the map scale is displayed. */
    displayScale: boolean;
    /** @description Maximim width in pixels that the map scale could take. */
    maxWidthScale: number;
    /** @description Unit display for the map scale. */
    unitScale: string;
    /** @description Whether to display the coordinates of the mouse while moving. */
    displayCurrentCoordinates: boolean;
    /** @description If true, the coordinates values are wrapped between -180 and 180. */
    wrapLatLng: boolean;
    /** --- BASEMAPS */
    /** @description Default basemap to display. */
    defaultBasemapStyle: BasemapStyle;
    /** @description List of available basemaps. */
    basemapStyles: BasemapStyle[];
    /** --- INITIAL MAP VIEW : ZOOMs, CENTER, BOUNDS */
    /** @description Zoom of the map when it's initialized. */
    initZoom: number;
    /** @description Max zoom of the map. */
    maxZoom: number;
    /** @description Min zoom of the map. */
    minZoom: number;
    /** @description Coordinates of the map's center when it's first loaded. */
    initCenter: [number, number];
    /** --- BOUNDS TO FIT STRATEGY */
    /** @description Bounds that the view map fits. It's an array of two corners. */
    /** Each corner is an lat-long position. For example: boundsToFit = [[30.51, -54.3],[30.57, -54.2]] */
    boundsToFit: Array<Array<number>>;
    /** @description The padding added in the top-left and bottom-right corners of a map container that shouldn't be accounted */
    /** for when setting the view to fit bounds.*/
    fitBoundsOffSet: [number, number];
    /**  @description Padding value applied around a fitBounds to fully show the area targeted. */
    fitBoundsPadding: number;
    /** @description The maximum zoom level so that the bounds fit the map view. */
    fitBoundsMaxZoom: number;
    /** --- DATA LOADING STRATEGIES */
    /** @description Margin applied to the map extent. Data will be fetched in all this extent. */
    margePanForLoad: number;
    /** @description Margin applied to the map extent. Before loading data,
     * the components checks first if there are features already loaded in this extent. */
    margePanForTest: number;
    /** @description A callback run before the Map makes a request for an external URL/ */
    transformRequest: unknown /** TransformRequestFunction or RequestTransformRequest */;
    /** --- MAP INTERACTION */
    /** @description Feature to highlight. */
    featureToHightLight: {
        isleaving: boolean;
        elementidentifier: ElementIdentifier;
    };
    /** @description List of features to select. */
    featuresToSelect: Array<ElementIdentifier>;
    /** --- SOURCES */
    /** @description List of sources to add to the map. */
    mapSources: Array<ArlasMapSource<S>>;
    /** @description Subject to which the component subscribes to redraw on the map the `data` of the given `source`. */
    redrawSource: Subject<{
        source: string;
        data: Feature<GeoJSON.Geometry>[];
    }>;
    /** @description List of data sources names that should be added to the map. Sources should be of type `geojson`. */
    dataSources: Set<string>;
    /** --- DRAW */
    /**  @description Options object for draw tools : https://github.com/mapbox/mapbox-gl-draw/blob/master/docs/API.md#options */
    drawOption: any;
    /** @description Features drawn at component start */
    drawData: FeatureCollection<GeoJSON.Geometry>;
    /** @description Whether the draw tools are activated. */
    drawButtonEnabled: boolean;
    /** @description Maximum number of vertices allowed for a polygon. */
    drawPolygonVerticesLimit: number;
    /** @description Whether the drawing buffer is activated */
    /** If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL(). Default: false */
    preserveDrawingBuffer: boolean;
    /** --- ATTRIBUTION */
    /** @description Position of the map attribution. */
    mapAttributionPosition: ControlPosition;
    /** --- MAP ICONS */
    /** @description List of icons to add to the map and that can be used in layers. */
    icons: Array<IconConfig>;
    /** --- LEGEND AND VISUALISATIONS */
    /** @description Subject of [collection, [field, legendData]] map. The map subscribes to it to keep */
    /** the legend updated with the data displayed on the map. */
    legendUpdater: Subject<Map<string, Map<string, LegendData>>>;
    /** @description Subject of [layerId, boolean] map. The map subscribes to it to keep */
    /** the legend updated with the visibility of the layer.*/
    visibilityUpdater: Subject<Map<string, boolean>>;
    /** @description List of visualisation sets. A Visualisation set is an entity where layers are grouped together. */
    /** If a visualisation set is enabled, all the layers in it can be displayed on the map, otherwise the layers are removed from the map. */
    visualisationSetsConfig: Array<VisualisationSetConfig>;
    /** ANGULAR OUTPUTS */
    /** @description Emits true after the map is loaded and all sources & layers are added. */
    onMapLoaded: Subject<boolean>;
    /** @description Emits the map extent when the browser tab is closed/refreshed. */
    onMapClosed: EventEmitter<MapExtent>;
    /**
     * @deprecated
     * @description  Emits the event of moving the map. */
    onMove: EventEmitter<OnMoveResult>;
    /** @description Emits the visible visualisation sets' names */
    visualisations: EventEmitter<Set<string>>;
    /** @description Emits the features that were clicked on. */
    onFeatureClick: EventEmitter<{
        features: Array<GeoJSON.Feature<GeoJSON.Geometry>>;
        point: [number, number];
    }>;
    /** @description Emits the features that were hovered. */
    onFeatureHover: EventEmitter<{} | {
        features: Array<GeoJSON.Feature<GeoJSON.Geometry>>;
        point: [number, number];
    }>;
    /** @description Emits the geojson of all aois added to the map. */
    onAoiChanged: EventEmitter<FeatureCollection<GeoJSON.Geometry>>;
    /** @description Emits the the dimensions of the polygon/bbox that is being drawn. */
    onAoiEdit: EventEmitter<AoiDimensions>;
    /** @description Emits an event when the basemap has been changed by the user. */
    onBasemapChanged: Subject<boolean>;
    /** @description Emits which layers are displayed on the map. */
    legendVisibiltyStatus: Subject<Map<string, boolean>>;
    /** @description  Notifies that the user wants to download the selected layer */
    downloadSourceEmitter: Subject<{
        layerId: string;
        layerName: string;
        collection: string;
        sourceName: string;
        downloadType: string;
    }>;
    protected ICONS_BASE_PATH: string;
    constructor(drawService: MapboxAoiDrawService, basemapService: BasemapService<L, S, M>, translate: TranslateService, mapFrameworkService: ArlasMapFrameworkService<L, S, M>, mapService: AbstractArlasMapService<L, S, M>);
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    /** If transformRequest' @Input was not set, set a default value : a function that maintains the same url */
    initTransformRequest(): void;
    /** Zooms on clicked feature from map mouse event e.
     * @param mouseEvent Map mouse event provided by the map instance.
     */
    zoomOnClick(mouseEvent: MapMouseEvent): void;
    /**
     * Queries all rendered features on the position that was clicked on, on a layer; and emits those features.
     * @param mapLayerMouseEvent Map mouse event provided by a layer instance.
     */
    protected queryRender(mapLayerMouseEvent: MapLayerMouseEvent): void;
    /** @description Adds the custom icons given in the component's input */
    addIcons(): void;
    /**
     * @description Creates the map instance and adds the basemap, arlas data
     * and starts listening to arlas data changes and layers visibility updates.
     * It also starts emiting map moveend event.
     */
    declareMap(): void;
    /**
     * @description Listens to events on mapLayers input (configured layers).
     */
    listenToLayersEvents(): void;
    /** Sets the layers order according to the current order of `visualisationSetsConfig` list*/
    reorderLayers(): void;
    /** @description Display the basemapswitcher */
    showBasemapSwitcher(): void;
    /** @description Emits event notifiying that the basemap has been changed */
    onChangeBasemapStyle(): void;
    /**
     * Updates the visibility status of the layer and emits that update.
     * @param visualisation visualisation set name
     * @param l layer id
     * @param visible whether the layer is enabled and visible in the visualisation set
     */
    emitLegendVisibility(visualisation: string, l: string, visible: boolean): void;
    /**
     * @description Emits the visible visualisation set
     * @param visualisationName Name of the visualisation.
     */
    emitVisualisations(visualisationName: string): void;
    downloadLayerSource(downaload: {
        layer: any;
        downloadType: string;
    }): void;
    /** puts the visualisation set list in the new order after dropping */
    drop(event: CdkDragDrop<string[]>): void;
    /** puts the layers list in the new order after dropping */
    dropLayer(event: CdkDragDrop<string[]>, visuName: string): void;
    hideBasemapSwitcher(): void;
    /**
     * Fit to given bounds. Options are for padding.
     * @param bounds Bounds of the map to fit to.
     */
    fitToPaddedBounds(bounds: ArlasLngLatBounds): void;
    /**
     * Centers the map to the given latitude/longitude coordinates.
     * @param lngLat Latitude/longitude coordinates.
     */
    moveToCoordinates(lngLat: [number, number]): void;
    /** Highlights, in all data sources,the feature(s) having the given elementIdentifier */
    private highlightFeature;
    /** Selects, in all data sources,the feature(s) having the given elementIdentifier */
    private selectFeatures;
    /** Selects, in all data sources, all the features having the given elementIdentifiers and under the given collection.
     * @param features list of features identifiers.
     * @param collection data collection (metadata of the data source).
    */
    selectFeaturesByCollection(features: Array<ElementIdentifier>, collection: string): void;
    static getMapJsonSchema(): Object;
    /** Destroys all the components subscriptions. */
    ngOnDestroy(): void;
    /** @description Enables bbox drawing mode.*/
    addGeoBox(): void;
    /**
     * @description Removes all the aois if none of them is selected. Otherwise it removes the selected one only
     */
    removeAois(): void;
    /** @description Deletes the selected drawn geometry. If no drawn geometry is selected, all geometries are deteleted */
    deleteSelectedItem(): void;
    /**
     * @description Switches to a drawing mode of a DRAW_POLYGON, DRAW_CIRCLE or DRAW_RADIUS_CIRCLE.
     * @param mode Draw mode (DRAW_POLYGON, DRAW_CIRCLE or DRAW_RADIUS_CIRCLE). Default to DRAW_POLYGON
     * @param option Mapboxdraw option.
     */
    switchToDrawMode(mode?: string, option?: any): void;
    /**
     * @description Switches to direct_select mode.
     * @param option Mapboxdraw option.
     */
    switchToDirectSelectMode(option?: {
        featureIds: Array<string>;
        allowCircleResize: boolean;
    } | {
        featureId: string;
        allowCircleResize: boolean;
    }): void;
    /**
     * @description Switches to simple_select mode.
     * @param option Mapboxdraw option.
     */
    switchToEditMode(): void;
    /**
     * @description Returns all the drawn polygons as wkt or geojson.
     * @param mode 'wkt' | 'geojson'
     * @returns Wkt string or Geojson object.
     */
    getAllPolygon(mode: 'wkt' | 'geojson'): string | Object;
    /**
     * @description returns the selected polygon geometry in WKT or GeoJson given the mode
     * @param mode : 'wkt' | 'geojson'
     * @returns Wkt string or Geojson object.
     */
    getSelectedPolygon(mode: 'wkt' | 'geojson'): string | Object;
    static ɵfac: i0.ɵɵFactoryDeclaration<ArlasMapComponent<any, any, any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ArlasMapComponent<any, any, any>, "arlas-map", never, { "id": { "alias": "id"; "required": false; }; "offset": { "alias": "offset"; "required": false; }; "mapLayers": { "alias": "mapLayers"; "required": false; }; "displayScale": { "alias": "displayScale"; "required": false; }; "maxWidthScale": { "alias": "maxWidthScale"; "required": false; }; "unitScale": { "alias": "unitScale"; "required": false; }; "displayCurrentCoordinates": { "alias": "displayCurrentCoordinates"; "required": false; }; "wrapLatLng": { "alias": "wrapLatLng"; "required": false; }; "defaultBasemapStyle": { "alias": "defaultBasemapStyle"; "required": false; }; "basemapStyles": { "alias": "basemapStyles"; "required": false; }; "initZoom": { "alias": "initZoom"; "required": false; }; "maxZoom": { "alias": "maxZoom"; "required": false; }; "minZoom": { "alias": "minZoom"; "required": false; }; "initCenter": { "alias": "initCenter"; "required": false; }; "boundsToFit": { "alias": "boundsToFit"; "required": false; }; "fitBoundsOffSet": { "alias": "fitBoundsOffSet"; "required": false; }; "fitBoundsPadding": { "alias": "fitBoundsPadding"; "required": false; }; "fitBoundsMaxZoom": { "alias": "fitBoundsMaxZoom"; "required": false; }; "margePanForLoad": { "alias": "margePanForLoad"; "required": false; }; "margePanForTest": { "alias": "margePanForTest"; "required": false; }; "transformRequest": { "alias": "transformRequest"; "required": false; }; "featureToHightLight": { "alias": "featureToHightLight"; "required": false; }; "featuresToSelect": { "alias": "featuresToSelect"; "required": false; }; "mapSources": { "alias": "mapSources"; "required": false; }; "redrawSource": { "alias": "redrawSource"; "required": false; }; "dataSources": { "alias": "dataSources"; "required": false; }; "drawOption": { "alias": "drawOption"; "required": false; }; "drawData": { "alias": "drawData"; "required": false; }; "drawButtonEnabled": { "alias": "drawButtonEnabled"; "required": false; }; "drawPolygonVerticesLimit": { "alias": "drawPolygonVerticesLimit"; "required": false; }; "preserveDrawingBuffer": { "alias": "preserveDrawingBuffer"; "required": false; }; "mapAttributionPosition": { "alias": "mapAttributionPosition"; "required": false; }; "icons": { "alias": "icons"; "required": false; }; "legendUpdater": { "alias": "legendUpdater"; "required": false; }; "visibilityUpdater": { "alias": "visibilityUpdater"; "required": false; }; "visualisationSetsConfig": { "alias": "visualisationSetsConfig"; "required": false; }; }, { "onMapLoaded": "onMapLoaded"; "onMapClosed": "onMapClosed"; "onMove": "onMove"; "visualisations": "visualisations"; "onFeatureClick": "onFeatureClick"; "onFeatureHover": "onFeatureHover"; "onAoiChanged": "onAoiChanged"; "onAoiEdit": "onAoiEdit"; "onBasemapChanged": "onBasemapChanged"; "legendVisibiltyStatus": "legendVisibiltyStatus"; "downloadSourceEmitter": "downloadSourceEmitter"; }, never, never, false, never>;
}
