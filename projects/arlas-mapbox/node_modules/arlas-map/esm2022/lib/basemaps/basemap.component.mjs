/*
 * Licensed to Gisaïa under one or more contributor
 * license agreements. See the NOTICE.txt file distributed with
 * this work for additional information regarding copyright
 * ownership. Gisaïa licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { Subject } from 'rxjs/internal/Subject';
import { AbstractArlasMapGL } from '../map/AbstractArlasMapGL';
import { BasemapService } from './basemap.service';
import { ArlasMapFrameworkService } from '../arlas-map-framework.service';
import { AbstractArlasMapService } from '../arlas-map.service';
import { takeUntil } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "./basemap.service";
import * as i2 from "../arlas-map.service";
import * as i3 from "../arlas-map-framework.service";
import * as i4 from "@angular/common";
import * as i5 from "@angular/material/icon";
import * as i6 from "@ngx-translate/core";
/** L: a layer class/interface.
 *  S: a source class/interface.
 *  M: a Map configuration class/interface.
 */
export class BasemapComponent {
    constructor(basemapService, mapService, mapFrameworkService) {
        this.basemapService = basemapService;
        this.mapService = mapService;
        this.mapFrameworkService = mapFrameworkService;
        this._onDestroy$ = new Subject();
        this.basemapChanged = new EventEmitter();
        this.blur = new Subject();
        this.showList = false;
        this.basemapService.basemapChanged$.pipe(takeUntil(this._onDestroy$)).subscribe(() => this.basemapChanged.emit());
    }
    ngOnInit() {
        this.initBasemaps();
    }
    initBasemaps() {
        this.basemaps = this.basemapService.basemaps;
        if (this.basemaps) {
            const styles = this.basemaps.styles();
            if (styles) {
                this.showList = styles.length > 0;
                styles.filter(bm => !bm.image).forEach(bm => {
                    if (bm.type !== 'protomap' && !!bm.url) {
                        const splitUrl = bm.url.split('/style.json?key=');
                        if (splitUrl.length === 2) {
                            bm.image = `${splitUrl[0]}/0/0/0.png?key=${splitUrl[1]}`;
                        }
                    }
                });
            }
        }
    }
    /** Removes the old basemap and set the new one that is given as a parameter
     * @param newBasemap: Basemap selected by the user
     */
    onChangeBasemap(newBasemap) {
        const selectedBasemap = this.basemaps.getSelected();
        if (selectedBasemap.type === 'protomap') {
            this.basemapService.removeProtomapBasemap(this.map);
        }
        this.setBaseMapStyle(newBasemap);
    }
    setBaseMapStyle(newBasemap) {
        if (this.map) {
            this.basemapService.setBasemap(this.basemaps.getSelected().styleFile, newBasemap, this.map, this.mapSources);
        }
    }
    ngOnDestroy() {
        this._onDestroy$.next(true);
        this._onDestroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapComponent, deps: [{ token: i1.BasemapService }, { token: i2.AbstractArlasMapService }, { token: i3.ArlasMapFrameworkService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.13", type: BasemapComponent, selector: "arlas-basemap", inputs: { map: "map", mapSources: "mapSources" }, outputs: { basemapChanged: "basemapChanged", blur: "blur" }, ngImport: i0, template: "<div *ngIf=\"showList\" class=\"basemap-container\">\n  <ng-container *ngFor=\"let style of basemaps?._styles\">\n    <div *ngIf=\"!style.errored\" class=\"basemap\" [class.selected]=\"style.name === basemaps?._selectedStyle?.name\"\n    (click)=\"onChangeBasemap(style)\" (keyDown)=\"onChangeBasemap(style)\">\n      <div class=\"image\">\n        <img *ngIf=\"!!style?.image && style?.image !== ''\" src=\"{{style?.image}}\" (error)=\"style.image = null\" />\n        <div *ngIf=\"!style?.image || (!!style?.image && style?.image === '')\" class=\"no-image\">\n          <mat-icon>wallpaper</mat-icon>\n        </div>\n        <div class=\"name\">{{style.name | translate}}</div>\n      </div>\n    </div>\n  </ng-container>\n</div>\n", styles: ["@charset \"UTF-8\";.basemap-container{border-radius:6px;position:absolute;top:10px;right:45px;display:flex;flex-flow:row wrap;max-width:243px;gap:3px;overflow:hidden}.basemap-container .basemap{border:2px solid white;background-color:#fff;border-radius:6px;cursor:pointer}.basemap-container .basemap .image{height:75px;width:75px;position:relative}.basemap-container .basemap .image .name{font-size:10px;line-height:15px;text-align:center;position:absolute;width:100%;bottom:0;background-color:#f5f5f580;border-radius:0 0 6px 6px;text-shadow:1px 1px 2px white;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.basemap-container .basemap .image img{width:75px;border-radius:6px;image-rendering:auto}.basemap-container .basemap .image .no-image{width:75px;height:75px;background-color:#fff;text-align:center;padding-top:20px}.basemap-container .selected{border:2px solid #337ab7;background-color:#337ab7;color:#337ab7;font-weight:600}\n"], dependencies: [{ kind: "directive", type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i5.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "pipe", type: i6.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BasemapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'arlas-basemap', template: "<div *ngIf=\"showList\" class=\"basemap-container\">\n  <ng-container *ngFor=\"let style of basemaps?._styles\">\n    <div *ngIf=\"!style.errored\" class=\"basemap\" [class.selected]=\"style.name === basemaps?._selectedStyle?.name\"\n    (click)=\"onChangeBasemap(style)\" (keyDown)=\"onChangeBasemap(style)\">\n      <div class=\"image\">\n        <img *ngIf=\"!!style?.image && style?.image !== ''\" src=\"{{style?.image}}\" (error)=\"style.image = null\" />\n        <div *ngIf=\"!style?.image || (!!style?.image && style?.image === '')\" class=\"no-image\">\n          <mat-icon>wallpaper</mat-icon>\n        </div>\n        <div class=\"name\">{{style.name | translate}}</div>\n      </div>\n    </div>\n  </ng-container>\n</div>\n", styles: ["@charset \"UTF-8\";.basemap-container{border-radius:6px;position:absolute;top:10px;right:45px;display:flex;flex-flow:row wrap;max-width:243px;gap:3px;overflow:hidden}.basemap-container .basemap{border:2px solid white;background-color:#fff;border-radius:6px;cursor:pointer}.basemap-container .basemap .image{height:75px;width:75px;position:relative}.basemap-container .basemap .image .name{font-size:10px;line-height:15px;text-align:center;position:absolute;width:100%;bottom:0;background-color:#f5f5f580;border-radius:0 0 6px 6px;text-shadow:1px 1px 2px white;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.basemap-container .basemap .image img{width:75px;border-radius:6px;image-rendering:auto}.basemap-container .basemap .image .no-image{width:75px;height:75px;background-color:#fff;text-align:center;padding-top:20px}.basemap-container .selected{border:2px solid #337ab7;background-color:#337ab7;color:#337ab7;font-weight:600}\n"] }]
        }], ctorParameters: () => [{ type: i1.BasemapService }, { type: i2.AbstractArlasMapService }, { type: i3.ArlasMapFrameworkService }], propDecorators: { map: [{
                type: Input
            }], mapSources: [{
                type: Input
            }], basemapChanged: [{
                type: Output
            }], blur: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZW1hcC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hcmxhcy1tYXAvc3JjL2xpYi9iYXNlbWFwcy9iYXNlbWFwLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FybGFzLW1hcC9zcmMvbGliL2Jhc2VtYXBzL2Jhc2VtYXAuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFxQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ2hELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRy9ELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVuRCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUMxRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7Ozs7OztBQU9qQzs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sZ0JBQWdCO0lBYTNCLFlBQTZCLGNBQXVDLEVBQ3hELFVBQTRDLEVBQzVDLG1CQUFzRDtRQUZyQyxtQkFBYyxHQUFkLGNBQWMsQ0FBeUI7UUFDeEQsZUFBVSxHQUFWLFVBQVUsQ0FBa0M7UUFDNUMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFtQztRQWJqRCxnQkFBVyxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFLckMsbUJBQWMsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBQzFDLFNBQUksR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO1FBRXJDLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFPcEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBRW5ILENBQUM7SUFFRyxRQUFRO1FBQ2IsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFUyxZQUFZO1FBQ3BCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUM7UUFDN0MsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDbEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN0QyxJQUFJLE1BQU0sRUFBRSxDQUFDO2dCQUNYLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7Z0JBQ2xDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUU7b0JBQzFDLElBQUksRUFBRSxDQUFDLElBQUksS0FBSyxVQUFVLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQzt3QkFDdkMsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQzt3QkFDbEQsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDOzRCQUMxQixFQUFFLENBQUMsS0FBSyxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7d0JBQzNELENBQUM7b0JBQ0gsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZSxDQUFDLFVBQXdCO1FBQzdDLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDcEQsSUFBSSxlQUFlLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRSxDQUFDO1lBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RELENBQUM7UUFDRCxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFTSxlQUFlLENBQUMsVUFBd0I7UUFDN0MsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLFNBQWdCLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3RILENBQUM7SUFDSCxDQUFDO0lBRU0sV0FBVztRQUNoQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzlCLENBQUM7K0dBL0RVLGdCQUFnQjttR0FBaEIsZ0JBQWdCLG9LQ3ZDN0Isa3VCQWNBOzs0RkR5QmEsZ0JBQWdCO2tCQVQ1QixTQUFTOytCQUNFLGVBQWU7Z0tBWVQsR0FBRztzQkFBbEIsS0FBSztnQkFDVSxVQUFVO3NCQUF6QixLQUFLO2dCQUVXLGNBQWM7c0JBQTlCLE1BQU07Z0JBQ1UsSUFBSTtzQkFBcEIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBMaWNlbnNlZCB0byBHaXNhw69hIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFLnR4dCBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEdpc2HDr2EgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL2ludGVybmFsL1N1YmplY3QnO1xuaW1wb3J0IHsgQWJzdHJhY3RBcmxhc01hcEdMIH0gZnJvbSAnLi4vbWFwL0Fic3RyYWN0QXJsYXNNYXBHTCc7XG5pbXBvcnQgeyBBcmxhc01hcFNvdXJjZSB9IGZyb20gJy4uL21hcC9tb2RlbC9zb3VyY2VzJztcbmltcG9ydCB7IEFybGFzQmFzZW1hcHMgfSBmcm9tICcuL2Jhc2VtYXBzLm1vZGVsJztcbmltcG9ydCB7IEJhc2VtYXBTZXJ2aWNlIH0gZnJvbSAnLi9iYXNlbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmFzZW1hcFN0eWxlIH0gZnJvbSAnLi9iYXNlbWFwLmNvbmZpZyc7XG5pbXBvcnQgeyBBcmxhc01hcEZyYW1ld29ya1NlcnZpY2UgfSBmcm9tICcuLi9hcmxhcy1tYXAtZnJhbWV3b3JrLnNlcnZpY2UnO1xuaW1wb3J0IHsgQWJzdHJhY3RBcmxhc01hcFNlcnZpY2UgfSBmcm9tICcuLi9hcmxhcy1tYXAuc2VydmljZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYXJsYXMtYmFzZW1hcCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9iYXNlbWFwLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vYmFzZW1hcC5jb21wb25lbnQuc2NzcyddXG59KVxuLyoqIEw6IGEgbGF5ZXIgY2xhc3MvaW50ZXJmYWNlLlxuICogIFM6IGEgc291cmNlIGNsYXNzL2ludGVyZmFjZS5cbiAqICBNOiBhIE1hcCBjb25maWd1cmF0aW9uIGNsYXNzL2ludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VtYXBDb21wb25lbnQ8TCwgUywgTT5pbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9vbkRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBASW5wdXQoKSBwdWJsaWMgbWFwOiBBYnN0cmFjdEFybGFzTWFwR0w7XG4gIEBJbnB1dCgpIHB1YmxpYyBtYXBTb3VyY2VzOiBBcnJheTxBcmxhc01hcFNvdXJjZTxhbnk+PjtcblxuICBAT3V0cHV0KCkgcHVibGljIGJhc2VtYXBDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICBAT3V0cHV0KCkgcHVibGljIGJsdXIgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIHB1YmxpYyBzaG93TGlzdCA9IGZhbHNlO1xuICBwdWJsaWMgYmFzZW1hcHM6IEFybGFzQmFzZW1hcHM7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBiYXNlbWFwU2VydmljZTogQmFzZW1hcFNlcnZpY2U8TCwgUywgTT4sXG4gICAgcHJvdGVjdGVkIG1hcFNlcnZpY2U6IEFic3RyYWN0QXJsYXNNYXBTZXJ2aWNlPEwsIFMsIE0+LFxuICAgIHByb3RlY3RlZCBtYXBGcmFtZXdvcmtTZXJ2aWNlOiBBcmxhc01hcEZyYW1ld29ya1NlcnZpY2U8TCwgUywgTT4pIHtcblxuICAgICAgdGhpcy5iYXNlbWFwU2VydmljZS5iYXNlbWFwQ2hhbmdlZCQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmJhc2VtYXBDaGFuZ2VkLmVtaXQoKSk7XG5cbiAgICAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmluaXRCYXNlbWFwcygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGluaXRCYXNlbWFwcygpIHtcbiAgICB0aGlzLmJhc2VtYXBzID0gdGhpcy5iYXNlbWFwU2VydmljZS5iYXNlbWFwcztcbiAgICBpZiAodGhpcy5iYXNlbWFwcykge1xuICAgICAgY29uc3Qgc3R5bGVzID0gdGhpcy5iYXNlbWFwcy5zdHlsZXMoKTtcbiAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5zaG93TGlzdCA9IHN0eWxlcy5sZW5ndGggPiAwO1xuICAgICAgICBzdHlsZXMuZmlsdGVyKGJtID0+ICFibS5pbWFnZSkuZm9yRWFjaChibSA9PiB7XG4gICAgICAgICAgaWYgKGJtLnR5cGUgIT09ICdwcm90b21hcCcgJiYgISFibS51cmwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0VXJsID0gYm0udXJsLnNwbGl0KCcvc3R5bGUuanNvbj9rZXk9Jyk7XG4gICAgICAgICAgICBpZiAoc3BsaXRVcmwubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIGJtLmltYWdlID0gYCR7c3BsaXRVcmxbMF19LzAvMC8wLnBuZz9rZXk9JHtzcGxpdFVybFsxXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIFJlbW92ZXMgdGhlIG9sZCBiYXNlbWFwIGFuZCBzZXQgdGhlIG5ldyBvbmUgdGhhdCBpcyBnaXZlbiBhcyBhIHBhcmFtZXRlclxuICAgKiBAcGFyYW0gbmV3QmFzZW1hcDogQmFzZW1hcCBzZWxlY3RlZCBieSB0aGUgdXNlclxuICAgKi9cbiAgcHVibGljIG9uQ2hhbmdlQmFzZW1hcChuZXdCYXNlbWFwOiBCYXNlbWFwU3R5bGUpIHtcbiAgICBjb25zdCBzZWxlY3RlZEJhc2VtYXAgPSB0aGlzLmJhc2VtYXBzLmdldFNlbGVjdGVkKCk7XG4gICAgaWYgKHNlbGVjdGVkQmFzZW1hcC50eXBlID09PSAncHJvdG9tYXAnKSB7XG4gICAgICB0aGlzLmJhc2VtYXBTZXJ2aWNlLnJlbW92ZVByb3RvbWFwQmFzZW1hcCh0aGlzLm1hcCk7XG4gICAgfVxuICAgIHRoaXMuc2V0QmFzZU1hcFN0eWxlKG5ld0Jhc2VtYXApO1xuICB9XG5cbiAgcHVibGljIHNldEJhc2VNYXBTdHlsZShuZXdCYXNlbWFwOiBCYXNlbWFwU3R5bGUpIHtcbiAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgIHRoaXMuYmFzZW1hcFNlcnZpY2Uuc2V0QmFzZW1hcCh0aGlzLmJhc2VtYXBzLmdldFNlbGVjdGVkKCkuc3R5bGVGaWxlIGFzIGFueSwgbmV3QmFzZW1hcCwgdGhpcy5tYXAsIHRoaXMubWFwU291cmNlcyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX29uRGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gIH1cblxufVxuIiwiPGRpdiAqbmdJZj1cInNob3dMaXN0XCIgY2xhc3M9XCJiYXNlbWFwLWNvbnRhaW5lclwiPlxuICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBzdHlsZSBvZiBiYXNlbWFwcz8uX3N0eWxlc1wiPlxuICAgIDxkaXYgKm5nSWY9XCIhc3R5bGUuZXJyb3JlZFwiIGNsYXNzPVwiYmFzZW1hcFwiIFtjbGFzcy5zZWxlY3RlZF09XCJzdHlsZS5uYW1lID09PSBiYXNlbWFwcz8uX3NlbGVjdGVkU3R5bGU/Lm5hbWVcIlxuICAgIChjbGljayk9XCJvbkNoYW5nZUJhc2VtYXAoc3R5bGUpXCIgKGtleURvd24pPVwib25DaGFuZ2VCYXNlbWFwKHN0eWxlKVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImltYWdlXCI+XG4gICAgICAgIDxpbWcgKm5nSWY9XCIhIXN0eWxlPy5pbWFnZSAmJiBzdHlsZT8uaW1hZ2UgIT09ICcnXCIgc3JjPVwie3tzdHlsZT8uaW1hZ2V9fVwiIChlcnJvcik9XCJzdHlsZS5pbWFnZSA9IG51bGxcIiAvPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwiIXN0eWxlPy5pbWFnZSB8fCAoISFzdHlsZT8uaW1hZ2UgJiYgc3R5bGU/LmltYWdlID09PSAnJylcIiBjbGFzcz1cIm5vLWltYWdlXCI+XG4gICAgICAgICAgPG1hdC1pY29uPndhbGxwYXBlcjwvbWF0LWljb24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwibmFtZVwiPnt7c3R5bGUubmFtZSB8IHRyYW5zbGF0ZX19PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cbiJdfQ==